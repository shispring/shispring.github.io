<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Anolis OS 8安装中文字符集</title>
    <url>/2024/08/28/Anolis-OS-8%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E9%9B%86/</url>
    <content><![CDATA[<h2 id="1-查看当前系统字符集"><a href="#1-查看当前系统字符集" class="headerlink" title="1 查看当前系统字符集"></a>1 查看当前系统字符集</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看环境字符集</span></span><br><span class="line">locale</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看平台所有字符集</span></span><br><span class="line">locale -a</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LANG</span></span><br><span class="line">en_US.UTF-8</span><br></pre></td></tr></table></figure>

<h2 id="2-安装字符集"><a href="#2-安装字符集" class="headerlink" title="2 安装字符集"></a>2 安装字符集</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装字符集</span></span><br><span class="line">yum install -y glibc-common</span><br><span class="line">yum install -y langpacks-zh_CN</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改/etc/locale.conf文件</span></span><br><span class="line"><span class="built_in">cat</span> /etc/locale.conf</span><br><span class="line">en_US.UTF-8</span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;s#^LANG=.*#LANG=&quot;zh_CN.utf8&quot;#&#x27;</span> /etc/locale.conf</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/locale.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看新的字符集</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LANG</span></span><br><span class="line">zh_CN.UTF-8</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>CA签发证书</title>
    <url>/2024/10/18/CA%E7%AD%BE%E5%8F%91%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p>CA（Certificate Authority），翻译过来就叫作证书颁发机构。用于实现数字证书的管理，包括证书颁发、吊销、续期等。PKI（Registration Authority ），翻译过来叫作注册机构，负责接收请求并验证实体的身份，然后指示 CA 为其颁发或撤销证书。CA和PKI的关系：PKI 是一个更大的框架或系统，而 CA 是 PKI 中的一个核心组件。</p>
<h2 id="1、安装openSSL"><a href="#1、安装openSSL" class="headerlink" title="1、安装openSSL"></a>1、安装openSSL</h2><h2 id="2、创建目录"><a href="#2、创建目录" class="headerlink" title="2、创建目录"></a>2、创建目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /etc/pki/CA</span><br><span class="line"><span class="built_in">mkdir</span> /etc/pki/CA</span><br><span class="line"><span class="built_in">mkdir</span> /etc/pki/CA/&#123;certs,crl,newcerts,private,csr&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#certs目录：用于统一存放CA签发的证书</span></span><br><span class="line"><span class="comment">#crl目录：用于存放一个证书吊销文件，这个文件的内容记录了吊销证书的信息</span></span><br><span class="line"><span class="comment">#newcerts目录：这个目录存放的是刚创建的证书</span></span><br><span class="line"><span class="comment">#private：存放的是CA的私钥文件</span></span><br><span class="line"><span class="comment">#csr:单独给客户的证书请求文件创建了一个目录，用于保存客户端传输过来的CSR文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这个文件初始时一定要为空，不然后期没法颁发证书</span></span><br><span class="line"><span class="built_in">touch</span>  /etc/pki/CA/index.txt</span><br><span class="line"><span class="built_in">echo</span> 01 &gt; /etc/pki/CA/serial</span><br><span class="line"></span><br><span class="line"><span class="comment">#文件说明：</span></span><br><span class="line"><span class="comment">#index.txt文件: 是OpenSSL用来跟踪哪些证书已经被签署的数据库。对于一个新的CA，index.txt应该是一个空文件，如果这个文件非空，签发证书的时候会失败。</span></span><br><span class="line"><span class="comment">#serial文件：存放颁发证书的编号的文件，每当签发新证书时，OpenSSL会读取这个文件中的值作为其序列号，并增加该值以供下次使用，所以需要给他赋初值。</span></span><br></pre></td></tr></table></figure>

<h2 id="3、编辑配置文件"><a href="#3、编辑配置文件" class="headerlink" title="3、编辑配置文件"></a>3、编辑配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过 openssl version -d 来查找OpenSSL的相关文件</span></span><br><span class="line">openssl version -d</span><br><span class="line"><span class="built_in">ls</span> /etc/pki/tls</span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> /etc/pki/tls/openssl.cnf /etc/pki/tls/openssl.cnf.back</span><br></pre></td></tr></table></figure>

<ul>
<li>vim &#x2F;etc&#x2F;pki&#x2F;tls&#x2F;openssl.cnf</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># [ ca ]指定默认的 CA 配置区段，因为可能会存在多个 CA 配置区段，用于不同的目的或者不同的证书策略</span></span><br><span class="line">[ ca ]</span><br><span class="line"><span class="comment"># 定义默认的CA设置部分名称</span></span><br><span class="line">default_ca = CA_default</span><br><span class="line"></span><br><span class="line"><span class="comment"># [ CA_default ] 定义了关于证书颁发机构(CA)的默认设置和相关文件路径。</span></span><br><span class="line">[ CA_default ]</span><br><span class="line"><span class="comment"># 定义CA的主目录。</span></span><br><span class="line"><span class="built_in">dir</span> = /etc/pki/CA</span><br><span class="line"><span class="comment"># 已签发的证书的存储位置</span></span><br><span class="line">certs = <span class="variable">$dir</span>/certs</span><br><span class="line"><span class="comment"># 新证书的默认存放位置</span></span><br><span class="line">new_certs_dir = <span class="variable">$dir</span>/newcerts</span><br><span class="line"><span class="comment">#  用于存储证书签发信息的数据库文件的位置</span></span><br><span class="line">database = <span class="variable">$dir</span>/index.txt</span><br><span class="line"><span class="comment"># CA的证书位置</span></span><br><span class="line">certificate = <span class="variable">$dir</span>/certs/cacert.pem</span><br><span class="line"><span class="comment"># CA的私钥位置</span></span><br><span class="line">private_key = <span class="variable">$dir</span>/private/cakey.key</span><br><span class="line"><span class="comment"># 存储当前证书序列号的文件位置</span></span><br><span class="line">serial = <span class="variable">$dir</span>/serial</span><br><span class="line"><span class="comment"># 默认证书有效期</span></span><br><span class="line">default_days = 3650</span><br><span class="line"><span class="comment"># 默认使用的消息摘要算</span></span><br><span class="line">default_md = sha256</span><br><span class="line"><span class="comment"># 决定是否保留从证书请求(CSR)中传入的Distinguished Name(DN)的顺序</span></span><br><span class="line">preserve = no</span><br><span class="line">default_crl_days = 7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 策略定义，确保以下部分存在</span></span><br><span class="line">policy = policy_match</span><br><span class="line"></span><br><span class="line">[ policy_match ]</span><br><span class="line">countryName            = match</span><br><span class="line">stateOrProvinceName    = optional</span><br><span class="line">organizationName       = match</span><br><span class="line">organizationalUnitName = optional</span><br><span class="line">commonName             = supplied</span><br><span class="line">emailAddress           = optional</span><br><span class="line"></span><br><span class="line"><span class="comment"># [ req ]定义了与生成证书请求文件（也称为Certificate Signing Request，简称CSR）相关的默认设置</span></span><br><span class="line">[ req ]</span><br><span class="line"><span class="comment"># 生成新私钥时使用的默认位数</span></span><br><span class="line">default_bits = 2048</span><br><span class="line"><span class="comment"># 是否在创建证书请求时提示用户输入详细信息</span></span><br><span class="line"><span class="comment"># no表示使用 openssl req 命令创建新的CSR或证书时，将不会被提示输入任何DN字段，会使用 [ dn ] 部分提供的默认值。</span></span><br><span class="line">prompt = no</span><br><span class="line"><span class="comment"># 用于证书请求的默认消息摘要算法</span></span><br><span class="line">default_md = sha256</span><br><span class="line"><span class="comment"># 告诉OpenSSL使用配置文件中的[ dn ]部分作为CSR的默认字段值</span></span><br><span class="line">distinguished_name = dn</span><br><span class="line"></span><br><span class="line"><span class="comment"># [ dn ] 定义了默认的Distinguished Name（可分辨名称）属性和它们的值</span></span><br><span class="line"><span class="comment"># C：国家 ST：省 L：市 O：通常是一个公司或机构的全名 OU：组织内部的一个特定部门或单位</span></span><br><span class="line"><span class="comment"># CN：在 SSL/TLS 证书的上下文中通常表示证书意图保护的域名emailAddress：邮箱</span></span><br><span class="line">[ dn ]</span><br><span class="line">C = CN</span><br><span class="line">ST = BeiJing</span><br><span class="line">L = BeiJing</span><br><span class="line">O = xxx</span><br><span class="line">OU = xxx docker</span><br><span class="line">emailAddress = xxx@yyy.cn</span><br><span class="line">CN = yyy.cn</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4、自签名证书生成"><a href="#4、自签名证书生成" class="headerlink" title="4、自签名证书生成"></a>4、自签名证书生成</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先生成私钥</span></span><br><span class="line">openssl genpkey -algorithm RSA -out /etc/pki/CA/private/cakey.key</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据生成得私钥创建一个新的根证书,使用这个证书来签署其它得证书</span></span><br><span class="line">openssl req -key /etc/pki/CA/private/cakey.key -new -x509 -days 7300 -out /etc/pki/CA/certs/cacert.pem</span><br><span class="line"></span><br><span class="line">tree /etc/pki/CA</span><br></pre></td></tr></table></figure>

<h2 id="5、CA颁发证书"><a href="#5、CA颁发证书" class="headerlink" title="5、CA颁发证书"></a>5、CA颁发证书</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先创建一个目录存放相关文件</span></span><br><span class="line"><span class="built_in">cd</span> &amp;&amp; <span class="built_in">mkdir</span> tom &amp;&amp; <span class="built_in">cd</span> tom</span><br><span class="line"></span><br><span class="line"><span class="comment">#一步到位生成私钥和CSR</span></span><br><span class="line">openssl req -new -keyout tom.key -out tom_req.csr -nodes</span><br><span class="line"><span class="comment">#生成私钥的时候会要求输入一个密码，不输入的话可能会提示error，可以通过 -nodes 参数来不输入密码</span></span><br><span class="line"><span class="comment">#一步到位生成私钥和CSR，-keyout clientkey.pem 选项生成一个新的私钥，然后根据生成的私钥创建证书请求文件</span></span><br><span class="line"><span class="comment">#在CA上生成的CSR，配置文件里面指定了请求者的标识信息（如：组织、位置、国家、域名等，所以这里没有提示输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#拷贝到csr路径</span></span><br><span class="line"><span class="built_in">cp</span> ./tom_req.csr /etc/pki/CA/csr/</span><br><span class="line"></span><br><span class="line"><span class="comment">#CA签发证书，通过 -bath参数实现签署证书时自动确认，如果初始化CA环境的时候，index.txt这个数据库文件不为空，那么此时签署证书不会成功，也不会有任何错误提示。</span></span><br><span class="line">openssl ca -batch -<span class="keyword">in</span> /etc/pki/CA/csr/tom_req.csr -out /etc/pki/CA/certs/tom.pem</span><br><span class="line"></span><br><span class="line">tree /etc/pki/CA</span><br><span class="line">/etc/pki/CA</span><br><span class="line">├── certs</span><br><span class="line">│   ├── cacert.pem</span><br><span class="line">│   ├── tom1.pem</span><br><span class="line">│   └── tom.pem</span><br><span class="line">├── crl</span><br><span class="line">│   └── crl.pem</span><br><span class="line">├── csr</span><br><span class="line">│   └── tom_req.csr</span><br><span class="line">├── index.txt</span><br><span class="line">├── index.txt.attr</span><br><span class="line">├── index.txt.attr.old</span><br><span class="line">├── index.txt.old</span><br><span class="line">├── newcerts</span><br><span class="line">│   ├── 01.pem</span><br><span class="line">├── private</span><br><span class="line">│   └── cakey.key</span><br><span class="line">├── serial</span><br><span class="line">└── serial.old</span><br><span class="line"></span><br><span class="line"><span class="comment">#idnex.txt文件用于存储CA签发的所有证书，一行代表一个证书。</span></span><br><span class="line"><span class="comment">#该文件包含了index.txt文件的一些属性，unique_subject = yes表示在index.txt数据库中的每个主题应该是唯一的，即不允许有两个具有相同主题的证书</span></span><br><span class="line"><span class="comment">#index.txt.old存放上一个证书的数据库信息</span></span><br><span class="line"><span class="comment">#serial.old该文件存放上一个证书的编号信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查阅证书内容</span></span><br><span class="line">openssl req -noout -text -<span class="keyword">in</span> /etc/pki/CA/certs/tom.pem</span><br></pre></td></tr></table></figure>

<h2 id="6、注销证书"><a href="#6、注销证书" class="headerlink" title="6、注销证书"></a>6、注销证书</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#吊销证书</span></span><br><span class="line">openssl ca -revoke /etc/pki/CA/certs/tom.pem</span><br><span class="line"><span class="comment">#吊销后，需要重新生成 CRL 文件：</span></span><br><span class="line">openssl ca -gencrl -out /etc/pki/CA/crl/crl.pem</span><br><span class="line"></span><br><span class="line"><span class="comment">#验证</span></span><br><span class="line">openssl crl -<span class="keyword">in</span> /etc/pki/CA/crl/crl.pem -text -noout</span><br><span class="line"></span><br><span class="line">openssl verify -crl_check -CAfile /etc/pki/CA/certs/cacert.pem -CRLfile /etc/pki/CA/crl/crl.pem /etc/pki/CA/certs/tom.pem</span><br><span class="line"><span class="comment">#说明</span></span><br><span class="line">•	-crl_check：启用 CRL 检查。</span><br><span class="line">•	-CAfile：指定 CA 根证书。</span><br><span class="line">•	-CRLfile：指定 CRL 文件。</span><br></pre></td></tr></table></figure>

<h2 id="常见后缀"><a href="#常见后缀" class="headerlink" title="常见后缀"></a>常见后缀</h2><ul>
<li>.key：一般私钥就以 .key 结尾</li>
<li>.pem：新生成的证书一般以 .pem 结尾。pem是 Privacy Enhanced Mail 的缩写，是一种文件格式，可以包含任何类型的证书或密钥。这种格式的文件类容是BASE64编码显示的，并在开始和结束时由”—–BEGIN…”和”—–END…”标记包围</li>
<li>.csr：证书请求文件使用csr结尾，csr是Certificate Signing Request的缩写</li>
<li>.crl：这是CA用于列出已被撤销的证书的文件常用的后缀，是Certificate Revocation List的缩写</li>
</ul>
<hr>
<h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><table>
<thead>
<tr>
<th>文件名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>ca.crt</code></td>
<td>提供给客户端信任（例如放入系统 trusted roots、浏览器、curl、kubelet）</td>
</tr>
<tr>
<td><code>server.crt</code></td>
<td>绑定给 Nginx&#x2F;Ingress&#x2F;Harbor&#x2F;Rancher 等服务</td>
</tr>
<tr>
<td><code>server.key</code></td>
<td>绑定给服务，搭配 server.crt 使用</td>
</tr>
<tr>
<td><code>openssl.cnf</code></td>
<td>生成 SAN 字段的重要配置</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line"># ---------- 配置区 ----------</span><br><span class="line"># 通用变量，可按需修改</span><br><span class="line">OUTPUT_DIR=&quot;./certs&quot;</span><br><span class="line">CA_KEY=&quot;$OUTPUT_DIR/ca.key&quot;</span><br><span class="line">CA_CERT=&quot;$OUTPUT_DIR/ca.crt&quot;</span><br><span class="line">SERVER_KEY=&quot;$OUTPUT_DIR/server.key&quot;</span><br><span class="line">SERVER_CSR=&quot;$OUTPUT_DIR/server.csr&quot;</span><br><span class="line">SERVER_CERT=&quot;$OUTPUT_DIR/server.crt&quot;</span><br><span class="line">OPENSSL_CNF=&quot;$OUTPUT_DIR/openssl.cnf&quot;</span><br><span class="line"></span><br><span class="line"># SAN 配置：DNS 和 IP 可自由增减</span><br><span class="line">DNS_NAMES=(</span><br><span class="line">  &quot;*.xiaohong.net&quot;</span><br><span class="line">  &quot;harbor.xiaohong.net&quot;</span><br><span class="line">  &quot;*.harbor.xiaohong.net&quot;</span><br><span class="line">  &quot;k8s.xiaohong.net&quot;</span><br><span class="line">  &quot;*.k8s.xiaohong.net&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">IP_ADDRS=(</span><br><span class="line">  &quot;10.0.0.1&quot;</span><br><span class="line">  &quot;192.168.1.100&quot;</span><br><span class="line">)</span><br><span class="line"># ---------- 配置区结束 ----------</span><br><span class="line"></span><br><span class="line">log() &#123;</span><br><span class="line">  echo -e &quot;\033[1;32m[INFO]\033[0m $1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run_cmd() &#123;</span><br><span class="line">  echo -e &quot;\033[1;34m[CMD]\033[0m $1&quot;</span><br><span class="line">  eval &quot;$1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prepare_dir() &#123;</span><br><span class="line">  log &quot;创建输出目录：$OUTPUT_DIR&quot;</span><br><span class="line">  mkdir -p &quot;$OUTPUT_DIR&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generate_openssl_cnf() &#123;</span><br><span class="line">  log &quot;生成 openssl.cnf 文件（包含 SAN）&quot;</span><br><span class="line">  &#123;</span><br><span class="line">    echo &quot;[ req ]&quot;</span><br><span class="line">    echo &quot;default_bits       = 2048&quot;</span><br><span class="line">    echo &quot;distinguished_name = req_distinguished_name&quot;</span><br><span class="line">    echo &quot;req_extensions     = req_ext&quot;</span><br><span class="line">    echo &quot;prompt             = no&quot;</span><br><span class="line">    echo &quot;&quot;</span><br><span class="line">    echo &quot;[ req_distinguished_name ]&quot;</span><br><span class="line">    echo &quot;C  = CN&quot;</span><br><span class="line">    echo &quot;ST = Beijing&quot;</span><br><span class="line">    echo &quot;L  = Beijing&quot;</span><br><span class="line">    echo &quot;O  = XiaoHong&quot;</span><br><span class="line">    echo &quot;OU = DevOps&quot;</span><br><span class="line">    echo &quot;CN = *.xiaohong.net&quot;</span><br><span class="line">    echo &quot;&quot;</span><br><span class="line">    echo &quot;[ req_ext ]&quot;</span><br><span class="line">    echo &quot;subjectAltName = @alt_names&quot;</span><br><span class="line">    echo &quot;&quot;</span><br><span class="line">    echo &quot;[ alt_names ]&quot;</span><br><span class="line"></span><br><span class="line">    i=1</span><br><span class="line">    for dns in &quot;$&#123;DNS_NAMES[@]&#125;&quot;; do</span><br><span class="line">      echo &quot;DNS.$&#123;i&#125; = $dns&quot;</span><br><span class="line">      ((i++))</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    j=1</span><br><span class="line">    for ip in &quot;$&#123;IP_ADDRS[@]&#125;&quot;; do</span><br><span class="line">      echo &quot;IP.$&#123;j&#125; = $ip&quot;</span><br><span class="line">      ((j++))</span><br><span class="line">    done</span><br><span class="line">  &#125; &gt; &quot;$OPENSSL_CNF&quot;</span><br><span class="line"></span><br><span class="line">  log &quot;已生成配置文件：$OPENSSL_CNF&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generate_ca() &#123;</span><br><span class="line">  log &quot;生成 CA 私钥和证书&quot;</span><br><span class="line">  run_cmd &quot;openssl genrsa -out $CA_KEY 4096&quot;</span><br><span class="line">  run_cmd &quot;openssl req -x509 -new -nodes -key $CA_KEY -sha256 -days 3650 -subj \&quot;/C=CN/ST=Beijing/O=XiaoHong/OU=DevOps/CN=XiaoHong-CA\&quot; -out $CA_CERT&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generate_server_cert() &#123;</span><br><span class="line">  log &quot;生成服务端私钥和 CSR&quot;</span><br><span class="line">  run_cmd &quot;openssl genrsa -out $SERVER_KEY 2048&quot;</span><br><span class="line">  run_cmd &quot;openssl req -new -key $SERVER_KEY -out $SERVER_CSR -config $OPENSSL_CNF&quot;</span><br><span class="line"></span><br><span class="line">  log &quot;用 CA 签发服务端证书（包含 SAN）&quot;</span><br><span class="line">  run_cmd &quot;openssl x509 -req -in $SERVER_CSR -CA $CA_CERT -CAkey $CA_KEY -CAcreateserial -out $SERVER_CERT -days 3650 -sha256 -extensions req_ext -extfile $OPENSSL_CNF&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">verify_cert() &#123;</span><br><span class="line">  log &quot;验证生成的服务端证书&quot;</span><br><span class="line">  run_cmd &quot;openssl x509 -in $SERVER_CERT -text -noout | grep -A 1 &#x27;Subject Alternative Name&#x27;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  prepare_dir</span><br><span class="line">  generate_openssl_cnf</span><br><span class="line">  generate_ca</span><br><span class="line">  generate_server_cert</span><br><span class="line">  verify_cert</span><br><span class="line"></span><br><span class="line">  log &quot;✅ 证书生成完毕，请查看目录：$OUTPUT_DIR&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="通配符证书的匹配规则"><a href="#通配符证书的匹配规则" class="headerlink" title="通配符证书的匹配规则"></a>通配符证书的匹配规则</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSL/TLS 通配符证书的匹配规则是单级通配符，只匹配一级子域名。</span><br><span class="line"></span><br><span class="line">  - *.xiaohong.net 匹配：api.xiaohong.net、www.xiaohong.net</span><br><span class="line">  - *.xiaohong.net 不匹配：k8s.test.xiaohong.net（二级子域名）</span><br><span class="line"></span><br><span class="line">  RFC 6125 规范</span><br><span class="line"></span><br><span class="line">  - 通配符 * 只能替代一个域名标签（label）</span><br><span class="line">  - 不能跨越多个点（.）进行匹配</span><br><span class="line">  - 通配符只能出现在最左侧位置</span><br><span class="line"></span><br><span class="line">  支持多级域名的解决方案</span><br><span class="line"></span><br><span class="line">  方案1: 多个通配符证书SAN</span><br><span class="line">  SAN扩展包含:</span><br><span class="line">  - *.xiaohong.net</span><br><span class="line">  - *.https.xiaohong.net</span><br><span class="line">  - *.api.xiaohong.net</span><br><span class="line"></span><br><span class="line">  方案2: 具体域名列表</span><br><span class="line">  SAN扩展包含:</span><br><span class="line">  - test.https.xiaohong.net</span><br><span class="line">  - prod.https.xiaohong.net</span><br><span class="line">  - dev.api.xiaohong.net</span><br><span class="line"></span><br><span class="line">  方案3: 根域名通配符（不推荐）</span><br><span class="line">  - *.net （范围过大，安全风险）</span><br><span class="line"></span><br><span class="line">  推荐: 使用方案1，为每个需要的二级域名创建对应的通配符证书条目。</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="curl请求https测试"><a href="#curl请求https测试" class="headerlink" title="curl请求https测试"></a>curl请求https测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. curl -k https://k8s.xiaohong.net</span><br><span class="line"></span><br><span class="line">场景: 域名已通过DNS或hosts文件解析</span><br><span class="line">工作原理: 使用系统域名解析，忽略证书验证错误</span><br><span class="line">注意事项:</span><br><span class="line">- 需要配置 /etc/hosts 或 DNS 解析</span><br><span class="line">- -k 跳过证书验证，存在安全风险</span><br><span class="line">- 适用于测试环境或内部网络</span><br><span class="line"></span><br><span class="line">2. curl -k --resolve k8s.xiaohong.net:443:172.16.32.27 https://k8s.xiaohong.net</span><br><span class="line"></span><br><span class="line">场景: 不想修改系统hosts文件的临时域名解析</span><br><span class="line">工作原理: curl内部域名解析覆盖，绕过系统DNS</span><br><span class="line">注意事项:</span><br><span class="line">- 不需要修改系统配置</span><br><span class="line">- 解析仅对当前curl命令生效</span><br><span class="line">- 同时支持正确的SNI和Host头设置</span><br><span class="line">- 最灵活的测试方式</span><br><span class="line"></span><br><span class="line">3. curl -H &quot;Host: k8s.xiaohong.net&quot; https://172.16.32.27:443</span><br><span class="line"></span><br><span class="line">场景: 直接访问IP但需要特定Host头</span><br><span class="line">工作原理: 直接连接IP，手动设置HTTP Host头</span><br><span class="line">注意事项:</span><br><span class="line">- SNI不匹配: TLS握手时服务器名称仍为IP，可能导致SSL错误</span><br><span class="line">- 证书验证问题: 证书CN/SAN与实际访问地址不匹配</span><br><span class="line">- 适用于HTTP代理或负载均衡场景</span><br><span class="line">- 需要 -k 参数才能忽略证书错误</span><br><span class="line"></span><br><span class="line">推荐: 方式2最适合测试自签证书的HTTPS服务</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>DNS缓存时间TTL</title>
    <url>/2024/10/12/DNS%E7%BC%93%E5%AD%98%E6%97%B6%E9%97%B4TTL/</url>
    <content><![CDATA[<p>在计算机网络中，<strong>DNS（域名系统）缓存</strong>用于加速域名解析过程，减少重复查询，提高访问速度。<strong>本地 DNS 缓存时间</strong>主要取决于以下几个因素：</p>
<ol>
<li><strong>DNS 记录的 TTL（生存时间）</strong>：<ul>
<li><strong>TTL（Time-To-Live）</strong> 是 DNS 记录中指定的一个时间值，表示该记录在缓存中可以存储的最长时间。TTL 的单位通常是秒。</li>
<li>例如，TTL 为 <code>3600</code> 秒（即 1 小时），表示该 DNS 记录在缓存中有效期为 1 小时。</li>
</ul>
</li>
<li><strong>本地 DNS 解析器的缓存策略</strong>：<ul>
<li>不同操作系统和 DNS 解析器（如 <code>systemd-resolved</code>、<code>dnsmasq</code>、<code>nscd</code> 等）可能有自己的缓存策略，可能会设置最小或最大 TTL 值，以确保缓存的灵活性和安全性。</li>
</ul>
</li>
</ol>
<h2 id="1-本地-DNS-缓存时间的常见范围"><a href="#1-本地-DNS-缓存时间的常见范围" class="headerlink" title="1. 本地 DNS 缓存时间的常见范围"></a><strong>1. 本地 DNS 缓存时间的常见范围</strong></h2><ul>
<li><strong>短 TTL</strong>：如 30 秒至 5 分钟，适用于频繁更新的记录。</li>
<li><strong>中等 TTL</strong>：如 5 分钟至 1 小时，适用于大多数动态变化的记录。</li>
<li><strong>长 TTL</strong>：如 1 小时至 24 小时，适用于较为稳定的记录。</li>
</ul>
<h2 id="2-如何查看和配置本地-DNS-缓存时间"><a href="#2-如何查看和配置本地-DNS-缓存时间" class="headerlink" title="2. 如何查看和配置本地 DNS 缓存时间"></a><strong>2. 如何查看和配置本地 DNS 缓存时间</strong></h2><p>不同操作系统和 DNS 解析器有不同的方法来查看和配置本地 DNS 缓存时间。以下是常见操作系统和解析器的具体步骤：</p>
<h3 id="a-Linux-系统"><a href="#a-Linux-系统" class="headerlink" title="a. Linux 系统"></a><strong>a. Linux 系统</strong></h3><p><strong>查看 DNS 缓存内容和 TTL：</strong></p>
<ul>
<li>具体方法取决于所使用的 DNS 缓存服务。</li>
</ul>
<ol>
<li><p>**使用 <code>systemd-resolved</code>**：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#systemctl start systemd-resolved</span></span><br><span class="line">systemd-resolve --statistics</span><br></pre></td></tr></table></figure>
<ul>
<li>查看缓存统计信息。</li>
</ul>
</li>
<li><p><strong>使用 <code>nscd</code>（Name Service Cache Daemon）</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yum install -y nscd</span></span><br><span class="line">nscd -g</span><br></pre></td></tr></table></figure>
<ul>
<li>查看缓存信息。</li>
</ul>
</li>
<li><p>**使用 <code>dnsmasq</code>**：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status dnsmasq</span><br><span class="line">dnsmasq --<span class="built_in">test</span>  <span class="comment"># 检查配置</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>清除 DNS 缓存：</strong></p>
<ol>
<li><p><strong>systemd-resolved</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemd-resolve --flush-caches</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>nscd</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart nscd</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>dnsmasq</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart dnsmasq</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>配置 DNS 客户端缓存策略：</strong></p>
<ol>
<li><p><strong>systemd-resolved</strong>：</p>
<ul>
<li>配置文件位于 <code>/etc/systemd/resolved.conf</code>。</li>
<li>可设置 <code>Cache</code> 相关参数，但通常遵循 DNS 记录的 TTL。</li>
</ul>
</li>
<li><p><strong>nscd</strong>：</p>
<ul>
<li>配置文件位于 <code>/etc/nscd.conf</code>。</li>
<li>可设置 <code>positive-time-to-live</code> 和 <code>negative-time-to-live</code>。</li>
</ul>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/nscd.conf</span><br></pre></td></tr></table></figure>
<p> 示例配置：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enable-cache hosts yes</span><br><span class="line">positive-time-to-live hosts 3600</span><br><span class="line">negative-time-to-live hosts 20</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>dnsmasq</strong>：</p>
<ul>
<li>配置文件位于 <code>/etc/dnsmasq.conf</code>。</li>
<li>可设置 <code>min-cache-ttl</code> 和 <code>max-cache-ttl</code>。</li>
</ul>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vi /etc/dnsmasq.conf</span><br></pre></td></tr></table></figure>
<p> 示例配置：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min-cache-ttl=60</span><br><span class="line">max-cache-ttl=3600</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-确认-DNS-缓存时间"><a href="#3-确认-DNS-缓存时间" class="headerlink" title="3. 确认 DNS 缓存时间"></a><strong>3. 确认 DNS 缓存时间</strong></h2><p><strong>查看特定 DNS 记录的 TTL：</strong></p>
<p>使用 <code>dig</code> 命令可以查看 DNS 记录的 TTL 值。<br>在 Anolis OS 8 上安装 dig 命令通常通过安装 bind-utils 包来实现<br>yum install bind-utils -y </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig example.com</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">example.com.     3600    IN      A       93.184.216.34</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>上述输出中，<code>3600</code> 表示该 DNS 记录的 TTL 为 3600 秒（1 小时）。</li>
</ul>
<p><strong>综合判断缓存时间：</strong></p>
<ul>
<li>本地 DNS 缓存时间通常不会超过 DNS 记录本身的 TTL。</li>
<li>某些解析器可能会调整实际缓存时间，如设置最小 TTL 或最大 TTL。</li>
</ul>
<h2 id="4-实际案例演示"><a href="#4-实际案例演示" class="headerlink" title="4. 实际案例演示"></a><strong>4. 实际案例演示</strong></h2><p>以下是一个在 Linux 系统上使用 <code>systemd-resolved</code> 配置和查看 DNS 缓存时间的示例：</p>
<p><strong>查看当前 DNS 缓存统计：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemd-resolve --statistics</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Global</span><br><span class="line">         LLMNR setting: yes</span><br><span class="line">  MulticastDNS setting: no</span><br><span class="line">    DNSOverTLS setting: no</span><br><span class="line">        DNSSEC setting: no</span><br><span class="line">      DNSSEC supported: no</span><br><span class="line"></span><br><span class="line">Per-Link Statistics</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>清除 DNS 缓存：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemd-resolve --flush-caches</span><br></pre></td></tr></table></figure>

<p><strong>查看某个域名的 TTL：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig example.com +nocmd +noall +answer</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">example.com.     3600    IN      A       93.184.216.34</span><br></pre></td></tr></table></figure>

<h2 id="5-最佳实践"><a href="#5-最佳实践" class="headerlink" title="5. 最佳实践"></a><strong>5. 最佳实践</strong></h2><ol>
<li><strong>合理设置 DNS 记录的 TTL</strong>：<ul>
<li>根据应用需求和域名更新频率，合理设置 TTL。较低的 TTL 适用于频繁变动的记录，较高的 TTL 则适用于稳定的记录。</li>
</ul>
</li>
<li><strong>优化本地 DNS 解析器的缓存策略</strong>：<ul>
<li>根据网络环境和应用需求，调整本地解析器的最小和最大缓存时间，平衡缓存效率与更新灵活性。</li>
</ul>
</li>
<li><strong>定期清理 DNS 缓存</strong>：<ul>
<li>在进行 DNS 变更后，及时清理本地 DNS 缓存，确保新配置生效。</li>
</ul>
</li>
<li><strong>监控 DNS 解析性能</strong>：<ul>
<li>使用监控工具（如 Prometheus、Grafana）监控 DNS 解析的性能和缓存命中率，优化 DNS 配置。</li>
</ul>
</li>
<li><strong>使用可靠的 DNS 解析器</strong>：<ul>
<li>选择性能稳定、支持高级功能（如 DNSSEC、负载均衡）的 DNS 解析器，提升网络稳定性和安全性。</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Debian系统更新安装源</title>
    <url>/2024/09/26/Debian%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E5%AE%89%E8%A3%85%E6%BA%90/</url>
    <content><![CDATA[<h2 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">#注意查看系统的版本</span><br><span class="line">cat /etc/os-release</span><br><span class="line"><span class="variable constant_">PRETTY_NAME</span>=<span class="string">&quot;Debian GNU/Linux 11 (bullseye)&quot;</span></span><br><span class="line"><span class="variable constant_">NAME</span>=<span class="string">&quot;Debian GNU/Linux&quot;</span></span><br><span class="line"><span class="variable constant_">VERSION_ID</span>=<span class="string">&quot;11&quot;</span></span><br><span class="line"><span class="variable constant_">VERSION</span>=<span class="string">&quot;11 (bullseye)&quot;</span></span><br><span class="line"><span class="variable constant_">VERSION_CODENAME</span>=bullseye</span><br></pre></td></tr></table></figure>

<h2 id="变更apt源"><a href="#变更apt源" class="headerlink" title="变更apt源"></a>变更apt源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 11版本</span></span><br><span class="line"><span class="comment">#https://developer.aliyun.com/mirror/debian?spm=a2c6h.13651102.0.0.4bc81b11TwGuai</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt; /etc/apt/sources.list</span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/debian/ bullseye main non-free contrib</span></span><br><span class="line"><span class="string">deb-src https://mirrors.aliyun.com/debian/ bullseye main non-free contrib</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/debian-security/ bullseye-security main</span></span><br><span class="line"><span class="string">deb-src https://mirrors.aliyun.com/debian-security/ bullseye-security main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib</span></span><br><span class="line"><span class="string">deb-src https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib</span></span><br><span class="line"><span class="string">deb-src https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#12版本</span></span><br><span class="line"><span class="comment">#https://wph.im/272.html</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt; /etc/apt/sources.list</span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/debian/ bookworm main non-free non-free-firmware contrib</span></span><br><span class="line"><span class="string">deb-src https://mirrors.aliyun.com/debian/ bookworm main non-free non-free-firmware contrib</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/debian-security/ bookworm-security main</span></span><br><span class="line"><span class="string">deb-src https://mirrors.aliyun.com/debian-security/ bookworm-security main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/debian/ bookworm-updates main non-free non-free-firmware contrib</span></span><br><span class="line"><span class="string">deb-src https://mirrors.aliyun.com/debian/ bookworm-updates main non-free non-free-firmware contrib</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">deb https://mirrors.aliyun.com/debian/ bookworm-backports main non-free non-free-firmware contrib</span></span><br><span class="line"><span class="string">deb-src https://mirrors.aliyun.com/debian/ bookworm-backports main non-free non-free-firmware contrib</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行更新</span></span><br><span class="line">apt update &amp;&amp; apt upgrade</span><br></pre></td></tr></table></figure>

<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装top、ps、pstree、ping、ss</span></span><br><span class="line">apt-get install -y  ethtool htop net-tools telnet inetutils-ping procps psmisc iproute2</span><br><span class="line"></span><br><span class="line"><span class="comment">#ss 命令</span></span><br><span class="line">ss -tlp</span><br><span class="line">ss -t -a </span><br><span class="line">ss -lp | grep 3306</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>OpenSSL 支持的密钥类型和格式</title>
    <url>/2024/10/18/OpenSSL-%E6%94%AF%E6%8C%81%E7%9A%84%E5%AF%86%E9%92%A5%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>OpenSSL 证书链</strong></p>
<blockquote>
<p><a href="https://darutk.medium.com/illustrated-x-509-certificate-84aece2c5c2e">https://darutk.medium.com/illustrated-x-509-certificate-84aece2c5c2e</a></p>
</blockquote>
<hr>
<p><strong>OpenSSL 密钥类型与格式对比表</strong></p>
<p><strong>1. 密钥类型对比</strong></p>
<table>
<thead>
<tr>
<th><strong>密钥类型</strong></th>
<th><strong>算法描述</strong></th>
<th><strong>典型应用场景</strong></th>
<th><strong>生成命令示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>RSA</strong></td>
<td>基于大整数分解，常见的非对称加密算法</td>
<td>HTTPS、TLS&#x2F;SSL 证书、SSH、公钥加密</td>
<td>openssl genrsa -out rsa_key.pem 2048</td>
</tr>
<tr>
<td><strong>ECC</strong></td>
<td>椭圆曲线密码学，短密钥更高效</td>
<td>IoT、移动设备、TLS 1.3</td>
<td>openssl ecparam -genkey -name prime256v1 -out ec_key.pem</td>
</tr>
<tr>
<td><strong>DSA</strong></td>
<td>基于离散对数的数字签名算法</td>
<td>数字签名（DNSSEC 等）</td>
<td>openssl dsaparam -genkey 2048 -out dsa_key.pem</td>
</tr>
<tr>
<td><strong>DH</strong></td>
<td>Diffie-Hellman 算法，用于密钥交换</td>
<td>VPN、IPsec 加密通道</td>
<td>openssl dhparam -out dh_key.pem 2048</td>
</tr>
<tr>
<td><strong>ED25519</strong></td>
<td>高效的椭圆曲线签名算法（无须参数生成）</td>
<td>SSH、TLS 1.3、轻量级签名</td>
<td>openssl genpkey -algorithm ED25519 -out ed25519_key.pem</td>
</tr>
<tr>
<td><strong>X25519</strong></td>
<td>专用于密钥交换的现代椭圆曲线算法</td>
<td>TLS 1.3 密钥交换、ECDH</td>
<td>openssl genpkey -algorithm X25519 -out x25519_key.pem</td>
</tr>
<tr>
<td><strong>GOST</strong></td>
<td>俄罗斯国家标准算法</td>
<td>加密通信和签名（如 GOST SSL 证书）</td>
<td>需 GOST 扩展支持</td>
</tr>
<tr>
<td><strong>SM2</strong></td>
<td>中国国家标准（基于 ECC）</td>
<td>国密协议（如银行和政府应用）</td>
<td>openssl genpkey -algorithm SM2 -out sm2_key.pem</td>
</tr>
</tbody></table>
<p><strong>2. 密钥格式对比</strong></p>
<table>
<thead>
<tr>
<th><strong>格式</strong></th>
<th><strong>描述</strong></th>
<th><strong>典型应用场景</strong></th>
<th><strong>加密支持</strong></th>
<th><strong>转换命令示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>PEM</strong></td>
<td>Base64 编码，文本格式，以 —–BEGIN 开头</td>
<td>TLS&#x2F;SSL 证书、服务器私钥存储</td>
<td>支持</td>
<td>openssl rsa -in rsa_key.pem -out private_key.pem -outform PEM</td>
</tr>
<tr>
<td><strong>DER</strong></td>
<td>二进制格式，适合嵌入式系统</td>
<td>嵌入式系统、低级通信传输</td>
<td>不支持</td>
<td>openssl rsa -in rsa_key.pem -out private_key.der -outform DER</td>
</tr>
<tr>
<td><strong>PKCS#8</strong></td>
<td>私钥标准格式，支持多种算法（如 RSA、ECC）</td>
<td>服务器密钥存储、跨平台交换</td>
<td>支持</td>
<td>openssl pkcs8 -topk8 -in rsa_key.pem -out pkcs8_key.pem</td>
</tr>
<tr>
<td><strong>PKCS#12</strong></td>
<td>包含证书链和私钥的打包格式（.p12&#x2F;.pfx）</td>
<td>客户端证书、VPN、S&#x2F;MIME</td>
<td>支持</td>
<td>openssl pkcs12 -export -out cert.p12 -inkey ec_key.pem -in cert.pem</td>
</tr>
<tr>
<td><strong>OpenSSH</strong></td>
<td>专用于 SSH 的密钥格式</td>
<td>SSH 登录和密钥交换</td>
<td>支持</td>
<td>ssh-keygen -t ed25519 -f ~&#x2F;.ssh&#x2F;id_ed25519</td>
</tr>
<tr>
<td><strong>JWK</strong></td>
<td>JSON Web Key，用于 Web 应用密钥存储和传输</td>
<td>OAuth2、JWT 加密</td>
<td>支持</td>
<td>使用专用库生成</td>
</tr>
</tbody></table>
<p><strong>3. 应用场景推荐</strong></p>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>推荐密钥类型</strong></th>
<th><strong>推荐格式</strong></th>
<th><strong>命令示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Web 服务器（Nginx&#x2F;Apache）</strong></td>
<td>RSA 或 ECC</td>
<td>PEM、PKCS#8</td>
<td>openssl pkcs8 -topk8 -in rsa_key.pem -out server_key.pem</td>
</tr>
<tr>
<td><strong>IoT 设备和移动端</strong></td>
<td>ECC（prime256v1）</td>
<td>PKCS#8</td>
<td>openssl ecparam -genkey -name prime256v1 -out ec_key.pem</td>
</tr>
<tr>
<td><strong>VPN 客户端证书</strong></td>
<td>RSA 或 ECC</td>
<td>PKCS#12</td>
<td>openssl pkcs12 -export -out vpn_cert.p12 -inkey ec_key.pem -in cert.pem</td>
</tr>
<tr>
<td><strong>SSH 登录</strong></td>
<td>ED25519 或 RSA</td>
<td>OpenSSH</td>
<td>ssh-keygen -t ed25519 -f ~&#x2F;.ssh&#x2F;id_ed25519</td>
</tr>
<tr>
<td><strong>TLS 1.3 密钥交换</strong></td>
<td>X25519</td>
<td>PKCS#8</td>
<td>openssl genpkey -algorithm X25519 -out x25519_key.pem</td>
</tr>
<tr>
<td><strong>国密应用（SM2 签名）</strong></td>
<td>SM2</td>
<td>PKCS#8</td>
<td>openssl genpkey -algorithm SM2 -out sm2_key.pem</td>
</tr>
</tbody></table>
<p><strong>4. 实现案例</strong></p>
<p><strong>1. 生成 RSA 密钥并转换为 PKCS#8 格式</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out rsa_key.pem 2048</span><br><span class="line"></span><br><span class="line">openssl pkcs8 -topk8 -<span class="keyword">in</span> rsa_key.pem -out rsa_key_pkcs8.pem -nocrypt</span><br></pre></td></tr></table></figure>

<p><strong>2. 生成 ECC 私钥并打包为 PKCS#12</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl ecparam -genkey -name prime256v1 -out ec_key.pem</span><br><span class="line"></span><br><span class="line">openssl req -new -x509 -key ec_key.pem -out ec_cert.pem -days 365</span><br><span class="line"></span><br><span class="line">openssl pkcs12 -<span class="built_in">export</span> -out ec_cert.p12 -inkey ec_key.pem -<span class="keyword">in</span> ec_cert.pem</span><br></pre></td></tr></table></figure>

<p><strong>3. 生成 ED25519 密钥用于 SSH</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure>

<p><strong>4. 查看证书</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in ./ca.crt -text -noout</span><br></pre></td></tr></table></figure>

<p><strong>5. 总结与建议</strong></p>
<p>•<strong>RSA</strong>：经典且兼容性好，适合 Web 服务器和通用加密应用。</p>
<p>•<strong>ECC</strong>：更高效、密钥短，适用于 IoT 和现代 TLS。</p>
<p>•<strong>ED25519&#x2F;X25519</strong>：轻量级和高性能，推荐用于 SSH 和 TLS 1.3。</p>
<p>•<strong>SM2&#x2F;GOST</strong>：满足特定国家或行业的加密标准。</p>
<p>•<strong>PKCS#8 与 PKCS#12</strong>：PKCS#8 适合服务器端私钥存储，PKCS#12 常用于客户端证书传输。</p>
<p>选择合适的密钥类型与格式可以在 <strong>安全性、性能、兼容性</strong> 之间取得良好的平衡。</p>
<hr>
<h2 id="openssh-套件"><a href="#openssh-套件" class="headerlink" title="openssh 套件"></a>openssh 套件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.rockylinux.cn/notes/gnu-linux-basic-services-openssh-software-suite.html</span><br><span class="line"></span><br><span class="line">## /etc/ssh/sshd_config 配置</span><br><span class="line">grep -v -E &quot;^#|^$&quot; /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>openssl</category>
      </categories>
  </entry>
  <entry>
    <title>Pod状态及原因</title>
    <url>/2024/10/14/Pod%E7%8A%B6%E6%80%81%E5%8F%8A%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<p>以下是 Kubernetes <strong>Pod 各种状态</strong>及其<strong>原因分析</strong>的详细总结：</p>
<hr>
<h3 id="1-Pending"><a href="#1-Pending" class="headerlink" title="1. Pending"></a><strong>1. Pending</strong></h3><p><strong>解释</strong>：Pod 被成功创建，但其中的一个或多个容器尚未启动。<br><strong>可能原因</strong>：</p>
<ul>
<li>没有足够的资源（CPU、内存）调度到合适的节点。  </li>
<li>存在节点污点，Pod 无法容忍（Taints and Tolerations）。  </li>
<li>镜像下载缓慢或失败（如网络问题或镜像仓库不可用）。  </li>
<li>存在 PVC（Persistent Volume Claim）绑定问题。</li>
</ul>
<hr>
<h3 id="2-Running"><a href="#2-Running" class="headerlink" title="2. Running"></a><strong>2. Running</strong></h3><p><strong>解释</strong>：Pod 中的所有容器已启动并正在运行。<br><strong>可能原因</strong>：</p>
<ul>
<li>一切正常，Pod 正在按预期工作。  </li>
<li>若部分容器不断重启，则可能与健康检查失败有关（检查 Liveness 和 Readiness Probes）。</li>
</ul>
<hr>
<h3 id="3-CrashLoopBackOff"><a href="#3-CrashLoopBackOff" class="headerlink" title="3. CrashLoopBackOff"></a><strong>3. CrashLoopBackOff</strong></h3><p><strong>解释</strong>：容器在启动后不断崩溃，Kubelet 正在尝试重启它。<br><strong>可能原因</strong>：</p>
<ul>
<li>应用程序的错误配置或依赖缺失导致容器崩溃。  </li>
<li>容器中的应用程序无法正确初始化（可能因为端口占用或数据库连接失败）。  </li>
<li>Liveness Probe 检查失败导致 Kubelet 不断重启容器。</li>
</ul>
<hr>
<h3 id="4-ImagePullBackOff"><a href="#4-ImagePullBackOff" class="headerlink" title="4. ImagePullBackOff"></a><strong>4. ImagePullBackOff</strong></h3><p><strong>解释</strong>：Kubernetes 无法拉取容器镜像，正在等待重试。<br><strong>可能原因</strong>：</p>
<ul>
<li>镜像名或版本标记（tag）错误。  </li>
<li>镜像仓库不可访问（网络问题或仓库服务中断）。  </li>
<li>私有镜像仓库的认证失败（未正确配置 Secret）。</li>
</ul>
<hr>
<h3 id="5-ErrImagePull"><a href="#5-ErrImagePull" class="headerlink" title="5. ErrImagePull"></a><strong>5. ErrImagePull</strong></h3><p><strong>解释</strong>：尝试拉取镜像时发生错误。<br><strong>可能原因</strong>：</p>
<ul>
<li>镜像不存在于指定的仓库中。  </li>
<li>镜像仓库地址错误或不可访问。  </li>
<li>网络问题导致拉取失败。</li>
</ul>
<hr>
<h3 id="6-ErrImageNeverPull"><a href="#6-ErrImageNeverPull" class="headerlink" title="6. ErrImageNeverPull"></a><strong>6. ErrImageNeverPull</strong></h3><p><strong>解释</strong>：镜像策略被设置为 <code>ImagePullPolicy: Never</code>，但镜像在本地不存在。<br><strong>可能原因</strong>：</p>
<ul>
<li>配置错误导致 Kubernetes 无法从本地找到镜像。  </li>
<li>需要将拉取策略设置为 <code>IfNotPresent</code> 或 <code>Always</code>。</li>
</ul>
<hr>
<h3 id="7-Completed"><a href="#7-Completed" class="headerlink" title="7. Completed"></a><strong>7. Completed</strong></h3><p><strong>解释</strong>：Pod 中的所有容器正常终止，且没有重启策略（适用于 <strong>Job</strong> 和 <strong>CronJob</strong>）。<br><strong>可能原因</strong>：</p>
<ul>
<li>容器执行的任务已完成，Pod 正常退出。  </li>
<li>Job 或 CronJob 工作负载按计划执行结束。</li>
</ul>
<hr>
<h3 id="8-Terminating"><a href="#8-Terminating" class="headerlink" title="8. Terminating"></a><strong>8. Terminating</strong></h3><p><strong>解释</strong>：Pod 正在终止，但未在规定时间内结束。<br><strong>可能原因</strong>：</p>
<ul>
<li>Pod 中的进程未响应 SIGTERM 信号。  </li>
<li>容器内进程未正确设置退出钩子（如未处理 terminationGracePeriodSeconds）。  </li>
<li>挂载的 Volume 无法及时卸载。</li>
</ul>
<hr>
<h3 id="9-Unknown"><a href="#9-Unknown" class="headerlink" title="9. Unknown"></a><strong>9. Unknown</strong></h3><p><strong>解释</strong>：Pod 的状态无法从 API 服务器获取。<br><strong>可能原因</strong>：</p>
<ul>
<li>节点可能与 API 服务器失去连接（网络问题或节点崩溃）。  </li>
<li>etcd 数据库不稳定，导致状态获取失败。</li>
</ul>
<hr>
<h3 id="10-Failed"><a href="#10-Failed" class="headerlink" title="10. Failed"></a><strong>10. Failed</strong></h3><p><strong>解释</strong>：Pod 中的所有容器都已终止，并且至少有一个容器以非 0 状态码退出。<br><strong>可能原因</strong>：</p>
<ul>
<li>容器内的应用程序发生崩溃。  </li>
<li>必要的依赖服务（如数据库或 API）不可用。  </li>
<li>Liveness Probe 检查失败后被 Kubernetes 终止。</li>
</ul>
<hr>
<h3 id="11-NodeAffinity-PodAffinity-Unsatisfied"><a href="#11-NodeAffinity-PodAffinity-Unsatisfied" class="headerlink" title="11. NodeAffinity&#x2F;PodAffinity Unsatisfied"></a><strong>11. NodeAffinity&#x2F;PodAffinity Unsatisfied</strong></h3><p><strong>解释</strong>：由于节点亲和性或 Pod 亲和性规则，Pod 无法被调度到任何节点上。<br><strong>可能原因</strong>：</p>
<ul>
<li>设置了严格的 NodeAffinity 或 PodAffinity，无法匹配任何可用节点。  </li>
<li>调度策略配置不当。</li>
</ul>
<hr>
<h3 id="12-OOMKilled-Out-of-Memory-Killed"><a href="#12-OOMKilled-Out-of-Memory-Killed" class="headerlink" title="12. OOMKilled (Out of Memory Killed)"></a><strong>12. OOMKilled (Out of Memory Killed)</strong></h3><p><strong>解释</strong>：由于容器超出分配的内存限制，被操作系统的 OOM（Out Of Memory）杀死。<br><strong>可能原因</strong>：</p>
<ul>
<li>容器请求的内存不足以满足其应用的需求。  </li>
<li>负载过高导致内存泄漏或突发增长。  </li>
<li>需要调整 <code>requests.memory</code> 和 <code>limits.memory</code>。</li>
</ul>
<hr>
<h3 id="13-Evicted"><a href="#13-Evicted" class="headerlink" title="13. Evicted"></a><strong>13. Evicted</strong></h3><p><strong>解释</strong>：由于节点资源不足，Pod 被驱逐（Eviction）。<br><strong>可能原因</strong>：</p>
<ul>
<li>节点内存、CPU 等资源不足。  </li>
<li>节点磁盘压力高导致驱逐。  </li>
<li>调度策略驱逐低优先级 Pod 以释放资源。</li>
</ul>
<hr>
<h3 id="14-ContainerCreating"><a href="#14-ContainerCreating" class="headerlink" title="14. ContainerCreating"></a><strong>14. ContainerCreating</strong></h3><p><strong>解释</strong>：Pod 的容器正在创建中，但尚未启动。<br><strong>可能原因</strong>：</p>
<ul>
<li>拉取镜像耗时较长。  </li>
<li>卷（Volume）未能及时挂载。  </li>
<li>网络插件问题导致容器未能启动。</li>
</ul>
<hr>
<h3 id="15-NotReady"><a href="#15-NotReady" class="headerlink" title="15. NotReady"></a><strong>15. NotReady</strong></h3><p><strong>解释</strong>：Pod 尚未准备好接受流量（Readiness Probe 失败）。<br><strong>可能原因</strong>：</p>
<ul>
<li>容器内的服务未能正常启动。  </li>
<li>Readiness Probe 配置不当或探测路径错误。  </li>
<li>依赖的外部服务未启动或不可访问。</li>
</ul>
<hr>
<h3 id="16-Waiting"><a href="#16-Waiting" class="headerlink" title="16. Waiting"></a><strong>16. Waiting</strong></h3><p><strong>解释</strong>：容器由于某些原因正在等待，并未真正运行。<br><strong>可能原因</strong>：</p>
<ul>
<li>等待 Volume 挂载或镜像拉取完成。  </li>
<li>等待依赖资源（如 ConfigMap 或 Secret）。  </li>
<li>等待调度器将其分配到节点上。</li>
</ul>
<hr>
<h2 id="总结与最佳实践"><a href="#总结与最佳实践" class="headerlink" title="总结与最佳实践"></a><strong>总结与最佳实践</strong></h2><ul>
<li><strong>监控和告警</strong>：使用监控工具（如 Prometheus 和 Grafana）实时监控 Pod 状态，及时发现问题。  </li>
<li><strong>日志分析</strong>：查看 Pod 和容器的日志来分析具体原因（<code>kubectl logs &lt;pod-name&gt;</code>）。  </li>
<li><strong>资源规划</strong>：合理设置 Pod 的资源请求和限制（requests&#x2F;limits），避免 OOM 和驱逐问题。  </li>
<li><strong>健康检查配置</strong>：配置合适的 Liveness 和 Readiness Probe，确保 Pod 正常运行和流量切换。  </li>
<li><strong>滚动升级策略</strong>：使用 Deployment 的滚动升级策略（RollingUpdate），避免大规模 Pod 重启。</li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>PromQL一些用法</title>
    <url>/2025/01/08/PromQL%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h3 id="常用-PromQL-查询示例"><a href="#常用-PromQL-查询示例" class="headerlink" title="常用 PromQL 查询示例"></a><strong>常用 PromQL 查询示例</strong></h3><p>以下是一些常见场景和 PromQL 查询用法：</p>
<h4 id="1-查询特定指标的当前值"><a href="#1-查询特定指标的当前值" class="headerlink" title="1. 查询特定指标的当前值"></a><strong>1. 查询特定指标的当前值</strong></h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_cpu_seconds_total</span><br></pre></td></tr></table></figure>

<h4 id="2-查询特定实例的-CPU-使用率"><a href="#2-查询特定实例的-CPU-使用率" class="headerlink" title="2. 查询特定实例的 CPU 使用率"></a><strong>2. 查询特定实例的 CPU 使用率</strong></h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rate(node_cpu_seconds_total&#123;mode=&quot;user&quot;, instance=&quot;server1&quot;&#125;[5m])</span><br></pre></td></tr></table></figure>

<h4 id="3-查询所有实例的-CPU-使用率"><a href="#3-查询所有实例的-CPU-使用率" class="headerlink" title="3. 查询所有实例的 CPU 使用率"></a><strong>3. 查询所有实例的 CPU 使用率</strong></h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rate(node_cpu_seconds_total&#123;mode=&quot;user&quot;&#125;[5m])</span><br></pre></td></tr></table></figure>

<h4 id="4-查询内存使用率"><a href="#4-查询内存使用率" class="headerlink" title="4. 查询内存使用率"></a><strong>4. 查询内存使用率</strong></h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes</span><br></pre></td></tr></table></figure>

<h4 id="5-查询磁盘-I-O-读取速率"><a href="#5-查询磁盘-I-O-读取速率" class="headerlink" title="5. 查询磁盘 I&#x2F;O 读取速率"></a><strong>5. 查询磁盘 I&#x2F;O 读取速率</strong></h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rate(node_disk_read_bytes_total[5m])</span><br></pre></td></tr></table></figure>

<h4 id="6-查询-HTTP-请求状态码分布"><a href="#6-查询-HTTP-请求状态码分布" class="headerlink" title="6. 查询 HTTP 请求状态码分布"></a><strong>6. 查询 HTTP 请求状态码分布</strong></h4>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum(rate(http_requests_total[5m])) by (status)</span><br></pre></td></tr></table></figure>

<h4 id="7-查询包含特定标签的指标"><a href="#7-查询包含特定标签的指标" class="headerlink" title="7. 查询包含特定标签的指标"></a><strong>7. 查询包含特定标签的指标</strong></h4><ul>
<li>匹配 <code>job</code> 标签包含 “app” 的所有指标：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;job=~&quot;.*app.*&quot;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-查询指定时间段内的指标值"><a href="#8-查询指定时间段内的指标值" class="headerlink" title="8. 查询指定时间段内的指标值"></a><strong>8. 查询指定时间段内的指标值</strong></h4><ul>
<li>查询过去 1 小时的 <code>node_cpu_seconds_total</code>：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_cpu_seconds_total[1h]</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="9-计算某一时间段的平均值"><a href="#9-计算某一时间段的平均值" class="headerlink" title="9. 计算某一时间段的平均值"></a><strong>9. 计算某一时间段的平均值</strong></h4><ul>
<li>计算过去 5 分钟内的平均 CPU 使用率：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avg(rate(node_cpu_seconds_total[5m]))</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="10-查询最大值或最小值"><a href="#10-查询最大值或最小值" class="headerlink" title="10. 查询最大值或最小值"></a><strong>10. 查询最大值或最小值</strong></h4><ul>
<li>查询所有实例的最大 CPU 使用率：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max(rate(node_cpu_seconds_total[5m])) by (instance)</span><br></pre></td></tr></table></figure></li>
<li>查询最小值：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">min(rate(node_cpu_seconds_total[5m])) by (instance)</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="PromQL-模糊查找的常用方法"><a href="#PromQL-模糊查找的常用方法" class="headerlink" title="PromQL 模糊查找的常用方法"></a><strong>PromQL 模糊查找的常用方法</strong></h3><ol>
<li><p><strong>匹配标签值（正则表达式匹配）</strong><br>使用 <code>=~</code> 运算符可以对标签值进行正则表达式匹配。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">metric_name&#123;label_name=~&quot;regex_pattern&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<ul>
<li>匹配 <code>job</code> 标签中包含 “node” 的所有时间序列：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">up&#123;job=~&quot;.*node.*&quot;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>排除特定标签值</strong><br>使用 <code>!~</code> 运算符排除符合正则表达式的标签值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">metric_name&#123;label_name!~&quot;regex_pattern&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<ul>
<li>排除 <code>job</code> 标签中包含 “node” 的时间序列：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">up&#123;job!~&quot;.*node.*&quot;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>指定多个标签值</strong><br>使用 <code>|</code> 组合多个值进行匹配。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">metric_name&#123;label_name=~&quot;value1|value2&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<ul>
<li>匹配 <code>instance</code> 标签为 “server1” 或 “server2” 的时间序列：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpu_usage&#123;instance=~&quot;server1|server2&quot;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>匹配标签存在或不存在</strong></p>
<ul>
<li>匹配时间序列中存在某个标签：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">metric_name&#123;label_name=~&quot;.+&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li>匹配时间序列中不存在某个标签：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">metric_name&#123;label_name=&quot;&quot;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="PromQL-常用操作符"><a href="#PromQL-常用操作符" class="headerlink" title="PromQL 常用操作符"></a><strong>PromQL 常用操作符</strong></h3><table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>精确匹配标签值</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>排除匹配的标签值</td>
</tr>
<tr>
<td><code>=~</code></td>
<td>使用正则表达式匹配标签值</td>
</tr>
<tr>
<td><code>!~</code></td>
<td>排除匹配正则表达式的标签值</td>
</tr>
<tr>
<td><code>+</code></td>
<td>加法运算</td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法运算</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘法运算</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除法运算</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于比较</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于比较</td>
</tr>
<tr>
<td><code>and</code></td>
<td>返回两个时间序列中都有的标签</td>
</tr>
<tr>
<td><code>or</code></td>
<td>返回两个时间序列中任意一个时间序列的值</td>
</tr>
<tr>
<td><code>unless</code></td>
<td>从左侧时间序列中排除右侧时间序列</td>
</tr>
</tbody></table>
<hr>
<h3 id="推荐工具和文档"><a href="#推荐工具和文档" class="headerlink" title="推荐工具和文档"></a><strong>推荐工具和文档</strong></h3><ul>
<li><strong>Prometheus 官方文档</strong>: <a href="https://prometheus.io/docs/prometheus/latest/querying/basics/">PromQL 查询语言</a></li>
<li><strong>PromLens</strong>: 可视化 PromQL 查询工具，帮助调试复杂查询。</li>
</ul>
]]></content>
      <categories>
        <category>promql</category>
      </categories>
  </entry>
  <entry>
    <title>ab、wrk、wrk2使用</title>
    <url>/2024/11/01/ab%E3%80%81wrk%E3%80%81wrk2%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="使用脚本"><a href="#使用脚本" class="headerlink" title="使用脚本"></a>使用脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">#安装ab、wrk或者wrk2工具</span><br><span class="line">#ab安装：</span><br><span class="line">#yum install -y httpd-utils</span><br><span class="line">#</span><br><span class="line">#wrk使用源码安装:</span><br><span class="line">#git clone git@github.com:wg/wrk.git --&gt; 解压---&gt; make --&gt; cp wrk /usr/local/bin</span><br><span class="line">#</span><br><span class="line">#wrk2使用</span><br><span class="line">#https://github.com/giltene/wrk2</span><br><span class="line">##注意安装：yum install -y openssl-devel</span><br><span class="line">#git clone git@github.com:giltene/wrk2.git --&gt; 解压---&gt; make --&gt; mv wrk wrk2 ---&gt;cp wrk2 /usr/local/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ab test config</span><br><span class="line">AB_CONCURRENT_REQUESTS=1000</span><br><span class="line">AB_TIME_OUT=180</span><br><span class="line">AB_TOTAL_REQUESTS=1000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#wrk test config</span><br><span class="line">WRK_THREADS=48</span><br><span class="line">WRK_CONCURRENT_REQUEST=48</span><br><span class="line">WRK_DURATION=180</span><br><span class="line">WRK2_REQUEST_QPS=18500</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ingress-nginx info</span><br><span class="line">NAMESPACE=&quot;ingress-nginx&quot;</span><br><span class="line">DEPLOYMENT_NAME=&quot;ingress-nginx-controller&quot;</span><br><span class="line"></span><br><span class="line">HEADER=&quot;\&quot;host:xxx.xxx.xxx.com\&quot;&quot;</span><br><span class="line">podIP=`kubectl get pods -n ingress-nginx -o yaml | grep &quot;podIP:&quot; | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">URL=&quot;http://$podIP:80/&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#检查是否安装了相关命令</span><br><span class="line">require_command=(ab kubectl)</span><br><span class="line">checkRequireCMD()</span><br><span class="line">&#123;</span><br><span class="line">    for cmd in $&#123;require_command[@]&#125;; do</span><br><span class="line">        if command -v $cmd &gt; /dev/null 2&gt;&amp;1; then</span><br><span class="line">            yellowPrint &quot;$cmd is available&quot;</span><br><span class="line">        else</span><br><span class="line">            redPrint &quot;exec failed! $cmd command is not installed, please install! &quot;</span><br><span class="line">            exit 1</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k8sInfo()</span><br><span class="line">&#123;</span><br><span class="line">	greenPrint &quot;k8s node info: &quot;</span><br><span class="line">	kubectl get nodes -o custom-columns=&quot;NODE:.metadata.name,CPU:.status.capacity.cpu,MEMORY:.status.capacity.memory,ALLOCATABLE_CPU:.status.allocatable.cpu,ALLOCATABLE_MEMORY:.status.allocatable.memory&quot;</span><br><span class="line"></span><br><span class="line">	yellowPrint &quot;ingress nginx controller pod info:&quot;</span><br><span class="line">	kubectl get pods -n $NAMESPACE -o custom-columns=&quot;NAME:.metadata.name,CPU_REQUEST:.spec.containers[*].resources.requests.cpu,MEM_REQUEST:.spec.containers[*].resources.requests.memory,CPU_LIMIT:.spec.containers[*].resources.limits.cpu,MEM_LIMIT:.spec.containers[*].resources.limits.memory&quot;</span><br><span class="line"></span><br><span class="line">	yellowPrint &quot;pod network info:&quot;</span><br><span class="line">	kubectl get pods -n $NAMESPACE -o custom-columns=&quot;POD:.metadata.name,HOST_NETWORK:.spec.hostNetwork,POD_IP:.status.podIP,HOST_IP:.status.hostIP&quot;</span><br><span class="line"></span><br><span class="line">	yellowPrint &quot;current localhost ip:&quot;</span><br><span class="line">	hostname -i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ab test</span><br><span class="line">abBenchTest()</span><br><span class="line">&#123;</span><br><span class="line">	for times in &#123;1..3&#125;; do</span><br><span class="line">		greenPrint &quot;times: $times --- ab -c $AB_CONCURRENT_REQUESTS -t $AB_TIME_OUT -n $AB_TOTAL_REQUESTS  -H $HEADER $URL&quot;</span><br><span class="line">		ab -c $AB_CONCURRENT_REQUESTS -t $AB_TIME_OUT -n $AB_TOTAL_REQUESTS  -H $HEADER $URL</span><br><span class="line">		greenPrint &quot;sleep 1s ...&quot;</span><br><span class="line">		sleep 1</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wrkTest()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	for times in &#123;1..3&#125;; do</span><br><span class="line">		greenPrint &quot;times: $times --- wrk -t $WRK_THREADS -c $WRK_CONCURRENT_REQUEST -d $WRK_DURATION --latency -H $HEADER $URL&quot;</span><br><span class="line">		wrk -t $WRK_THREADS -c $WRK_CONCURRENT_REQUEST -d $WRK_DURATION --latency -H $HEADER $URL</span><br><span class="line">	done</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wrk2Test()</span><br><span class="line">&#123;</span><br><span class="line">	for times in &#123;1..3&#125;; do</span><br><span class="line">		greenPrint &quot;times: $times --- wrk2 -t $WRK_THREADS -c $WRK_CONCURRENT_REQUEST -d $WRK_DURATION -R $WRK2_REQUEST_QPS --latency -H $HEADER $URL&quot;</span><br><span class="line">		wrk2 -t $WRK_THREADS -c $WRK_CONCURRENT_REQUEST -d $WRK_DURATION -R $WRK2_REQUEST_QPS --latency -H $HEADER $URL</span><br><span class="line">	done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义颜色代码</span><br><span class="line">RED=&#x27;\033[0;31m&#x27;</span><br><span class="line">GREEN=&#x27;\033[0;32m&#x27;</span><br><span class="line">YELLOW=&#x27;\033[0;33m&#x27;</span><br><span class="line">BLUE=&#x27;\033[0;34m&#x27;</span><br><span class="line">NC=&#x27;\033[0m&#x27; # 无颜色</span><br><span class="line"></span><br><span class="line"># 红色打印函数</span><br><span class="line">redPrint()</span><br><span class="line">&#123;</span><br><span class="line">    echo -e &quot;$&#123;RED&#125;$1$&#123;NC&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 绿色打印函数</span><br><span class="line">greenPrint()</span><br><span class="line">&#123;</span><br><span class="line">    echo -e &quot;$&#123;GREEN&#125;$1$&#123;NC&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 黄色打印函数</span><br><span class="line">yellowPrint()</span><br><span class="line">&#123;</span><br><span class="line">    echo -e &quot;$&#123;YELLOW&#125;$1$&#123;NC&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 蓝色打印函数</span><br><span class="line">bluePrint()</span><br><span class="line">&#123;</span><br><span class="line">    echo -e &quot;$&#123;BLUE&#125;$1$&#123;NC&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">selectAction()</span><br><span class="line">&#123;</span><br><span class="line">    # 提示信息</span><br><span class="line">    notice=&quot;$&#123;RED&#125;请根据以下步骤执行相关功能：$&#123;NC&#125;&quot;</span><br><span class="line">    # 主程序</span><br><span class="line">    echo -e &quot;$notice&quot;</span><br><span class="line"></span><br><span class="line">    PS3=&quot;请选择步骤编号: &quot;</span><br><span class="line"></span><br><span class="line">    options=(</span><br><span class="line">    &quot; -- 使用ab测试&quot;</span><br><span class="line">    &quot; -- 使用wrk测试&quot;</span><br><span class="line">    &quot; -- 使用wrk2测试&quot;</span><br><span class="line">    &quot; -- 退出&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">    select opt in &quot;$&#123;options[@]&#125;&quot;</span><br><span class="line">    do</span><br><span class="line">        case $REPLY in</span><br><span class="line">            1)</span><br><span class="line">				greenPrint &quot;检查必要的压测工具：&quot;</span><br><span class="line">				checkRequireCMD</span><br><span class="line">				greenPrint &quot;k8s集群信息：&quot;</span><br><span class="line">				k8sInfo</span><br><span class="line"></span><br><span class="line">				abBenchTest</span><br><span class="line">				break;;</span><br><span class="line">            2)</span><br><span class="line">				greenPrint &quot;检查必要的压测工具：&quot;</span><br><span class="line">				checkRequireCMD</span><br><span class="line">				greenPrint &quot;k8s集群信息：&quot;</span><br><span class="line">				k8sInfo</span><br><span class="line"></span><br><span class="line">				wrkTest</span><br><span class="line"></span><br><span class="line">				break;;</span><br><span class="line">			 3)</span><br><span class="line">				greenPrint &quot;检查必要的压测工具：&quot;</span><br><span class="line">				checkRequireCMD</span><br><span class="line">				greenPrint &quot;k8s集群信息：&quot;</span><br><span class="line">				k8sInfo</span><br><span class="line"></span><br><span class="line">				wrk2Test</span><br><span class="line"></span><br><span class="line">				break;;</span><br><span class="line"></span><br><span class="line">			4)</span><br><span class="line">			    echo &quot;退出&quot;</span><br><span class="line">			    break;;</span><br><span class="line">			*)</span><br><span class="line">			    echo &quot;无效的选择，请输入 1 到 4 之间的数字。&quot;</span><br><span class="line">			    break;;</span><br><span class="line">        esac</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">selectAction</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>controller暴露metrics到prometheus接收数据的过程</title>
    <url>/2024/12/19/controller%E6%9A%B4%E9%9C%B2metrics%E5%88%B0prometheus%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><h3 id="①-controller暴露指标地址"><a href="#①-controller暴露指标地址" class="headerlink" title="① controller暴露指标地址"></a>① controller暴露指标地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主机ip：10.16.217.100</span><br><span class="line">curl http://10.16.217.100:8080/metrics | grep layer</span><br><span class="line">或者</span><br><span class="line">curl http://localhost:8080/metrics | grep layer</span><br></pre></td></tr></table></figure>
<h3 id="②-prometheus-yaml"><a href="#②-prometheus-yaml" class="headerlink" title="② prometheus.yaml"></a>② prometheus.yaml</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 15s </span><br><span class="line">  external_labels:</span><br><span class="line">    monitor: &#x27;codelab-monitor&#x27;</span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    scrape_interval: 5s</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [&#x27;10.16.217.100:8080&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="③-docker-compose-启动prometheus容器与grafana"><a href="#③-docker-compose-启动prometheus容器与grafana" class="headerlink" title="③ docker-compose 启动prometheus容器与grafana"></a>③ docker-compose 启动prometheus容器与grafana</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3.8&#x27;</span><br><span class="line">services:</span><br><span class="line">  prometheus:</span><br><span class="line">    image: prom/prometheus</span><br><span class="line">    container_name: prometheus</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9090:9090&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - ./prometheus.yml:/etc/prometheus/prometheus.yml</span><br><span class="line"></span><br><span class="line">  grafana:</span><br><span class="line">    image: grafana/grafana</span><br><span class="line">    container_name: grafana</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;3000:3000&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动：docker-compose -f .&#x2F;docker-compose.yaml up -d</li>
<li>重启：docker-compose -f .&#x2F;docker-compose.yaml restart</li>
<li>查看：docker-compose -f .&#x2F;docker-compose.yaml ps</li>
<li>停止：docker-compose -f .&#x2F;docker-compose.yaml down</li>
</ul>
<hr>
<h2 id="验证数据采集"><a href="#验证数据采集" class="headerlink" title="验证数据采集"></a>验证数据采集</h2><h3 id="1-验证-Prometheus-是否抓取到目标的指标"><a href="#1-验证-Prometheus-是否抓取到目标的指标" class="headerlink" title="1. 验证 Prometheus 是否抓取到目标的指标"></a><strong>1. 验证 Prometheus 是否抓取到目标的指标</strong></h3><ol>
<li><p><strong>检查 Prometheus 的 Targets 页面</strong></p>
<ul>
<li>在浏览器中访问 <code>http://localhost:9090/targets</code>。</li>
<li>找到名为 <code>prometheus</code> 的抓取任务。</li>
<li>检查 <code>State</code> 是否为 <code>UP</code>：<ul>
<li>如果是 <code>UP</code>，说明 Prometheus 成功抓取了目标地址的指标。</li>
<li>如果是 <code>DOWN</code>，说明 Prometheus 无法访问目标地址（可能是网络或配置问题）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>查看 Prometheus 是否抓取到目标的指标</strong></p>
<ul>
<li>在 Prometheus 的 Query 页面（<code>http://localhost:9090/graph</code>）运行以下查询：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">up&#123;job=&quot;prometheus&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li>返回值为 <code>1</code> 表示 Prometheus 能正常访问目标。</li>
<li>如果返回值为 <code>0</code>，需要检查目标地址是否正确，或者 Prometheus 是否能够访问 <code>10.16.217.100:8080</code>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-验证目标是否暴露了-layer-数据"><a href="#2-验证目标是否暴露了-layer-数据" class="headerlink" title="2. 验证目标是否暴露了 layer 数据"></a><strong>2. 验证目标是否暴露了 <code>layer</code> 数据</strong></h3><ol>
<li><p><strong>直接访问目标的 <code>/metrics</code></strong></p>
<ul>
<li>在容器外部运行：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://10.16.217.100:8080/metrics | grep layer</span><br></pre></td></tr></table></figure></li>
<li>确保目标地址上有 <code>layer</code> 相关的数据。</li>
<li>如果这里没有 <code>layer</code> 数据，说明目标程序没有暴露相关指标，问题在目标程序。</li>
</ul>
</li>
<li><p><strong>验证 Prometheus 抓取的原始数据</strong></p>
<ul>
<li>在 Prometheus 的 Query 页面运行以下查询：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;job=&quot;prometheus&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li>这会列出 Prometheus 从目标抓取的所有指标。</li>
<li>检查是否有与 <code>layer</code> 相关的指标。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-检查-Docker-容器的网络配置"><a href="#3-检查-Docker-容器的网络配置" class="headerlink" title="3. 检查 Docker 容器的网络配置"></a><strong>3. 检查 Docker 容器的网络配置</strong></h3><ol>
<li><p><strong>验证容器是否能访问目标地址</strong></p>
<ul>
<li>进入 Prometheus 容器：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;container_id&gt; sh</span><br></pre></td></tr></table></figure></li>
<li>在容器内部运行：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://10.16.217.100:8080/metrics | grep layer</span><br></pre></td></tr></table></figure></li>
<li>如果没有返回数据，可能是 Docker 容器的网络配置问题：<ul>
<li>确保 Docker 容器和主机在同一网络中。</li>
<li>如果目标是本地服务，尝试使用 <code>host.docker.internal</code> 替代 IP 地址。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>使用 <code>host</code> 网络模式</strong></p>
<ul>
<li>如果目标服务运行在主机上，可以使用 Docker 的 <code>host</code> 网络模式：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --network host -v /root/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus</span><br></pre></td></tr></table></figure></li>
<li>这会让容器直接使用主机网络，避免网络隔离问题。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-检查-Prometheus-配置文件是否正确"><a href="#4-检查-Prometheus-配置文件是否正确" class="headerlink" title="4. 检查 Prometheus 配置文件是否正确"></a><strong>4. 检查 Prometheus 配置文件是否正确</strong></h3><ol>
<li><p><strong>验证配置文件语法</strong></p>
<ul>
<li>使用 <code>promtool</code> 检查配置文件：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#wget https://github.com/prometheus/prometheus/releases/download/v3.0.1/prometheus-3.0.1.linux-amd64.tar.gz</span></span><br><span class="line"><span class="comment">#tar zxvf prometheus-3.0.1.linux-amd64.tar.gz -C /usr/local</span></span><br><span class="line"></span><br><span class="line">promtool check config /root/prometheus/prometheus.yml</span><br></pre></td></tr></table></figure></li>
<li>确保配置文件没有语法错误。</li>
</ul>
</li>
<li><p><strong>验证 <code>scrape_configs</code> 的目标地址</strong></p>
<ul>
<li>确保 <code>10.16.217.100:8080</code> 是正确的目标地址。</li>
<li>如果目标服务运行在本地主机，尝试使用 <code>localhost:8080</code> 替代 IP 地址。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-检查-Prometheus-抓取日志"><a href="#5-检查-Prometheus-抓取日志" class="headerlink" title="5. 检查 Prometheus 抓取日志"></a><strong>5. 检查 Prometheus 抓取日志</strong></h3><p>Prometheus 会记录抓取目标时的日志信息，可以通过以下方式查看：</p>
<ol>
<li><p><strong>访问 Prometheus 的日志页面</strong></p>
<ul>
<li>在 Prometheus Web 界面中访问 <code>http://localhost:9090/status</code>。</li>
<li>检查是否有与抓取目标相关的错误日志。</li>
</ul>
</li>
<li><p><strong>查看容器日志</strong></p>
<ul>
<li>运行以下命令查看 Prometheus 容器的日志：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs &lt;container_id&gt;</span><br></pre></td></tr></table></figure></li>
<li>检查是否有关于 <code>10.16.217.100:8080</code> 的抓取错误。</li>
</ul>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>create pod and state</title>
    <url>/2024/12/26/create-pod-and-state/</url>
    <content><![CDATA[<h2 id="pod状态"><a href="#pod状态" class="headerlink" title="pod状态"></a>pod状态</h2><ul>
<li>CrashLoopBackOff : 容器退出，kubelet正在将它重启</li>
<li>InvalidImageName : 无法解析镜像名称</li>
<li>ImageInspectError : 无法校验镜像</li>
<li>ErrImageNeverPull : 策略禁止拉取镜像</li>
<li>ImagePullBackOff : 正在重试拉取</li>
<li>RegistryUnavailable : 连接不到镜像中心</li>
<li>ErrImagePull : 通用的拉取镜像出错</li>
<li>CreateContainerConfigError : 不能创建kubelet使用的容器配置</li>
<li>CreateContainerError : 创建容器失败</li>
<li>m.internalLifecycle.PreStartContainer : 执行hook报错</li>
<li>RunContainerError : 启动容器失败</li>
<li>PostStartHookError : 执行hook报错</li>
<li>ContainersNotInitialized : 容器没有初始化完毕</li>
<li>ContainersNotRead : 容器没有准备完毕</li>
<li>ContainerCreating : 容器创建中</li>
<li>PodInitializing : pod : 初始化中</li>
<li>DockerDaemonNotReady : docker还没有完全启动</li>
<li>NetworkPluginNotReady : 网络插件还没有完全启动</li>
<li>Evicted : Pod被驱逐</li>
</ul>
<h2 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h2><p><img src="https://raw.githubusercontent.com/shispring/picgo/master/pod-create.png" alt="create pod"></p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>docker ctr crictl nerdctl命令使用</title>
    <url>/2025/01/10/docker-ctr-crictl%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="命令对比"><a href="#命令对比" class="headerlink" title="命令对比"></a>命令对比</h2><table>
<thead>
<tr>
<th>命令</th>
<th>docker</th>
<th>ctr（containerd）</th>
<th>crictl（kubernetes）</th>
</tr>
</thead>
<tbody><tr>
<td>查看运行的容器</td>
<td>docker ps</td>
<td>ctr task ls &#x2F; ctr container ls</td>
<td>crictl ps</td>
</tr>
<tr>
<td>查看镜像</td>
<td>docker images</td>
<td>ctr image ls &#x2F; ctr i ls</td>
<td>crictl images</td>
</tr>
<tr>
<td>查看容器日志</td>
<td>docker logs</td>
<td>无</td>
<td>crictl logs</td>
</tr>
<tr>
<td>查看容器信息</td>
<td>docker inspect</td>
<td>ctr container info</td>
<td>crictl inspect</td>
</tr>
<tr>
<td>查看容器资源</td>
<td>docker stats</td>
<td>无</td>
<td>crictl stats</td>
</tr>
<tr>
<td>启动&#x2F;关闭已有的容器</td>
<td>docker start&#x2F;stop</td>
<td>ctr task start&#x2F;kill</td>
<td>crictl start&#x2F;stop</td>
</tr>
<tr>
<td>运行一个新的容器</td>
<td>docker run</td>
<td>ctr run</td>
<td>无（最小单元为 Pod）</td>
</tr>
<tr>
<td>修改镜像标签</td>
<td>docker tag</td>
<td>ctr image tag</td>
<td>无</td>
</tr>
<tr>
<td>创建一个新的容器</td>
<td>docker create</td>
<td>ctr container create</td>
<td>crictl create</td>
</tr>
<tr>
<td>导入镜像</td>
<td>docker load</td>
<td>ctr image import</td>
<td>无</td>
</tr>
<tr>
<td>导出镜像</td>
<td>docker save</td>
<td>ctr image export</td>
<td>无</td>
</tr>
<tr>
<td>删除容器</td>
<td>docker rm</td>
<td>ctr container rm</td>
<td>crictl rm</td>
</tr>
<tr>
<td>删除镜像</td>
<td>docker rmi</td>
<td>ctr image rm</td>
<td>crictl rmi</td>
</tr>
<tr>
<td>拉取镜像</td>
<td>docker pull</td>
<td>ctr image pull</td>
<td>crictl pull</td>
</tr>
<tr>
<td>推送镜像</td>
<td>docker push</td>
<td>ctr image push</td>
<td>无</td>
</tr>
<tr>
<td>在容器内部执行命令</td>
<td>docker exec</td>
<td>无</td>
<td>crictl exec</td>
</tr>
</tbody></table>
<hr>
<h2 id="docker清理资源"><a href="#docker清理资源" class="headerlink" title="docker清理资源"></a>docker清理资源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看停止的容器</span><br><span class="line">docker ps --filter status=exited --filter status=dead -q</span><br><span class="line">docker ps --filter status=exited --filter status=dead -s</span><br><span class="line">#停止所有容器</span><br><span class="line">#docker stop $(docker ps -q)</span><br><span class="line"></span><br><span class="line">#清理停止的容器</span><br><span class="line">docker container prune -f</span><br><span class="line"></span><br><span class="line">#列出所有悬空镜像</span><br><span class="line">docker images -f &quot;dangling=true&quot;</span><br><span class="line">#清理未使用的镜像（悬空或无标签）</span><br><span class="line">docker image prune -a -f</span><br><span class="line"></span><br><span class="line">#清除默认构建缓存</span><br><span class="line">docker buildx prune -f</span><br><span class="line"></span><br><span class="line">#清理未使用的卷</span><br><span class="line">docker volume prune -f</span><br><span class="line"></span><br><span class="line">#清理未使用的网络</span><br><span class="line">docker network prune -f</span><br><span class="line"></span><br><span class="line">#查看容器、镜像、卷等资源的占用情况</span><br><span class="line">docker system df</span><br><span class="line"></span><br><span class="line">#综合清理所有未使用的数据，所有废弃镜像与Build Cache</span><br><span class="line">docker system prune -a -f --volumes</span><br><span class="line"></span><br><span class="line">#查看磁盘使用情况</span><br><span class="line">df -lh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="ctr"><a href="#ctr" class="headerlink" title="ctr"></a>ctr</h2><blockquote>
<p>ctr 是一个不受支持的，用于与 containerd 守护进程交互的调试和管理客户端 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 查看containerd命名空间：ctr namespace ls</span><br><span class="line">- 查看containerd的镜像：ctr images ls（可指定命名空间，如ctr -n k8s.io images ls）</span><br><span class="line">- 拉取containerd的镜像：ctr -n k8s.io images pull &lt;image&gt;</span><br><span class="line">- 删除containerd的镜像：ctr -n k8s.io images rm &lt;image&gt;</span><br><span class="line">- 导出containerd的镜像：ctr -n k8s.io images export &lt;image&gt;</span><br><span class="line">- 导入containerd的镜像：ctr -n k8s.io image import &lt;image&gt;</span><br><span class="line">- 标记containerd的镜像（起别名）：ctr -n k8s.io images tag &lt;image&gt; &lt;alias&gt;</span><br><span class="line">- 运行containerd的容器：ctr -n k8s.io run &lt;container&gt;</span><br><span class="line">- 查看运行容器的task：ctr -n k8s.io task ls</span><br><span class="line">- 启动指定容器的task：ctr -n k8s.io task start &lt;container&gt;</span><br><span class="line">- 进入指定容器的task：ctr -n k8s.io task exec --exec-id &lt;id&gt; -t &lt;container&gt; /bin/bash</span><br><span class="line">- 删除指定容器的task：ctr -n k8s.io task rm -f &lt;container&gt;</span><br><span class="line">- 停止指定容器的task：ctr -n k8s.io task kill --signal &lt;signal&gt; &lt;container&gt;</span><br><span class="line">- 查看容器：ctr -n k8s.io c list</span><br><span class="line">- 删除容器：ctr -n k8s.io c rm &lt;container&gt;</span><br></pre></td></tr></table></figure>

<h2 id="crictl"><a href="#crictl" class="headerlink" title="crictl"></a>crictl</h2><blockquote>
<p>crictl 是一个符合 CRI 接口规范的命令行工具，通常用于检查和管理 kubelet 节点上的容器运行时和镜像</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 取消DEBUG信息：crictl --debug=false xxx</span><br><span class="line">- 查看镜像：crictl images</span><br><span class="line">- 拉取镜像：crictl pull &lt;image-name&gt;:&lt;tag&gt;</span><br><span class="line">- 删除镜像：crictl rmi &lt;image-id&gt;</span><br><span class="line">- 列出当前运行的容器：crictl ps</span><br><span class="line">- 列出所有容器（包括已停止的）：crictl ps -a</span><br><span class="line">- 查看指定容器的详细信息：crictl inspect &lt;container-id&gt;</span><br><span class="line">- 停止指定ID的容器：crictl stop &lt;container-id&gt;</span><br><span class="line">- 删除指定ID的容器：crictl rm &lt;container-id&gt;</span><br><span class="line">- 列出当前运行的Pod：crictl pods</span><br><span class="line">- 查看指定Pod的详细信息：crictl inspectp &lt;pod-id&gt;</span><br><span class="line">- 停止指定ID的Pod：crictl stopp &lt;pod-id&gt;</span><br><span class="line">- 删除指定ID的Pod：crictl rmp &lt;pod-id&gt;</span><br><span class="line">- 获取指定容器的日志输出：crictl logs &lt;container-id&gt;</span><br><span class="line">- 列出指定容器的资源使用统计信息：crictl stats &lt;container-id&gt;</span><br><span class="line">- 列出指定Pod的资源使用统计信息：crictl statsp &lt;pod-id&gt;</span><br><span class="line">- 显示crictl和容器运行时的版本信息：crictl version</span><br><span class="line">- 在运行的容器中执行指定的命令：crictl exec -it &lt;container-id&gt; -- &lt;command&gt;</span><br></pre></td></tr></table></figure>

<h2 id="nerdctl"><a href="#nerdctl" class="headerlink" title="nerdctl"></a>nerdctl</h2><blockquote>
<p><a href="https://github.com/containerd/nerdctl/releases">https://github.com/containerd/nerdctl/releases</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- nerdctl run：在新容器中运行命令</span><br><span class="line">- nerdctl exec：在正在运行的容器中运行命令</span><br><span class="line">- nerdctl create : 创建一个新容器</span><br><span class="line">- nerdctl logs : 获取容器日志</span><br><span class="line">- nerdctl start：启动一个或多个正在运行的容器。</span><br><span class="line">- nerdctl stop：停止一个或多个正在运行的容器。</span><br><span class="line">- nerdctl restart：重启一个或多个正在运行的容器。</span><br><span class="line">- nerdctl rm/rmi：删除一个或多个容器/图像。</span><br><span class="line">- nerdctl container prune：删除所有停止的容器。</span><br><span class="line">- nerdctl build：从 Dockerfile 构建图像。</span><br><span class="line">- nerdctl pull/push：从注册表中拉取/推送图像。</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="快速部署docker服务"><a href="#快速部署docker服务" class="headerlink" title="快速部署docker服务"></a>快速部署docker服务</h2><ul>
<li>执行方式：DATA_ROOT&#x3D;&#x2F;mnt&#x2F;docker DOCKER_VERSION&#x3D;25.0.5 .&#x2F;install-docker.sh<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">set -euo pipefail</span><br><span class="line"></span><br><span class="line"># ==============================</span><br><span class="line"># Configurable options</span><br><span class="line"># ==============================</span><br><span class="line">DOCKER_VERSION=&quot;$&#123;DOCKER_VERSION:-25.0.4&#125;&quot;</span><br><span class="line">DOCKER_CLI_VERSION=&quot;$&#123;DOCKER_CLI_VERSION:-25.0.4&#125;&quot;</span><br><span class="line">CONTAINERD_VERSION=&quot;$&#123;CONTAINERD_VERSION:-1.6.32&#125;&quot;</span><br><span class="line">COMPOSE_VERSION=&quot;$&#123;COMPOSE_VERSION:-2.27.0&#125;&quot;</span><br><span class="line">DATA_ROOT=&quot;$&#123;DATA_ROOT:-/data/docker&#125;&quot;</span><br><span class="line">MTU=&quot;$&#123;MTU:-1450&#125;&quot;</span><br><span class="line"></span><br><span class="line">DOCKER_BASE_URL=&quot;https://mirrors.aliyun.com/docker-ce/linux/centos/8/x86_64/stable/Packages&quot;</span><br><span class="line"></span><br><span class="line"># ==============================</span><br><span class="line"># Helper functions</span><br><span class="line"># ==============================</span><br><span class="line">log() &#123;</span><br><span class="line">    echo -e &quot;\033[1;32m[INFO]\033[0m $*&quot;</span><br><span class="line">&#125;</span><br><span class="line">warn() &#123;</span><br><span class="line">    echo -e &quot;\033[1;33m[WARN]\033[0m $*&quot;</span><br><span class="line">&#125;</span><br><span class="line">err() &#123;</span><br><span class="line">    echo -e &quot;\033[1;31m[ERROR]\033[0m $*&quot; &gt;&amp;2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># ==============================</span><br><span class="line"># Install Docker</span><br><span class="line"># ==============================</span><br><span class="line">log &quot;Installing Docker CE version $&#123;DOCKER_VERSION&#125;...&quot;</span><br><span class="line"></span><br><span class="line">dnf install -y \</span><br><span class="line">  $&#123;DOCKER_BASE_URL&#125;/docker-ce-$&#123;DOCKER_VERSION&#125;-1.el8.x86_64.rpm \</span><br><span class="line">  $&#123;DOCKER_BASE_URL&#125;/docker-ce-cli-$&#123;DOCKER_CLI_VERSION&#125;-1.el8.x86_64.rpm \</span><br><span class="line">  $&#123;DOCKER_BASE_URL&#125;/containerd.io-$&#123;CONTAINERD_VERSION&#125;-3.1.el8.x86_64.rpm \</span><br><span class="line">  $&#123;DOCKER_BASE_URL&#125;/docker-compose-plugin-$&#123;COMPOSE_VERSION&#125;-1.el8.x86_64.rpm \</span><br><span class="line">  || &#123; err &quot;Docker installation failed&quot;; exit 1; &#125;</span><br><span class="line"></span><br><span class="line">log &quot;Docker installed successfully.&quot;</span><br><span class="line"></span><br><span class="line"># ==============================</span><br><span class="line"># Configure Docker</span><br><span class="line"># ==============================</span><br><span class="line">log &quot;Configuring Docker daemon...&quot;</span><br><span class="line"></span><br><span class="line">mkdir -p &quot;$&#123;DATA_ROOT&#125;&quot;</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">   &quot;registry-mirrors&quot;: [</span><br><span class="line">     &quot;https://docker.m.daocloud.io&quot;,</span><br><span class="line">     &quot;https://fw92oidw.mirror.aliyuncs.com&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;log-opts&quot;: &#123;</span><br><span class="line">        &quot;max-file&quot;: &quot;3&quot;,</span><br><span class="line">        &quot;max-size&quot;: &quot;500m&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;data-root&quot;: &quot;$&#123;DATA_ROOT&#125;&quot;,</span><br><span class="line">    &quot;mtu&quot;: $&#123;MTU&#125;,</span><br><span class="line">    &quot;iptables&quot;: true,</span><br><span class="line">    &quot;live-restore&quot;: true,</span><br><span class="line">    &quot;init&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">log &quot;Docker configuration written to /etc/docker/daemon.json&quot;</span><br><span class="line"></span><br><span class="line"># ==============================</span><br><span class="line"># Enable and restart Docker</span><br><span class="line"># ==============================</span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line">log &quot;Docker service enabled and restarted successfully.&quot;</span><br><span class="line">log &quot;Data root set to $&#123;DATA_ROOT&#125;, MTU set to $&#123;MTU&#125;.&quot;</span><br><span class="line"></span><br><span class="line">log &quot;Docker Registry Mirrors&quot;</span><br><span class="line">docker info | grep -A3 &quot;Registry Mirrors&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="查看容器与进程映射"><a href="#查看容器与进程映射" class="headerlink" title="查看容器与进程映射"></a>查看容器与进程映射</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#docker运行时</span><br><span class="line">docker ps -q | while read cid; do</span><br><span class="line">    pid=$(docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; $cid)</span><br><span class="line">    echo &quot;$cid -&gt; $pid&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#containerd运行时</span><br><span class="line">crictl --debug=false ps -q | while read cid; do</span><br><span class="line">    pid=$(crictl --debug=false inspect $cid | jq -r &#x27;.info.pid&#x27;)</span><br><span class="line">    echo &quot;$cid -&gt; $pid&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<ul>
<li>k8s节点打印多项信息<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#docker运行时</span><br><span class="line">#!/usr/bin/env bash</span><br><span class="line">set -euo pipefail</span><br><span class="line"></span><br><span class="line"># 打印表头</span><br><span class="line">printf &quot;%-20s %-10s %-40s %-30s %-20s %-20s\n&quot; \</span><br><span class="line">  &quot;CONTAINER_ID&quot; &quot;PID&quot; &quot;POD_UID&quot; &quot;POD_NAME&quot; &quot;NAMESPACE&quot; &quot;CONTAINER_NAME&quot;</span><br><span class="line"></span><br><span class="line">docker ps -q | while read -r cid; do</span><br><span class="line">    inspect_json=$(docker inspect &quot;$cid&quot;)</span><br><span class="line"></span><br><span class="line">    pid=$(echo &quot;$inspect_json&quot; | jq -r &#x27;.[0].State.Pid&#x27;)</span><br><span class="line">    pod_uid=$(echo &quot;$inspect_json&quot; | jq -r &#x27;.[0].Config.Labels.&quot;io.kubernetes.pod.uid&quot;&#x27;)</span><br><span class="line">    pod_name=$(echo &quot;$inspect_json&quot; | jq -r &#x27;.[0].Config.Labels.&quot;io.kubernetes.pod.name&quot;&#x27;)</span><br><span class="line">    namespace=$(echo &quot;$inspect_json&quot; | jq -r &#x27;.[0].Config.Labels.&quot;io.kubernetes.pod.namespace&quot;&#x27;)</span><br><span class="line">    container_name=$(echo &quot;$inspect_json&quot; | jq -r &#x27;.[0].Config.Labels.&quot;io.kubernetes.container.name&quot;&#x27;)</span><br><span class="line"></span><br><span class="line">    printf &quot;%-20s %-10s %-40s %-30s %-20s %-20s\n&quot; \</span><br><span class="line">      &quot;$cid&quot; &quot;$pid&quot; &quot;$pod_uid&quot; &quot;$pod_name&quot; &quot;$namespace&quot; &quot;$container_name&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#containerd运行时</span><br><span class="line">#!/usr/bin/env bash</span><br><span class="line">set -euo pipefail</span><br><span class="line"></span><br><span class="line"># 打印表头</span><br><span class="line">printf &quot;%-20s %-10s %-40s %-30s\n&quot; &quot;CONTAINER_ID&quot; &quot;PID&quot; &quot;POD_UID&quot; &quot;POD_NAME&quot;</span><br><span class="line"></span><br><span class="line">crictl --debug=false ps -q | while read -r cid; do</span><br><span class="line">    inspect_json=$(crictl --debug=false inspect &quot;$cid&quot;)</span><br><span class="line">    pid=$(echo &quot;$inspect_json&quot; | jq -r &#x27;.info.pid&#x27;)</span><br><span class="line">    pod_uid=$(echo &quot;$inspect_json&quot; | jq -r &#x27;.status.labels.&quot;io.kubernetes.pod.uid&quot;&#x27;)</span><br><span class="line">    pod_name=$(echo &quot;$inspect_json&quot; | jq -r &#x27;.status.labels.&quot;io.kubernetes.pod.name&quot;&#x27;)</span><br><span class="line"></span><br><span class="line">    printf &quot;%-20s %-10s %-40s %-30s\n&quot; &quot;$cid&quot; &quot;$pid&quot; &quot;$pod_uid&quot; &quot;$pod_name&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>expect跳转tips</title>
    <url>/2024/12/16/expect%E8%B7%B3%E8%BD%ACtips/</url>
    <content><![CDATA[<h2 id="一、单次跳转"><a href="#一、单次跳转" class="headerlink" title="一、单次跳转"></a>一、单次跳转</h2><ul>
<li>① shell脚本拼凑登录信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/opt/homebrew/bin/bash</span><br><span class="line">###---------------###</span><br><span class="line">#mac安装新版本bash: 支持declare -A xxx</span><br><span class="line">#brew install bash</span><br><span class="line">#</span><br><span class="line">###---------------###</span><br><span class="line"></span><br><span class="line"># 全局变量</span><br><span class="line">PORT=&quot;22&quot;</span><br><span class="line">USER=&quot;xxx&quot;</span><br><span class="line">PASSWORD=&quot;xxx&quot;</span><br><span class="line"></span><br><span class="line"># ANSI 转义码定义颜色</span><br><span class="line">RESET=&quot;\033[0m&quot;</span><br><span class="line">RED=&quot;\033[31m&quot;</span><br><span class="line">GREEN=&quot;\033[32m&quot;</span><br><span class="line">YELLOW=&quot;\033[33m&quot;</span><br><span class="line"></span><br><span class="line"># 函数：打印日志（支持颜色）</span><br><span class="line">log_message() &#123;</span><br><span class="line">    local level=$1</span><br><span class="line">    local message=$2</span><br><span class="line">    local color</span><br><span class="line"></span><br><span class="line">    case $level in</span><br><span class="line">        INFO)</span><br><span class="line">            color=$GREEN</span><br><span class="line">            ;;</span><br><span class="line">        WARN)</span><br><span class="line">            color=$YELLOW</span><br><span class="line">            ;;</span><br><span class="line">        ERROR)</span><br><span class="line">            color=$RED</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            color=$RESET</span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line"></span><br><span class="line">    echo -e &quot;$(date &#x27;+%Y-%m-%dT%H:%M:%S&#x27;) [$&#123;color&#125;$&#123;level&#125;$&#123;RESET&#125;] $message&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 函数：定义 IP 映射</span><br><span class="line">declare -A IP_MAP</span><br><span class="line">IP_MAP[&quot;dev_194&quot;]=&quot;10.xxx.xxx.194&quot;</span><br><span class="line">IP_MAP[&quot;jump_113&quot;]=&quot;10.xxx.xxx.113&quot;</span><br><span class="line"></span><br><span class="line"># 函数：获取 IP 地址</span><br><span class="line">get_ip() &#123;</span><br><span class="line">    local key=&quot;$&#123;1&#125;_$&#123;2&#125;&quot;</span><br><span class="line">    echo &quot;$&#123;IP_MAP[$key]&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 参数检查</span><br><span class="line">if [[ $# -lt 2 ]]; then</span><br><span class="line">    log_message &quot;ERROR&quot; &quot;Usage: $0 &lt;environment&gt; &lt;option&gt;&quot;</span><br><span class="line">    log_message &quot;INFO&quot; &quot;Examples: $0 dev 194&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 获取参数</span><br><span class="line">ENVIRONMENT=$1</span><br><span class="line">OPTION=$2</span><br><span class="line"></span><br><span class="line"># 获取目标 IP</span><br><span class="line">IP=$(get_ip &quot;$ENVIRONMENT&quot; &quot;$OPTION&quot;)</span><br><span class="line">echo $IP</span><br><span class="line">if [[ -z $IP ]]; then</span><br><span class="line">    log_message &quot;ERROR&quot; &quot;Invalid environment or option: $ENVIRONMENT $OPTION&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 调用 Expect 脚本</span><br><span class="line">log_message &quot;INFO&quot; &quot;Connecting to $IP with user $USER on port $PORT&quot;</span><br><span class="line"></span><br><span class="line">expect /Users/xxx/shell/expectLogin.exp &quot;$IP&quot; &quot;$PORT&quot; &quot;$USER&quot; &quot;$PASSWORD&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>② 配合的expectLogin.exp脚本</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/expect -f</span><br><span class="line"></span><br><span class="line"># 获取参数</span><br><span class="line">set ip [lindex $argv 0]</span><br><span class="line">set port [lindex $argv 1]</span><br><span class="line">set user [lindex $argv 2]</span><br><span class="line">set password [lindex $argv 3]</span><br><span class="line"></span><br><span class="line"># 设置超时时间</span><br><span class="line">set timeout 0.5</span><br><span class="line"></span><br><span class="line"># 打印日志</span><br><span class="line">puts &quot;[clock format [clock seconds] -format %Y-%m-%dT%H:%M:%S] Connecting to $ip&quot;</span><br><span class="line"></span><br><span class="line"># 执行 SSH 登录（ssh config 可自动处理免密情况）</span><br><span class="line">spawn ssh -p $port $user@$ip</span><br><span class="line"></span><br><span class="line"># 通过循环处理可能的交互情况</span><br><span class="line">while &#123;1&#125; &#123;</span><br><span class="line">    expect &#123;</span><br><span class="line">        -re &quot;Are you sure you want to continue connecting.*\\(yes/no\\)\\?&quot; &#123;</span><br><span class="line">            send &quot;yes\r&quot;</span><br><span class="line">            exp_continue</span><br><span class="line">        &#125;</span><br><span class="line">        -re &quot;(?i)password:&quot; &#123;</span><br><span class="line">            # 如果传入的密码为空，说明可能是免密登录，不发送密码</span><br><span class="line">            if &#123;$password ne &quot;&quot;&#125; &#123;</span><br><span class="line">                send &quot;$password\r&quot;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                # 若密码为空则直接进入交互模式</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            exp_continue</span><br><span class="line">        &#125;</span><br><span class="line">        -re &#123;([\$#] $)&#125; &#123;</span><br><span class="line">            # 匹配到标准 shell 提示符（支持$或#结尾），登录成功</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        timeout &#123;</span><br><span class="line">            # 如果等待超时，也尝试结束循环进入交互模式</span><br><span class="line">            # puts &quot;等待响应超时，尝试进入交互模式，请注意确认登录状态。&quot;</span><br><span class="line">            # send &quot;\r&quot;</span><br><span class="line">	    break</span><br><span class="line">        &#125;</span><br><span class="line">        eof &#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 进入交互模式</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="两次跳转登录"><a href="#两次跳转登录" class="headerlink" title="两次跳转登录"></a>两次跳转登录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/expect</span><br><span class="line">#############################################</span><br><span class="line">#</span><br><span class="line">#脚本目的：从本地mac ---经跳板机---&gt; 跳到IDC主机</span><br><span class="line">#使用方法：</span><br><span class="line">#1、chmod +x jump.exp</span><br><span class="line">#2、可在.bash_profile 定义脚本别名 alias jump=&#x27;xxxx/jump.exp&#x27;</span><br><span class="line">#3、登录机器 jump &#123;hostname&#125;</span><br><span class="line">#############################################</span><br><span class="line"></span><br><span class="line">set port 22</span><br><span class="line">set user xxx</span><br><span class="line">set password xxx</span><br><span class="line">set jumper xxx</span><br><span class="line"></span><br><span class="line"># 定义登录主机名</span><br><span class="line">set hostname [lindex $argv 0]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if &#123; $argc &lt; 1 &#125; &#123;</span><br><span class="line">    puts &quot;please input: jump &#123;hostname&#125; &quot;</span><br><span class="line">    exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if &#123; $argc == 1 &#125; &#123;</span><br><span class="line"></span><br><span class="line">    # 关闭mac层连接的标准输出</span><br><span class="line">    log_user 0</span><br><span class="line"></span><br><span class="line">    #特殊处理主机,该主机配置了无密码登录，可以不再设置密码登录</span><br><span class="line">    if &#123;$hostname == $jumper&#125; &#123;</span><br><span class="line"></span><br><span class="line">        spawn ssh -p $port $user@$hostname</span><br><span class="line">        expect &#123;</span><br><span class="line">            &quot;*yes/no&quot; &#123; </span><br><span class="line">                send &quot;yes\r&quot;; exp_continue </span><br><span class="line">            &#125;</span><br><span class="line">            &quot;*password:*&quot; &#123; </span><br><span class="line">                send &quot;$password\r;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            &quot;$&quot; &#123;</span><br><span class="line">                send &quot;\r;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        # spawn 是 expect 环境的内部命令，它主要的功能是给 ssh 运行进程加个壳，用来传递交互指令。</span><br><span class="line">        spawn ssh -p $port $user@$jumper</span><br><span class="line"></span><br><span class="line">        # expect 也是 expect 环境的一个内部命令，用来判断上一个指令输入之后的得到输出结果是否包含 &quot;&quot; 双引号里的字符串，-re 表示通过正则来匹配。</span><br><span class="line">        # 如果是第一次登录，会出现 &quot;yes/no&quot; 的字符串，就发送（send）指令 &quot;yes\r&quot;，然后继续（exp_continue）。</span><br><span class="line">        expect &#123;</span><br><span class="line">            &quot;*yes/no&quot; &#123;    send &quot;yes\r&quot;; exp_continue &#125;</span><br><span class="line">            &quot;*password:*&quot; &#123;   send &quot;$password\r;&quot;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        # 关闭mac层连接的标准输出</span><br><span class="line">        log_user 0</span><br><span class="line"></span><br><span class="line">        expect &quot;@&quot; &#123; send &quot;ssh -p $port $user@$hostname\r&quot;&#125;</span><br><span class="line">        expect &#123;</span><br><span class="line">            &quot;*yes/no&quot; &#123;    send &quot;yes\r&quot;; exp_continue &#125;</span><br><span class="line">            &quot;*password*&quot; &#123;   send &quot;$password\r;&quot;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #保持交互状态，把控制权交给控制台。</span><br><span class="line">    interact</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>go tips</title>
    <url>/2022/04/27/go-tips/</url>
    <content><![CDATA[<h2 id="go基本类型"><a href="#go基本类型" class="headerlink" title="go基本类型"></a>go基本类型</h2><ol>
<li>基本类型：<ul>
<li>整型（int&#x2F;uint&#x2F;int8&#x2F;uint8&#x2F;int16&#x2F;uint16&#x2F;int32&#x2F;uint32&#x2F;int64&#x2F;uint64&#x2F;byte&#x2F;rune等）</li>
<li>浮点数（float32&#x2F;float64）</li>
<li>复数类型（complex64&#x2F;complex128）</li>
<li>字符串（string）</li>
</ul>
</li>
<li>复合类型（又叫聚合类型）：数组和结构体类型。</li>
<li>引用类型：切片（slice）、map、channel、指针。</li>
<li>接口类型：如error。</li>
</ol>
<h2 id="比较"><a href="#比较" class="headerlink" title="&#x3D;&#x3D; 比较"></a>&#x3D;&#x3D; 比较</h2><p><strong>&#x3D;&#x3D;操作最重要的一个前提是：两个操作数类型必须相同！类型必须相同！类型必须相同!</strong></p>
<p>关于引用类型，有两个比较特殊的规定：</p>
<ul>
<li>切片之间不允许比较。切片只能与nil值比较。</li>
<li>map之间不允许比较。map只能与nil值比较。</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title>grpc demo 部署及调试</title>
    <url>/2024/12/30/grpc-demo-%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://segmentfault.com/a/1190000040761594">https://segmentfault.com/a/1190000040761594</a></li>
<li><a href="https://github.com/lubanproj/grpc-read">https://github.com/lubanproj/grpc-read</a></li>
<li><a href="https://github.com/grpc/grpc-go/tree/master/examples/helloworld">https://github.com/grpc/grpc-go/tree/master/examples/helloworld</a></li>
</ul>
<h2 id="一、安装protobuf"><a href="#一、安装protobuf" class="headerlink" title="一、安装protobuf"></a>一、安装protobuf</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载地址（用作编译，版本无要求）：</span></span><br><span class="line"><span class="comment">#https://github.com/protocolbuffers/protobuf/releases</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下载最新版本</span></span><br><span class="line">wget https://github.com/protocolbuffers/protobuf/releases/download/v29.2/protoc-29.2-osx-aarch_64.zip</span><br><span class="line"></span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">unzip protoc-29.2-osx-aarch_64.zip</span><br><span class="line"></span><br><span class="line">/Users/xxx/soft/grpc/bin/protoc --version</span><br></pre></td></tr></table></figure>

<h2 id="二、安装protoc-gen-go"><a href="#二、安装protoc-gen-go" class="headerlink" title="二、安装protoc-gen-go"></a>二、安装protoc-gen-go</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go version</span></span><br><span class="line">go version go1.23.0 darwin/arm64</span><br><span class="line"></span><br><span class="line"><span class="comment">#wget https://github.com/protocolbuffers/protobuf-go/releases/download/v1.36.1/protoc-gen-go.v1.36.1.darwin.arm64.tar.gz</span></span><br><span class="line"></span><br><span class="line">go install github.com/golang/protobuf/protoc-gen-go@latest</span><br></pre></td></tr></table></figure>

<h2 id="三、项目Demo"><a href="#三、项目Demo" class="headerlink" title="三、项目Demo"></a>三、项目Demo</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir grpcDemo</span></span><br><span class="line"><span class="comment"># go mod init grpcdemo</span></span><br></pre></td></tr></table></figure>

<h3 id="greeter-client-main-go内容"><a href="#greeter-client-main-go内容" class="headerlink" title="greeter_client&#x2F;main.go内容"></a>greeter_client&#x2F;main.go内容</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">&quot;grpcdemo/helloworld&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	defaultName = <span class="string">&quot;world&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	addr = flag.String(<span class="string">&quot;addr&quot;</span>, <span class="string">&quot;localhost:50051&quot;</span>, <span class="string">&quot;the address to connect to&quot;</span>)</span><br><span class="line">	name = flag.String(<span class="string">&quot;name&quot;</span>, defaultName, <span class="string">&quot;Name to greet&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// Set up a connection to the server.</span></span><br><span class="line">	conn, err := grpc.NewClient(*addr, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Contact the server and print out its response.</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;Greeting: %s&quot;</span>, r.GetMessage())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="greeter-server-main-go"><a href="#greeter-server-main-go" class="headerlink" title="greeter_server&#x2F;main.go"></a>greeter_server&#x2F;main.go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">&quot;grpcdemo/helloworld&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/reflection&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	port = flag.Int(<span class="string">&quot;port&quot;</span>, <span class="number">50051</span>, <span class="string">&quot;The server port&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(_ context.Context, in *pb.HelloRequest) (*pb.HelloReply, <span class="type">error</span>) &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;Received: %v&quot;</span>, in.GetName())</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">&quot;Hello &quot;</span> + in.GetName()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="string">&quot;:%d&quot;</span>, *port))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用 Reflection</span></span><br><span class="line">	reflection.Register(s)</span><br><span class="line">	log.Printf(<span class="string">&quot;server listening at %v&quot;</span>, lis.Addr())</span><br><span class="line">	<span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="helloworld-proto"><a href="#helloworld-proto" class="headerlink" title="helloworld.proto"></a>helloworld.proto</h2><ul>
<li>注意：go_package 路径</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The greeting service definition.</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// Sends a greeting</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The request message containing the user&#x27;s name.</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The response message containing the greetings</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloReply</span> &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="四、执行命令"><a href="#四、执行命令" class="headerlink" title="四、执行命令"></a>四、执行命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># cd grpcDemo </span></span><br><span class="line"><span class="comment"># go mod tidy</span></span><br><span class="line"><span class="comment"># /Users/xxx/soft/grpc/bin/protoc -I helloworld/ helloworld/helloworld.proto --go_out=plugins=grpc:helloworld</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── greeter_client</span><br><span class="line">│   └── main.go</span><br><span class="line">├── greeter_server</span><br><span class="line">│   └── main.go</span><br><span class="line">└── helloworld</span><br><span class="line">    ├── helloworld.pb.go</span><br><span class="line">    └── helloworld.proto</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行程序</span></span><br><span class="line">go run greeter_server/main.go</span><br><span class="line"></span><br><span class="line"><span class="comment">#另一终端运行</span></span><br><span class="line">go run greeter_client/main.go</span><br></pre></td></tr></table></figure>

<h2 id="五、grpcurl调试"><a href="#五、grpcurl调试" class="headerlink" title="五、grpcurl调试"></a>五、grpcurl调试</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装grpcurl</span></span><br><span class="line">brew install grpcurl</span><br><span class="line">或者</span><br><span class="line">go install github.com/fullstorydev/grpcurl/cmd/grpcurl@latest</span><br><span class="line"></span><br><span class="line"><span class="comment">#调试</span></span><br><span class="line">grpcurl -plaintext 127.0.0.1:50051 list</span><br><span class="line">grpcurl -plaintext 127.0.0.1:50051 list helloworld.Greeter</span><br><span class="line">grpcurl -plaintext 127.0.0.1:50051 describe helloworld.Greeter.SayHello</span><br><span class="line">grpcurl -plaintext 127.0.0.1:50051 describe helloworld.HelloRequest</span><br><span class="line">grpcurl -d <span class="string">&#x27;&#123;&quot;name&quot;: &quot;zhangsan&quot;&#125;&#x27;</span>  -plaintext 127.0.0.1:50051 helloworld.Greeter.SayHello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title>grpc服务端TLS加密步骤及单元调试</title>
    <url>/2024/12/31/grpc%E6%9C%8D%E5%8A%A1%E7%AB%AFTLS%E5%8A%A0%E5%AF%86%E6%AD%A5%E9%AA%A4%E5%8F%8A%E5%8D%95%E5%85%83%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="github参考地址"><a href="#github参考地址" class="headerlink" title="github参考地址"></a>github参考地址</h2><blockquote>
<p><a href="https://github.com/shispring/grpcdemo">https://github.com/shispring/grpcdemo</a></p>
</blockquote>
<h2 id="CA-证书制作："><a href="#CA-证书制作：" class="headerlink" title="CA 证书制作："></a>CA 证书制作：</h2><h3 id="1、生成-key-私钥文件"><a href="#1、生成-key-私钥文件" class="headerlink" title="1、生成.key  私钥文件"></a>1、生成.key  私钥文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out ca.key 4096</span><br></pre></td></tr></table></figure>

<h3 id="2、生成证书"><a href="#2、生成证书" class="headerlink" title="2、生成证书"></a>2、生成证书</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#生成.csr 证书签名请求文件</span><br><span class="line">openssl req -new -key ca.key -out ca.csr  -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=demo/OU=IT Department/CN=www.demo.cn&quot;</span><br><span class="line"></span><br><span class="line">#自签名生成.crt 证书文件</span><br><span class="line">openssl req -new -x509 -days 3650 -key ca.key -out ca.crt -config /opt/homebrew/etc/openssl@3/openssl.cnf \</span><br><span class="line">  -extensions v3_ca \</span><br><span class="line">  -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=demo/OU=IT Department/CN=www.demo.cn&quot;</span><br></pre></td></tr></table></figure>

<p>或者合成一步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -days 3650 -key ca.key -out ca.crt \</span><br><span class="line">  -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=demo/OU=IT Department/CN=www.demo.cn&quot; \</span><br><span class="line">  -config /opt/homebrew/etc/openssl@3/openssl.cnf \</span><br><span class="line">  -extensions v3_ca</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="服务端证书"><a href="#服务端证书" class="headerlink" title="服务端证书"></a>服务端证书</h2><h3 id="1、生成-key-私钥文件-1"><a href="#1、生成-key-私钥文件-1" class="headerlink" title="1、生成 .key 私钥文件"></a>1、生成 .key 私钥文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out server.key 2048</span><br></pre></td></tr></table></figure>

<h3 id="2、生成-csr-证书签名请求文件"><a href="#2、生成-csr-证书签名请求文件" class="headerlink" title="2、生成 .csr 证书签名请求文件"></a>2、生成 .csr 证书签名请求文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看openssl.conf</span><br><span class="line">openssl version -d</span><br><span class="line"></span><br><span class="line">#拷贝一份新的配置</span><br><span class="line">cp /opt/homebrew/etc/openssl@3/openssl.cnf server_openssl.cnf</span><br><span class="line"></span><br><span class="line">#添加SAN配置</span><br><span class="line">echo &quot;[SAN]&quot; &gt;&gt; server_openssl.cnf</span><br><span class="line">echo &quot;subjectAltName=DNS:*.demo.cn,DNS:www.demo.cn&quot; &gt;&gt; server_openssl.cnf</span><br><span class="line"></span><br><span class="line">#生成 .csr</span><br><span class="line">openssl req -new -key server.key -out server.csr -config server_openssl.cnf -reqexts SAN \</span><br><span class="line">  -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=demo/OU=IT Department/CN=www.demo.cn&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、签名生成-crt-证书文件"><a href="#3、签名生成-crt-证书文件" class="headerlink" title="3、签名生成.crt 证书文件"></a>3、签名生成.crt 证书文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -days 3650 -in server.csr -out server.crt \</span><br><span class="line">  -CA ca.crt -CAkey ca.key -CAcreateserial \</span><br><span class="line">  -extensions SAN -extfile server_openssl.cnf</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="查看证书内容"><a href="#查看证书内容" class="headerlink" title="查看证书内容"></a>查看证书内容</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in ./ca.crt -text -noout</span><br><span class="line">openssl x509 -in ./server.crt -text -noout</span><br></pre></td></tr></table></figure>


<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go test -v ./test/server_test.go </span><br><span class="line">go test -v ./test/client_test.go </span><br></pre></td></tr></table></figure>

<h2 id="grpcurl调试"><a href="#grpcurl调试" class="headerlink" title="grpcurl调试"></a>grpcurl调试</h2><blockquote>
<p><a href="https://github.com/fullstorydev/grpcurl/releases">https://github.com/fullstorydev/grpcurl/releases</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fullstorydev/grpcurl/releases/download/v1.9.3/grpcurl_1.9.3_linux_amd64.rpm</span><br><span class="line">sudo rpm -ivh grpcurl_1.9.3_linux_amd64.rpm</span><br><span class="line"></span><br><span class="line">#使用了TLS模式调试步骤</span><br><span class="line">grpcurl -v \</span><br><span class="line">  -cacert ca.crt \</span><br><span class="line">  -authority www.demo.cn \</span><br><span class="line">  127.0.0.1:8972 list</span><br><span class="line"></span><br><span class="line">grpcurl -v \</span><br><span class="line">  -cacert ca.crt \</span><br><span class="line">  -authority www.demo.cn \</span><br><span class="line">  127.0.0.1:8972 list helloworld.Greeter</span><br><span class="line"></span><br><span class="line">grpcurl -v \</span><br><span class="line">  -cacert ca.crt \</span><br><span class="line">  -authority www.demo.cn \</span><br><span class="line">  127.0.0.1:8972 describe helloworld.Greeter.SayHello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grpcurl -v \</span><br><span class="line">  -cacert ca.crt \</span><br><span class="line">  -authority www.demo.cn \</span><br><span class="line">  127.0.0.1:8972 describe helloworld.HelloRequest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grpcurl \</span><br><span class="line">  -cert server.crt \</span><br><span class="line">  -key server.key \</span><br><span class="line">  -cacert ca.crt \</span><br><span class="line">  -authority www.demo.cn \</span><br><span class="line">  -d &#x27;&#123;&quot;name&quot;: &quot;China&quot;&#125;&#x27; \</span><br><span class="line">  127.0.0.1:8972 helloworld.Greeter/SayHello</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">grpcurl \</span><br><span class="line">  -cert server.crt \</span><br><span class="line">  -key server.key \</span><br><span class="line">  -cacert ca.crt \</span><br><span class="line">  -authority www.demo.cn \</span><br><span class="line">  -d &#x27;&#123;&quot;name&quot;: &quot;China&quot;&#125;&#x27; \</span><br><span class="line">  127.0.0.1:8972 helloworld.Greeter.SayHello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1.-cert server.crt</span><br><span class="line">指定客户端使用的证书文件，这里是服务端证书文件 server.crt。</span><br><span class="line">2.-key server.key</span><br><span class="line">指定客户端使用的私钥文件，与 server.crt 配套使用。</span><br><span class="line">3.-cacert ca.crt</span><br><span class="line">指定 CA 根证书文件，用于验证服务端证书的合法性。</span><br><span class="line">4.-authority www.demo.cn</span><br><span class="line">指定服务端证书的 Common Name 或 subjectAltName，这里需要与服务端证书中的 CN 或 SAN 匹配（例如 www.demo.cn）。</span><br><span class="line">5.-d &#x27;&#123;&quot;name&quot;: &quot;China&quot;&#125;&#x27;</span><br><span class="line">指定请求数据，这里是一个 JSON 格式的请求体，调用服务端的 SayHello 方法时需要传递此数据。 </span><br></pre></td></tr></table></figure>
<hr>
<h3 id="关于-subj-的使用与含义"><a href="#关于-subj-的使用与含义" class="headerlink" title="关于 -subj 的使用与含义"></a><strong>关于 <code>-subj</code> 的使用与含义</strong></h3><p><code>-subj</code> 参数用于在命令行中直接指定证书的主题信息，避免交互式输入。这是非交互式生成证书时非常常用的方式。</p>
<h4 id="subj-参数的格式"><a href="#subj-参数的格式" class="headerlink" title="-subj 参数的格式"></a><strong><code>-subj</code> 参数的格式</strong></h4><p><code>-subj</code> 参数的值是一个以 <code>/</code> 分隔的字符串，每个字段的含义如下：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>全称</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>C</code></td>
<td>Country Name</td>
<td>国家代码，需为两位 ISO 3166 国家代码</td>
<td><code>C=CN</code></td>
</tr>
<tr>
<td><code>ST</code></td>
<td>State or Province Name</td>
<td>州或省的名称（可选）</td>
<td><code>ST=Beijing</code></td>
</tr>
<tr>
<td><code>L</code></td>
<td>Locality Name</td>
<td>地区或城市名称</td>
<td><code>L=Beijing</code></td>
</tr>
<tr>
<td><code>O</code></td>
<td>Organization Name</td>
<td>组织名称（通常是公司名称）</td>
<td><code>O=demo</code></td>
</tr>
<tr>
<td><code>OU</code></td>
<td>Organizational Unit</td>
<td>组织部门名称（可选，通常是团队或部门名称）</td>
<td><code>OU=IT Department</code></td>
</tr>
<tr>
<td><code>CN</code></td>
<td>Common Name</td>
<td>通用名称，通常是域名或主机名</td>
<td><code>CN=www.demo.cn</code></td>
</tr>
<tr>
<td><code>emailAddress</code></td>
<td>Email Address</td>
<td>邮箱地址（可选）</td>
<td><code>emailAddress=admin@demo.cn</code></td>
</tr>
</tbody></table>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-subj <span class="string">&quot;/C=CN/ST=Beijing/L=Beijing/O=demo/OU=IT Department/CN=www.demo.cn&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>字段的匹配</strong>：</p>
<ul>
<li><code>CN</code>（Common Name）字段必须与您希望匹配的域名一致。例如，<code>CN=www.demo.cn</code> 表示该证书适用于 <code>www.demo.cn</code>。</li>
<li>如果需要支持多个域名，请在扩展字段（如 <code>subjectAltName</code>）中添加更多域名，而不是只依赖 <code>CN</code>。</li>
</ul>
</li>
<li><p><strong>格式正确性</strong>：</p>
<ul>
<li>每个字段必须以 <code>/</code> 开头，不能有多余的空格。</li>
<li>如果某些字段为空，可以省略，但必须确保其他字段正确填写。</li>
</ul>
</li>
<li><p><strong>兼容性问题</strong>：</p>
<ul>
<li><code>CN</code> 字段在现代证书中已逐渐被 <code>subjectAltName</code> 替代，因此推荐在配置文件中明确添加 <code>SAN</code> 扩展。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Issuer-的含义"><a href="#Issuer-的含义" class="headerlink" title="Issuer 的含义"></a><strong>Issuer 的含义</strong></h3><p>在读取证书时，<code>Issuer</code> 表示签发该证书的实体信息，即证书的颁发者（CA）。以下是常见的字段及其含义：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>C</code></td>
<td>签发者所在国家代码</td>
<td><code>C=CN</code></td>
</tr>
<tr>
<td><code>ST</code></td>
<td>签发者所在州或省份</td>
<td><code>ST=Beijing</code></td>
</tr>
<tr>
<td><code>L</code></td>
<td>签发者所在城市</td>
<td><code>L=Beijing</code></td>
</tr>
<tr>
<td><code>O</code></td>
<td>签发者组织名称</td>
<td><code>O=demo Root CA</code></td>
</tr>
<tr>
<td><code>OU</code></td>
<td>签发者组织部门</td>
<td><code>OU=Certificate Authority</code></td>
</tr>
<tr>
<td><code>CN</code></td>
<td>签发者的通用名称（通常是 CA 的名称）</td>
<td><code>CN=demo Root CA</code></td>
</tr>
</tbody></table>
<hr>
<h4 id="Issuer-和-Subject-的区别"><a href="#Issuer-和-Subject-的区别" class="headerlink" title="Issuer 和 Subject 的区别"></a><strong>Issuer 和 Subject 的区别</strong></h4><ul>
<li>**<code>Issuer</code>**：表示证书的颁发者，即签署该证书的 CA。</li>
<li>**<code>Subject</code>**：表示证书的持有者，即证书所代表的实体。</li>
</ul>
<hr>
<h3 id="如何查看证书的-Issuer-信息"><a href="#如何查看证书的-Issuer-信息" class="headerlink" title="如何查看证书的 Issuer 信息"></a><strong>如何查看证书的 Issuer 信息</strong></h3><p>使用以下命令查看证书的详细信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> server.crt -text -noout</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol>
<li><code>-subj</code> 提供了一种简洁、非交互式的方式指定证书的主题信息。</li>
<li>证书的 <code>Issuer</code> 表示签发证书的 CA 信息，通常需要与信任链中的根证书匹配。</li>
<li>在现代证书中，<code>subjectAltName</code> 的配置非常重要，<code>CN</code> 仅作为备用字段。</li>
</ol>
]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title>helm使用教程</title>
    <url>/2024/11/07/helm%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#helm与k8s版本兼容匹配：https://helm.sh/zh/docs/topics/version_skew/</span></span><br><span class="line">wget https://get.helm.sh/helm-v3.15.3-linux-amd64.tar.gz</span><br><span class="line">tar  zxvf helm-v3.15.3-linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">mv</span> linux-amd64/helm /usr/local/bin/</span><br><span class="line">helm version</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除Helm使用时关于kubernetes文件的警告</span></span><br><span class="line"><span class="built_in">chmod</span> g-rw /root/.kube/config</span><br><span class="line"><span class="built_in">chmod</span> o-r /root/.kube/config</span><br></pre></td></tr></table></figure>

<h2 id="缓存路径"><a href="#缓存路径" class="headerlink" title="缓存路径"></a>缓存路径</h2><table>
<thead>
<tr>
<th>操作系统</th>
<th>缓存路径</th>
<th>配置路径</th>
<th>数据路径</th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td><code>$HOME/.cache/helm</code></td>
<td><code>$HOME/.config/helm</code></td>
<td><code>$HOME/.local/share/helm</code></td>
</tr>
<tr>
<td>macOS</td>
<td><code>$HOME/Library/Caches/helm</code></td>
<td><code>$HOME/Library/Preferences/helm</code></td>
<td><code>$HOME/Library/helm</code></td>
</tr>
<tr>
<td>Windows</td>
<td><code>%TEMP%\helm</code></td>
<td><code>%APPDATA%\helm</code></td>
<td><code>%APPDATA%\helm</code></td>
</tr>
</tbody></table>
<h2 id="添加仓库"><a href="#添加仓库" class="headerlink" title="添加仓库"></a>添加仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#常见仓库</span></span><br><span class="line">helm repo add bitnami <span class="string">&quot;https://helm-charts.itboon.top/bitnami&quot;</span></span><br><span class="line">helm repo add grafana <span class="string">&quot;https://helm-charts.itboon.top/grafana&quot;</span></span><br><span class="line">helm repo add prometheus-community <span class="string">&quot;https://helm-charts.itboon.top/prometheus-community&quot;</span></span><br><span class="line">helm repo add ingress-nginx <span class="string">&quot;https://helm-charts.itboon.top/ingress-nginx&quot;</span></span><br><span class="line">helm repo add aliyun  https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</span><br><span class="line"></span><br><span class="line">helm repo list</span><br><span class="line">helm repo update</span><br></pre></td></tr></table></figure>

<h2 id="搜索与下载"><a href="#搜索与下载" class="headerlink" title="搜索与下载"></a>搜索与下载</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm search repo bitnami</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询nginx相关的包</span></span><br><span class="line">helm search repo  bitnami/nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询版本</span></span><br><span class="line">helm search repo bitnami/nginx -l</span><br><span class="line"></span><br><span class="line">helm pull bitnami/nginx --version 18.1.7</span><br><span class="line"><span class="comment">#校验打包</span></span><br><span class="line">helm lint --strict nginx-18.1.7.tgz</span><br><span class="line">tar zxvf nginx-18.1.7.tgz</span><br><span class="line">tree -L 1 nginx</span><br><span class="line">nginx</span><br><span class="line">|-- Chart.lock</span><br><span class="line">|-- Chart.yaml</span><br><span class="line">|-- README.md</span><br><span class="line">|-- charts</span><br><span class="line">|-- templates</span><br><span class="line">|-- values.schema.json</span><br><span class="line">`-- values.yaml</span><br></pre></td></tr></table></figure>

<h3 id="编辑values-yaml-与Chart-yaml的镜像仓库"><a href="#编辑values-yaml-与Chart-yaml的镜像仓库" class="headerlink" title="编辑values.yaml 与Chart.yaml的镜像仓库"></a>编辑values.yaml 与Chart.yaml的镜像仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -rn <span class="string">&quot;image:&quot;</span></span><br><span class="line"><span class="comment">#cat Chart.yaml | grep &quot;image:&quot;</span></span><br><span class="line"><span class="comment">#将docker.io改为:swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io</span></span><br></pre></td></tr></table></figure>

<h3 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#渲染：测试模板渲染的内容但又不想安装任何实际应用时</span></span><br><span class="line"><span class="comment">#helm install webapp --debug --dry-run ./nginx</span></span><br><span class="line">helm install webapp . --<span class="built_in">set</span> service.type=NodePort -n chart-demo</span><br><span class="line"></span><br><span class="line">helm status webapp  -n chart-demo</span><br><span class="line"></span><br><span class="line">kubectl get all -n chart-demo</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印releases</span></span><br><span class="line">helm list -n chart-demo</span><br><span class="line"></span><br><span class="line">helm uninstall wabapp -n chart-demo</span><br></pre></td></tr></table></figure>

<h2 id="创建教程"><a href="#创建教程" class="headerlink" title="创建教程"></a>创建教程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#参数含义</span><br><span class="line">https://helm.sh/zh/docs/topics/charts/</span><br><span class="line"></span><br><span class="line">#创建与安装</span><br><span class="line">https://helm.sh/zh/docs/chart_template_guide/getting_started/</span><br></pre></td></tr></table></figure>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建</span><br><span class="line">helm create mychart</span><br><span class="line"></span><br><span class="line">#helm install full-coral ./mychart</span><br><span class="line"></span><br><span class="line">#查看生成的完整的YAML</span><br><span class="line">helm get manifest full-coral</span><br><span class="line"></span><br><span class="line">#卸载</span><br><span class="line">helm uninstall full-coral</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#想测试模板渲染的内容但又不想安装任何实际应用</span><br><span class="line">helm install --debug --dry-run goodly-guppy ./mychart</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">helm install --dry-run --disable-openapi-validation moldy-jaguar ./mychart</span><br><span class="line"></span><br><span class="line">以下命令有助于调试：</span><br><span class="line"></span><br><span class="line">helm lint 是验证chart是否遵循最佳实践的首选工具。</span><br><span class="line">helm template --debug 在本地测试渲染chart模板。</span><br><span class="line">helm install --dry-run --debug：我们已经看到过这个技巧了，这是让服务器渲染模板的好方法，然后返回生成的清单文件。</span><br><span class="line">helm get manifest: 这是查看安装在服务器上的模板的好方法。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Helm-针对集群的常用操作命令"><a href="#Helm-针对集群的常用操作命令" class="headerlink" title="Helm 针对集群的常用操作命令"></a>Helm 针对集群的常用操作命令</h3><h4 id="安装-Chart"><a href="#安装-Chart" class="headerlink" title="安装 Chart"></a><strong>安装 Chart</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install &lt;release-name&gt; &lt;chart-path-or-name&gt; [options]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install my-app ./my-chart</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="卸载-Chart"><a href="#卸载-Chart" class="headerlink" title="卸载 Chart"></a><strong>卸载 Chart</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm uninstall &lt;release-name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm uninstall my-app -n default</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="升级-Chart"><a href="#升级-Chart" class="headerlink" title="升级 Chart"></a><strong>升级 Chart</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm upgrade &lt;release-name&gt; &lt;chart-path-or-name&gt; [options]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm upgrade my-app ./my-chart</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="回滚到之前的版本"><a href="#回滚到之前的版本" class="headerlink" title="回滚到之前的版本"></a><strong>回滚到之前的版本</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm rollback &lt;release-name&gt; &lt;revision&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm rollback my-app 2 -n default</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="查看-Release-历史"><a href="#查看-Release-历史" class="headerlink" title="查看 Release 历史"></a><strong>查看 Release 历史</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm <span class="built_in">history</span> &lt;release-name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm <span class="built_in">history</span> my-app -n default</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="测试-Chart"><a href="#测试-Chart" class="headerlink" title="测试 Chart"></a><strong>测试 Chart</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm <span class="built_in">test</span> &lt;release-name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm <span class="built_in">test</span> my-app -n default</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="渲染-Chart-模板"><a href="#渲染-Chart-模板" class="headerlink" title="渲染 Chart 模板"></a><strong>渲染 Chart 模板</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm template &lt;chart-path-or-name&gt; [options]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm template ./my-chart</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="调试安装或升级"><a href="#调试安装或升级" class="headerlink" title="调试安装或升级"></a><strong>调试安装或升级</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install --debug --dry-run &lt;release-name&gt; &lt;chart-path-or-name&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm install --debug --dry-run my-app ./my-chart</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="导出-Release-的配置"><a href="#导出-Release-的配置" class="headerlink" title="导出 Release 的配置"></a><strong>导出 Release 的配置</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm get values &lt;release-name&gt; -n &lt;namespace&gt; [options]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm get values my-app -n default</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="检查-Chart-的版本更新"><a href="#检查-Chart-的版本更新" class="headerlink" title="检查 Chart 的版本更新"></a><strong>检查 Chart 的版本更新</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm search repo &lt;chart-name&gt; --versions</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm search repo nginx --versions</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="添加或更新-Chart-仓库"><a href="#添加或更新-Chart-仓库" class="headerlink" title="添加或更新 Chart 仓库"></a><strong>添加或更新 Chart 仓库</strong></h4><ul>
<li>添加仓库：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo add &lt;repo-name&gt; &lt;repo-url&gt;</span><br></pre></td></tr></table></figure></li>
<li>更新仓库：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm repo update</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="推荐-Helm-工作流"><a href="#推荐-Helm-工作流" class="headerlink" title="推荐 Helm 工作流"></a>推荐 Helm 工作流</h3><ol>
<li><p><strong>列出已安装的 Releases</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm list -A</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查某个 Release 的状态</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm status &lt;release-name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>备份配置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm get values &lt;release-name&gt; -n &lt;namespace&gt; &gt; backup.yaml</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>升级或回滚</strong></p>
<ul>
<li>升级：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm upgrade &lt;release-name&gt; &lt;chart-path-or-name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure></li>
<li>回滚：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">helm rollback &lt;release-name&gt; &lt;revision&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#推送</span><br><span class="line">helm chart 模式：安装cm-push插件</span><br><span class="line">helm plugin install https://github.com/chartmuseum/helm-push.git</span><br><span class="line">helm chart 模式：查看已安装插件</span><br><span class="line">helm plugin list</span><br><span class="line">helm chart 模式：推送</span><br><span class="line">HELM_REPO_USERNAME=xxx HELM_REPO_PASSWORD=xxx helm cm-push ingress-nginx-1.11.5.tgz &lt;repo&gt;</span><br><span class="line"></span><br><span class="line">#比较差异</span><br><span class="line">helm plugin install https://github.com/databus23/helm-diff.git</span><br><span class="line">helm diff revision ingress-nginx 1 2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>hexo建站</title>
    <url>/2021/11/05/hexo_env/</url>
    <content><![CDATA[<h2 id="一、nodejs-安装"><a href="#一、nodejs-安装" class="headerlink" title="一、nodejs 安装"></a>一、nodejs 安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网: https://nodejs.org/en/</span><br></pre></td></tr></table></figure>

<h2 id="二、hexo安装"><a href="#二、hexo安装" class="headerlink" title="二、hexo安装"></a>二、hexo安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网：https://hexo.io/zh-cn/</span><br><span class="line">1. npm install hexo-cli -g</span><br><span class="line">2. hexo init hexo  #初始化博客</span><br><span class="line">3. cd hexo</span><br><span class="line">4. hexo server   #启动服务</span><br><span class="line"></span><br><span class="line">#升级命令：</span><br><span class="line">npm update hexo-cli -g</span><br></pre></td></tr></table></figure>

<h2 id="三、生成文档"><a href="#三、生成文档" class="headerlink" title="三、生成文档"></a>三、生成文档</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. cd hexo</span><br><span class="line">2. hexo n myTest  # 建文章,同命令：hexo new myTest</span><br><span class="line">3. hexo g         #生成，同命令：hexo generate</span><br><span class="line">4. hexo s         #启动服务，可预览</span><br><span class="line"></span><br><span class="line">5. hexo d          #部署,需要配置github，hexo deploy</span><br></pre></td></tr></table></figure>

<h2 id="四、部署到github"><a href="#四、部署到github" class="headerlink" title="四、部署到github"></a>四、部署到github</h2><ul>
<li>部署文档：<a href="https://hexo.io/docs/one-command-deployment">https://hexo.io/docs/one-command-deployment</a></li>
<li>github新建项目：shispring.github.io</li>
<li>编辑配置文件：vim hexo&#x2F;_config.yaml<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:shispring/shispring.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li>
<li>npm install hexo-deployer-git –save</li>
<li>hexo g</li>
<li>hexo d</li>
</ul>
<h2 id="五、更换主题"><a href="#五、更换主题" class="headerlink" title="五、更换主题"></a>五、更换主题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">详情请查看：</span><br><span class="line">https://github.com/theme-next/hexo-theme-next</span><br><span class="line">主题配置</span><br><span class="line">https://hexo-theme-async.imalun.com/guide/page</span><br><span class="line"></span><br><span class="line">主题添加搜索功能</span><br><span class="line">https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</span><br><span class="line"></span><br><span class="line">Hexo添加分类及标签</span><br><span class="line">https://tohugo.com/2021/01/26/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE%EF%BC%88%E5%9C%A8Next%E4%B8%BB%E9%A2%98%E4%B8%8B%EF%BC%89/</span><br></pre></td></tr></table></figure>


<h2 id="hexo-Fliud美化"><a href="#hexo-Fliud美化" class="headerlink" title="hexo + Fliud美化"></a>hexo + Fliud美化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://b.wihi.top/posts/c1486c12</span><br><span class="line">https://emoryhuang.cn/blog/1729600336.html</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>hpa pod计算</title>
    <url>/2024/10/21/hpa-pod%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>在 Kubernetes 中配置基于 CPU 利用率的 Horizontal Pod Autoscaler (HPA) 策略时，扩展的 Pod 数量根据以下公式计算：</p>
<h3 id="HPA-计算扩展-Pod-数量的公式："><a href="#HPA-计算扩展-Pod-数量的公式：" class="headerlink" title="HPA 计算扩展 Pod 数量的公式："></a>HPA 计算扩展 Pod 数量的公式：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desiredReplicas = ceil[currentReplicas * (currentMetricValue / targetMetricValue)]</span><br></pre></td></tr></table></figure>

<p>具体来说：</p>
<ol>
<li><strong>currentReplicas</strong>：当前正在运行的 Pod 数量。</li>
<li><strong>currentMetricValue</strong>：当前的 CPU 使用率，通常是所有 Pod 的 CPU 使用情况的平均值（例如 75%）。</li>
<li><strong>targetMetricValue</strong>：你在 HPA 配置中指定的目标 CPU 利用率（例如 65%）。</li>
</ol>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>假设：</p>
<ul>
<li>当前有 <strong>4 个 Pod</strong>。</li>
<li>目标 CPU 利用率为 **65%**。</li>
<li>当前的平均 CPU 利用率为 **80%**。</li>
</ul>
<p>计算公式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desiredReplicas = ceil[4 * (80 / 65)] = ceil[4 * 1.23] = ceil[4.92] = 5</span><br></pre></td></tr></table></figure>
<p>因此，HPA 将扩展至 <strong>5 个 Pod</strong>，以保证 CPU 利用率降到你设置的目标值附近。</p>
<h3 id="扩展和缩容过程："><a href="#扩展和缩容过程：" class="headerlink" title="扩展和缩容过程："></a>扩展和缩容过程：</h3><ul>
<li><strong>扩展</strong>：当当前的 CPU 使用率高于目标值时，HPA 会增加 Pod 数量。</li>
<li><strong>缩容</strong>：如果当前的 CPU 使用率低于目标值，HPA 会减少 Pod 数量，但缩容通常有冷却时间，避免频繁调整。</li>
</ul>
<h3 id="配置示例："><a href="#配置示例：" class="headerlink" title="配置示例："></a>配置示例：</h3><p>在 HPA 配置文件中，设置 <code>targetCPUUtilizationPercentage</code>，例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-hpa</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-deployment</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">metrics:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Resource</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cpu</span></span><br><span class="line">      <span class="attr">target:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">Utilization</span></span><br><span class="line">        <span class="attr">averageUtilization:</span> <span class="number">65</span>  <span class="comment"># 目标 CPU 利用率</span></span><br></pre></td></tr></table></figure>
<p>此配置将基于 CPU 利用率，动态调整 Pod 数量，使整体利用率保持在 65% 附近。</p>
<p>这种机制确保集群资源得到充分利用，同时避免单个 Pod 过载或资源浪费。</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>http协议比对</title>
    <url>/2024/12/30/http%E5%8D%8F%E8%AE%AE%E6%AF%94%E5%AF%B9/</url>
    <content><![CDATA[<p>以下是对 HTTP&#x2F;1.0、HTTP&#x2F;1.1、HTTP&#x2F;2 和 HTTP&#x2F;3 的详细介绍，包括它们产生的背景、遇到的问题、解决方案，以及优缺点和实现方式，最后以表格形式进行汇总。</p>
<hr>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a><strong>HTTP&#x2F;1.0</strong></h3><h4 id="背景-1996年发布"><a href="#背景-1996年发布" class="headerlink" title="**背景:1996年发布 **"></a>**背景:1996年发布 **</h4><ul>
<li><p><strong>问题</strong>：  </p>
<ol>
<li>每个资源请求都需要建立新的 TCP 连接（无连接特性）。  </li>
<li>没有缓存机制，导致重复下载资源。  </li>
<li>没有明确的主机字段，无法支持虚拟主机。</li>
</ol>
</li>
<li><p><strong>解决方案</strong>：<br>HTTP&#x2F;1.0 引入了基本的请求-响应模型，支持简单的网页浏览，但未解决连接效率和缓存的问题。</p>
</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul>
<li>简单易用，适合早期的互联网环境。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul>
<li>无连接：每次请求都需新建连接，效率低下。  </li>
<li>无缓存：资源浪费严重。  </li>
<li>无主机字段：难以支持多站点。</li>
</ul>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><ul>
<li>每个请求通过独立的 TCP 连接完成。</li>
</ul>
<hr>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a><strong>HTTP&#x2F;1.1</strong></h3><h4 id="背景-1997年发布，1999年成为RFC-2616标准"><a href="#背景-1997年发布，1999年成为RFC-2616标准" class="headerlink" title="**背景:1997年发布，1999年成为RFC 2616标准 **"></a>**背景:1997年发布，1999年成为RFC 2616标准 **</h4><ul>
<li><p><strong>问题</strong>：  </p>
<ol>
<li>HTTP&#x2F;1.0 的无连接特性导致网络资源浪费。  </li>
<li>缺乏缓存支持，重复请求同一资源。  </li>
<li>早期未支持持久连接和并发请求。</li>
</ol>
</li>
<li><p><strong>解决方案</strong>：  </p>
<ol>
<li>引入持久连接（Keep-Alive）。  </li>
<li>支持分块传输编码（Chunked Transfer Encoding）。  </li>
<li>增加缓存控制头（Cache-Control）。  </li>
<li>引入 Host 字段支持虚拟主机。</li>
</ol>
</li>
</ul>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul>
<li>持久连接减少了 TCP 连接建立的开销。  </li>
<li>增强了缓存能力，提高了性能。  </li>
<li>支持分块传输，适合动态内容。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul>
<li>头部阻塞（Head-of-Line Blocking）问题仍然存在。  </li>
<li>并发请求效率低，需通过多连接实现。</li>
</ul>
<h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><ul>
<li>默认使用持久连接，多个请求可复用同一连接。</li>
</ul>
<hr>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a><strong>HTTP&#x2F;2</strong></h3><h4 id="背景-2015年发布，基于Google的SPDY协议"><a href="#背景-2015年发布，基于Google的SPDY协议" class="headerlink" title="**背景:2015年发布，基于Google的SPDY协议 **"></a>**背景:2015年发布，基于Google的SPDY协议 **</h4><ul>
<li><p><strong>问题</strong>：  </p>
<ol>
<li>HTTP&#x2F;1.1 的头部阻塞问题导致性能瓶颈。  </li>
<li>多连接管理复杂，浏览器对单域名的连接数有限制。  </li>
<li>请求和响应体积大，头部冗余。</li>
</ol>
</li>
<li><p><strong>解决方案</strong>：  </p>
<ol>
<li>引入二进制分帧（Binary Framing）。  </li>
<li>支持多路复用（Multiplexing），同一连接内可并发多个请求。  </li>
<li>使用头部压缩（HPACK）减少冗余。</li>
</ol>
</li>
</ul>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul>
<li>多路复用消除了头部阻塞问题。  </li>
<li>头部压缩大幅减少数据体积。  </li>
<li>单连接高效管理，减少网络资源占用。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul>
<li>实现复杂度增加。  </li>
<li>对 TLS（加密连接）的依赖较强。</li>
</ul>
<h4 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><ul>
<li>使用二进制协议，所有数据分为帧处理。</li>
</ul>
<hr>
<h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP&#x2F;3"></a><strong>HTTP&#x2F;3</strong></h3><h4 id="背景-2018年发布草案，基于Google的QUIC协议"><a href="#背景-2018年发布草案，基于Google的QUIC协议" class="headerlink" title="**背景:2018年发布草案，基于Google的QUIC协议 **"></a>**背景:2018年发布草案，基于Google的QUIC协议 **</h4><ul>
<li><p><strong>问题</strong>：  </p>
<ol>
<li>HTTP&#x2F;2 的多路复用依赖 TCP，但 TCP 的丢包重传机制会阻塞其他流。  </li>
<li>TLS 的握手时间较长，影响性能。  </li>
<li>移动网络切换导致连接中断。</li>
</ol>
</li>
<li><p><strong>解决方案</strong>：  </p>
<ol>
<li>基于 QUIC 协议，使用 UDP 替代 TCP。  </li>
<li>集成 TLS，减少握手步骤。  </li>
<li>支持连接迁移（Connection Migration），适应移动网络。</li>
</ol>
</li>
</ul>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul>
<li>基于 UDP 的多路复用避免了 TCP 的丢包阻塞问题。  </li>
<li>更快的握手速度，减少延迟。  </li>
<li>连接迁移增强了移动场景的稳定性。</li>
</ul>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul>
<li>依赖较新的网络协议栈，旧设备支持较差。  </li>
<li>部署需要服务器和客户端更新。</li>
</ul>
<h4 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><ul>
<li>使用 QUIC 协议，直接在应用层实现可靠传输和加密。</li>
</ul>
<hr>
<h3 id="汇总对比表格"><a href="#汇总对比表格" class="headerlink" title="汇总对比表格"></a><strong>汇总对比表格</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>HTTP&#x2F;1.0</strong></th>
<th><strong>HTTP&#x2F;1.1</strong></th>
<th><strong>HTTP&#x2F;2</strong></th>
<th><strong>HTTP&#x2F;3</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>背景问题</strong></td>
<td>无连接、无缓存、无主机字段</td>
<td>无持久连接、无缓存机制</td>
<td>头部阻塞、多连接管理复杂</td>
<td>TCP 丢包阻塞、握手延迟高</td>
</tr>
<tr>
<td><strong>连接方式</strong></td>
<td>每请求一个连接</td>
<td>持久连接（Keep-Alive）</td>
<td>单连接多路复用</td>
<td>基于 QUIC 的单连接多路复用</td>
</tr>
<tr>
<td><strong>数据格式</strong></td>
<td>文本</td>
<td>文本</td>
<td>二进制</td>
<td>二进制</td>
</tr>
<tr>
<td><strong>缓存支持</strong></td>
<td>无</td>
<td>Cache-Control 支持</td>
<td>强缓存支持</td>
<td>强缓存支持</td>
</tr>
<tr>
<td><strong>加密支持</strong></td>
<td>无</td>
<td>可选（HTTPS）</td>
<td>强制 TLS</td>
<td>集成 TLS</td>
</tr>
<tr>
<td><strong>优点</strong></td>
<td>简单易用</td>
<td>持久连接、分块传输、缓存增强</td>
<td>多路复用、头部压缩</td>
<td>低延迟、抗丢包、连接迁移</td>
</tr>
<tr>
<td><strong>缺点</strong></td>
<td>效率低、资源浪费</td>
<td>头部阻塞、并发受限</td>
<td>依赖 TLS，复杂度增加</td>
<td>依赖新协议栈，兼容性较差</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>早期网页浏览</td>
<td>普通网页和 API 服务</td>
<td>高并发、大量请求</td>
<td>移动场景、高性能需求</td>
</tr>
</tbody></table>
<hr>
]]></content>
      <categories>
        <category>network</category>
      </categories>
  </entry>
  <entry>
    <title>http状态码</title>
    <url>/2024/08/30/http%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<h2 id="HTTP状态码总结"><a href="#HTTP状态码总结" class="headerlink" title="HTTP状态码总结"></a>HTTP状态码总结</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">100：继续 客户端应当继续发送请求。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。</span><br><span class="line"></span><br><span class="line">101： 转换协议 在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。</span><br><span class="line"></span><br><span class="line">102：继续处理 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</span><br><span class="line"></span><br><span class="line">200：请求成功 处理方式：获得响应的内容，进行处理</span><br><span class="line"></span><br><span class="line">201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到 处理方式：爬虫中不会遇到</span><br><span class="line"></span><br><span class="line">202：请求被接受，但处理尚未完成 处理方式：阻塞等待</span><br><span class="line"></span><br><span class="line">204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。 处理方式：丢弃</span><br><span class="line"></span><br><span class="line">300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。 处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃</span><br><span class="line"></span><br><span class="line">301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源 处理方式：重定向到分配的URL</span><br><span class="line"></span><br><span class="line">302：请求到的资源在一个不同的URL处临时保存 处理方式：重定向到临时的URL</span><br><span class="line"></span><br><span class="line">304：请求的资源未更新 处理方式：丢弃</span><br><span class="line"></span><br><span class="line">400：非法请求 处理方式：丢弃</span><br><span class="line"></span><br><span class="line">401：未授权 处理方式：丢弃</span><br><span class="line"></span><br><span class="line">403：禁止 处理方式：丢弃</span><br><span class="line"></span><br><span class="line">404：没有找到 处理方式：丢弃</span><br><span class="line"></span><br><span class="line">500：服务器内部错误 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。</span><br><span class="line"></span><br><span class="line">501：服务器无法识别 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</span><br><span class="line"></span><br><span class="line">502：错误网关 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</span><br><span class="line"></span><br><span class="line">503：服务出错 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>informer 核心机制</title>
    <url>/2024/11/28/informer-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>在 Kubernetes 的 <code>client-go</code> 中，Informer 的队列机制是控制器实现异步事件处理的核心部分。主要通过 <strong>工作队列 (WorkQueue)</strong> 实现，用于协调资源对象的事件处理，确保高效、可靠和去重的处理流程。</p>
<p>以下是 <code>client-go</code> 中工作队列的核心机制：</p>
<hr>
<h3 id="1-Queue-机制的核心组件"><a href="#1-Queue-机制的核心组件" class="headerlink" title="1. Queue 机制的核心组件"></a><strong>1. Queue 机制的核心组件</strong></h3><p><code>client-go</code> 的队列机制主要由以下组件组成：</p>
<ol>
<li><p><strong><code>WorkQueue</code> 接口</strong>  </p>
<ul>
<li><code>client-go</code> 提供了一种高效的事件队列实现：<code>rateLimitingQueue</code>。</li>
<li>常见接口包括：<code>Add</code>、<code>Get</code>、<code>Done</code>、<code>Forget</code> 和 <code>ShutDown</code>。</li>
</ul>
</li>
<li><p><strong><code>rateLimitingQueue</code></strong>  </p>
<ul>
<li>一种带速率限制的队列，用于在失败时控制重试的速率，防止频繁的事件触发导致资源占用过高。</li>
<li>内部通过 <code>DelayingQueue</code> 和 <code>DefaultControllerRateLimiter</code> 实现重试和延迟处理。</li>
</ul>
</li>
<li><p><strong>队列与同步机制</strong>  </p>
<ul>
<li><code>Informer</code> 监听到资源变化后，通过回调函数 (<code>AddEventHandler</code>) 将事件放入队列。</li>
<li>控制器从队列中读取事件并处理，每次处理后需调用 <code>Done</code> 标记完成。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-队列的处理逻辑"><a href="#2-队列的处理逻辑" class="headerlink" title="2. 队列的处理逻辑"></a><strong>2. 队列的处理逻辑</strong></h3><h4 id="核心流程："><a href="#核心流程：" class="headerlink" title="核心流程："></a>核心流程：</h4><ol>
<li><p><strong>资源事件入队</strong>：</p>
<ul>
<li>当 <code>Informer</code> 侦听到资源对象的 <code>Add</code>、<code>Update</code> 或 <code>Delete</code> 事件时，会通过回调将资源标识符（如名字或键）加入队列。</li>
<li>示例代码：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">queue.Add(objKey)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>事件出队并处理</strong>：</p>
<ul>
<li>控制器通过 <code>Get</code> 方法从队列取出事件，处理完成后调用 <code>Done</code>。</li>
<li>示例代码：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    obj, shutdown := queue.Get()</span><br><span class="line">    <span class="keyword">if</span> shutdown &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    handleErr(err, obj)</span><br><span class="line">    queue.Done(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>错误处理与重试</strong>：</p>
<ul>
<li>如果处理失败，可以调用 <code>AddRateLimited</code> 重新将事件入队，触发限速重试。</li>
<li>如果确定不再重试，调用 <code>Forget</code> 移除事件。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-核心功能特性"><a href="#3-核心功能特性" class="headerlink" title="3. 核心功能特性"></a><strong>3. 核心功能特性</strong></h3><ol>
<li><p><strong>去重</strong>：</p>
<ul>
<li>队列内对象使用唯一键（通常是 <code>namespace/name</code> 格式）标识，避免重复处理同一资源事件。</li>
</ul>
</li>
<li><p><strong>速率限制</strong>：</p>
<ul>
<li>内置的速率限制器（<code>RateLimiter</code>）控制失败重试的频率，防止集群压力过大。</li>
<li>常用速率限制器：<ul>
<li><code>BucketRateLimiter</code>: 令牌桶算法。</li>
<li><code>ItemExponentialFailureRateLimiter</code>: 指数增长重试间隔。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>延迟处理</strong>：</p>
<ul>
<li>支持延迟任务，适用于需要等待某些条件满足后再处理的场景。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a><strong>4. 示例代码</strong></h3><p>以下是使用 <code>WorkQueue</code> 的典型控制器实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">queue := workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enqueue</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    key, err := cache.MetaNamespaceKeyFunc(obj)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue.Add(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    obj, shutdown := queue.Get()</span><br><span class="line">    <span class="keyword">if</span> shutdown &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    key := obj.(<span class="type">string</span>) <span class="comment">// 处理对象的唯一标识符</span></span><br><span class="line">    err := syncHandler(key)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        queue.AddRateLimited(key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue.Forget(key)</span><br><span class="line">    &#125;</span><br><span class="line">    queue.Done(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="流程图演示-claude-sonnet-4"><a href="#流程图演示-claude-sonnet-4" class="headerlink" title="流程图演示(claude-sonnet-4)"></a>流程图演示(claude-sonnet-4)</h3><ul>
<li><p>WorkQueue<br><img src="https://raw.githubusercontent.com/shispring/picgo/master/controller-demo.png" alt="controller-demo" title="controller-demo"></p>
</li>
<li><p>list&#x2F;watch<br><img src="https://raw.githubusercontent.com/shispring/picgo/master/list-watch.png" alt="list-watch" title="list-watch"></p>
</li>
</ul>
<h3 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a><strong>5. 参考文档</strong></h3><ul>
<li><a href="https://github.com/kubernetes/client-go/tree/master/util/workqueue">client-go WorkQueue 实现</a></li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>ingress-nginx开启旧版本TLS</title>
    <url>/2024/10/16/ingress-nginx%E5%BC%80%E5%90%AF%E6%97%A7%E7%89%88%E6%9C%ACTLS/</url>
    <content><![CDATA[<h2 id="1-创建工作负载"><a href="#1-创建工作负载" class="headerlink" title="1.创建工作负载"></a>1.创建工作负载</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个deployment型的工作负载，端口使用nginx默认的80</span></span><br><span class="line">kubectl create deployment nginx-demo --image=swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/nginx:1.27.0 --port=80</span><br><span class="line"></span><br><span class="line"><span class="comment">#暴露服务端口</span></span><br><span class="line">kubectl expose deployment nginx-demo --port=80 --<span class="built_in">type</span>=ClusterIP</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个ingress规则</span></span><br><span class="line">kubectl create ingress nginx-demo --class=nginx --rule=<span class="string">&quot;test.qihoo.net/*=nginx-demo:80&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取ingress pod ip</span></span><br><span class="line"><span class="comment">#kubectl get pods -o=jsonpath=&#x27;&#123;@&#125;&#x27; | jq</span></span><br><span class="line">kubectl get pod -n ingress-nginx -o jsonpath=<span class="string">&quot;&#123;.items[*][&#x27;.status.hostIP&#x27;]&#125;&quot;</span></span><br><span class="line">11.33.162.177</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置host，保证请求经过ingress，</span></span><br><span class="line"><span class="built_in">cat</span> /etc/hosts</span><br><span class="line">11.33.162.177 test.qihoo.net</span><br></pre></td></tr></table></figure>

<h2 id="2-查看TLS支持版本"><a href="#2-查看TLS支持版本" class="headerlink" title="2.查看TLS支持版本"></a>2.查看TLS支持版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#请求后端服务</span></span><br><span class="line">curl -v http://test.qihoo.net</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用nmap或者openssl请求</span></span><br><span class="line">nmap --script ssl-enum-ciphers -p 443 test.qihoo.net</span><br><span class="line">nmap --script ssl-enum-ciphers -p 443 11.33.162.177</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">openssl s_client -connect test.qihoo.net:443 -tls1_1</span><br><span class="line">openssl s_client -connect test.qihoo.net:443 -tls1_2</span><br><span class="line">openssl s_client -connect test.qihoo.net:443 -tls1_3</span><br></pre></td></tr></table></figure>

<h2 id="3-编辑ingress-nginx-configmap配置"><a href="#3-编辑ingress-nginx-configmap配置" class="headerlink" title="3.编辑ingress-nginx configmap配置"></a>3.编辑ingress-nginx configmap配置</h2><ul>
<li><p>获取ingress-nginx的configmap，编辑配置</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取ingress-nginx 的configmap，编辑配置</span></span><br><span class="line">kubectl get cm -n ingress-nginx</span><br><span class="line">NAME                       DATA   AGE</span><br><span class="line">ingress-nginx-controller   3      47d</span><br><span class="line">kube-root-ca.crt           1      47d</span><br><span class="line">nginx-template             1      47d</span><br><span class="line"></span><br><span class="line">kubectl edit cm ingress-nginx-controller -n ingress-nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#data配置添加以下内容：</span></span><br><span class="line">ssl-ciphers: ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA256:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:@SECLEVEL=0</span><br><span class="line">ssl-protocols: TLSv1 TLSv1.1 TLSv1.2 TLSv1.3</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-再次请求查看支持的TLS版本"><a href="#4-再次请求查看支持的TLS版本" class="headerlink" title="4.再次请求查看支持的TLS版本"></a>4.再次请求查看支持的TLS版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap --script ssl-enum-ciphers -p 443 11.33.162.177</span><br><span class="line">或者</span><br><span class="line">nmap --script ssl-enum-ciphers -p 443 test.qihoo.net</span><br></pre></td></tr></table></figure>

<h2 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5.参考文档"></a>5.参考文档</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/</span><br><span class="line"></span><br><span class="line">https://stackoverflow.com/questions/59371313/kubernetes-nginx-ingress-controller-activate-tlsv1-1</span><br><span class="line"></span><br><span class="line">https://help.aliyun.com/zh/ack/ack-managed-and-ack-dedicated/user-guide/nginx-ingress-faq</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>intresting tools</title>
    <url>/2025/01/20/intresting-tools/</url>
    <content><![CDATA[<h2 id="gdu"><a href="#gdu" class="headerlink" title="gdu"></a>gdu</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/dundee/gdu</span><br></pre></td></tr></table></figure>

<h2 id="chsrc"><a href="#chsrc" class="headerlink" title="chsrc"></a>chsrc</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/RubyMetric/chsrc</span><br></pre></td></tr></table></figure>

<h2 id="lnav"><a href="#lnav" class="headerlink" title="lnav"></a>lnav</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/tstack/lnav</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#用法</span><br><span class="line">lnav /var/log/messages</span><br><span class="line">journalctl -a -o json | lnav</span><br><span class="line"></span><br><span class="line">#如果使用 systemd v236 或更新版本，输出字段可以限制为lnav实际识别的字段，以提高效率：</span><br><span class="line">journalctl -o json --output-fields=MESSAGE,PRIORITY,_PID,SYSLOG_IDENTIFIER,_SYSTEMD_UNIT | lnav</span><br></pre></td></tr></table></figure>

<h2 id="lancet"><a href="#lancet" class="headerlink" title="lancet"></a>lancet</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/duke-git/lancet</span><br></pre></td></tr></table></figure>

<h2 id="oha"><a href="#oha" class="headerlink" title="oha"></a>oha</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/hatoo/oha</span><br></pre></td></tr></table></figure>

<h2 id="icones"><a href="#icones" class="headerlink" title="icones"></a>icones</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/antfu-collective/icones</span><br></pre></td></tr></table></figure>

<h2 id="go2rtc"><a href="#go2rtc" class="headerlink" title="go2rtc"></a>go2rtc</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/AlexxIT/go2rtc</span><br></pre></td></tr></table></figure>

<h2 id="白噪音"><a href="#白噪音" class="headerlink" title="白噪音"></a>白噪音</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://moodist.mvze.net/</span><br></pre></td></tr></table></figure>
<h2 id="freeze-生成代码图片的终端工具"><a href="#freeze-生成代码图片的终端工具" class="headerlink" title="freeze :生成代码图片的终端工具"></a>freeze :生成代码图片的终端工具</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/charmbracelet/freeze</span><br></pre></td></tr></table></figure>

<h2 id="github镜像替换"><a href="#github镜像替换" class="headerlink" title="github镜像替换"></a>github镜像替换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">github镜像网站1：https://2git.xyz</span><br><span class="line"></span><br><span class="line">github镜像网站2：https://lgithub.xyz</span><br><span class="line"></span><br><span class="line">https://github.com/Alvin9999/new-pac</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>ipvsadm与iptables一些命令</title>
    <url>/2025/01/10/ipvsadm%E4%B8%8Eiptables%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="iptables-用法表"><a href="#iptables-用法表" class="headerlink" title="iptables 用法表"></a><strong><code>iptables</code> 用法表</strong></h3><table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>命令</strong></th>
<th><strong>实例</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>查看当前规则</td>
<td><code>iptables -L -n -v</code></td>
<td><code>iptables -L -n -v</code></td>
<td>列出所有链规则，显示计数器、字节数，并以数字形式显示 IP 和端口。</td>
</tr>
<tr>
<td>添加允许规则</td>
<td><code>iptables -A INPUT -p tcp --dport 22 -j ACCEPT</code></td>
<td><code>iptables -A INPUT -p tcp --dport 80 -j ACCEPT</code></td>
<td>允许所有 TCP 流量通过 80 端口进入。</td>
</tr>
<tr>
<td>拒绝特定 IP 流量</td>
<td><code>iptables -A INPUT -s 192.168.1.100 -j DROP</code></td>
<td><code>iptables -A INPUT -s 192.168.1.100 -j DROP</code></td>
<td>阻止来自 192.168.1.100 的所有流量。</td>
</tr>
<tr>
<td>删除规则</td>
<td><code>iptables -D INPUT &lt;rule-number&gt;</code></td>
<td><code>iptables -D INPUT 1</code></td>
<td>删除 INPUT 链中的第 1 条规则。</td>
</tr>
<tr>
<td>清空所有规则</td>
<td><code>iptables -F</code></td>
<td><code>iptables -F</code></td>
<td>清空所有链中的规则。</td>
</tr>
<tr>
<td>保存规则</td>
<td><code>iptables-save &gt; /etc/iptables.rules</code></td>
<td><code>iptables-save &gt; /etc/iptables.rules</code></td>
<td>将当前规则保存到文件。</td>
</tr>
<tr>
<td>恢复规则</td>
<td><code>iptables-restore &lt; /etc/iptables.rules</code></td>
<td><code>iptables-restore &lt; /etc/iptables.rules</code></td>
<td>从文件恢复规则。</td>
</tr>
<tr>
<td>允许特定网段访问</td>
<td><code>iptables -A INPUT -p tcp -s 192.168.1.0/24 --dport 3306 -j ACCEPT</code></td>
<td><code>iptables -A INPUT -p tcp -s 192.168.1.0/24 --dport 3306 -j ACCEPT</code></td>
<td>允许来自 192.168.1.0&#x2F;24 网段的流量访问 3306 端口（MySQL）。</td>
</tr>
<tr>
<td>设置默认策略</td>
<td><code>iptables -P INPUT DROP</code></td>
<td><code>iptables -P INPUT DROP</code></td>
<td>将 INPUT 链的默认策略设置为丢弃所有流量。</td>
</tr>
<tr>
<td>NAT 转发规则</td>
<td><code>iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 192.168.1.10:80</code></td>
<td><code>iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 10.0.0.2:80</code></td>
<td>将所有访问本机 8080 端口的流量转发到 192.168.1.10 的 80 端口。</td>
</tr>
</tbody></table>
<hr>
<h3 id="ipvsadm-用法表"><a href="#ipvsadm-用法表" class="headerlink" title="ipvsadm 用法表"></a><strong><code>ipvsadm</code> 用法表</strong></h3><table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>命令</strong></th>
<th><strong>实例</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>查看当前规则</td>
<td><code>ipvsadm -L -n</code></td>
<td><code>ipvsadm -L -n</code></td>
<td>列出所有虚拟服务和真实服务器的详细信息。</td>
</tr>
<tr>
<td>添加虚拟服务</td>
<td><code>ipvsadm -A -t &lt;VIP&gt;:&lt;PORT&gt; -s &lt;SCHEDULER&gt;</code></td>
<td><code>ipvsadm -A -t 192.168.1.100:80 -s rr</code></td>
<td>添加一个虚拟服务，VIP 为 192.168.1.100，端口 80，调度算法为轮询（<code>rr</code>）。</td>
</tr>
<tr>
<td>添加真实服务器</td>
<td><code>ipvsadm -a -t &lt;VIP&gt;:&lt;PORT&gt; -r &lt;RIP&gt;:&lt;PORT&gt; -m</code></td>
<td><code>ipvsadm -a -t 192.168.1.100:80 -r 192.168.1.101:80 -m</code></td>
<td>为虚拟服务添加真实服务器，RIP 为 192.168.1.101，端口 80，使用 NAT 模式。</td>
</tr>
<tr>
<td>删除虚拟服务</td>
<td><code>ipvsadm -D -t &lt;VIP&gt;:&lt;PORT&gt;</code></td>
<td><code>ipvsadm -D -t 192.168.1.100:80</code></td>
<td>删除 VIP 为 192.168.1.100，端口为 80 的虚拟服务。</td>
</tr>
<tr>
<td>删除真实服务器</td>
<td><code>ipvsadm -d -t &lt;VIP&gt;:&lt;PORT&gt; -r &lt;RIP&gt;:&lt;PORT&gt;</code></td>
<td><code>ipvsadm -d -t 192.168.1.100:80 -r 192.168.1.101:80</code></td>
<td>删除虚拟服务中指定的真实服务器。</td>
</tr>
<tr>
<td>设置连接超时</td>
<td><code>ipvsadm --set &lt;tcp_timeout&gt; &lt;tcpfin_timeout&gt; &lt;udp_timeout&gt;</code></td>
<td><code>ipvsadm --set 900 120 300</code></td>
<td>设置 TCP 连接超时为 900 秒，TCP FIN 等待时间为 120 秒，UDP 超时为 300 秒。</td>
</tr>
<tr>
<td>查看服务统计</td>
<td><code>ipvsadm -L -n --stats</code></td>
<td><code>ipvsadm -L -n --stats</code></td>
<td>显示虚拟服务的统计信息，包括请求数、连接数等。</td>
</tr>
<tr>
<td>保存规则</td>
<td><code>ipvsadm-save &gt; /etc/ipvs.rules</code></td>
<td><code>ipvsadm-save &gt; /etc/ipvs.rules</code></td>
<td>保存当前 IPVS 配置到文件中。</td>
</tr>
<tr>
<td>恢复规则</td>
<td><code>ipvsadm-restore &lt; /etc/ipvs.rules</code></td>
<td><code>ipvsadm-restore &lt; /etc/ipvs.rules</code></td>
<td>从文件中恢复 IPVS 配置。</td>
</tr>
<tr>
<td>清空所有规则</td>
<td><code>ipvsadm -C</code></td>
<td><code>ipvsadm -C</code></td>
<td>清空所有虚拟服务和真实服务器规则。</td>
</tr>
<tr>
<td>DR 模式的真实服务器</td>
<td><code>ipvsadm -a -t &lt;VIP&gt;:&lt;PORT&gt; -r &lt;RIP&gt;:&lt;PORT&gt; -g</code></td>
<td><code>ipvsadm -a -t 192.168.1.100:80 -r 192.168.1.101:80 -g</code></td>
<td>添加一个 DR 模式的真实服务器。</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong><code>iptables</code></strong> 主要用于管理 Linux 防火墙规则，控制网络流量的访问策略。</li>
<li><strong><code>ipvsadm</code></strong> 是 LVS（Linux Virtual Server）组件的用户空间工具，用于配置和管理负载均衡规则。</li>
</ul>
<hr>
<h1 id="🧠-ipvsadm-实战与原理分析文档"><a href="#🧠-ipvsadm-实战与原理分析文档" class="headerlink" title="🧠 ipvsadm 实战与原理分析文档"></a>🧠 <code>ipvsadm</code> 实战与原理分析文档</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><code>ipvsadm</code> 是 <strong>IP Virtual Server (IPVS)</strong> 的用户态管理工具，用于配置 Linux 内核的 L4 负载均衡功能。<br>它属于 <strong>LVS (Linux Virtual Server)</strong> 项目的一部分，通过内核模块 <code>ip_vs</code> 实现高性能 TCP&#x2F;UDP 负载均衡。</p>
<blockquote>
<p>📘 核心点：</p>
<ul>
<li>工作在内核态，性能高于用户态代理（如 Nginx、HAProxy）。</li>
<li>常用于 Kubernetes kube-proxy 的 <code>--proxy-mode=ipvs</code> 模式。</li>
<li>调度算法、转发模式灵活，支持 NAT（Masq）、Direct Routing（DR）、IP Tunneling（TUN）等。</li>
</ul>
</blockquote>
<hr>
<h2 id="二、ipvsadm-L-n-输出解释"><a href="#二、ipvsadm-L-n-输出解释" class="headerlink" title="二、ipvsadm -L -n 输出解释"></a>二、<code>ipvsadm -L -n</code> 输出解释</h2><p>你的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line"><span class="comment">#yum install -y ipvsadm</span></span><br><span class="line">[root@base-001 ~]# ipvsadm -L -n</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  11.0.56.240:18668 rr</span><br><span class="line">TCP  100.10.0.1:443 rr</span><br><span class="line">  -&gt; 11.0.54.202:6443            Masq    1      5          0</span><br><span class="line">  -&gt; 11.0.56.240:6443            Masq    1      3          0</span><br><span class="line">  -&gt; 11.0.61.78:6443             Masq    1      4          0</span><br></pre></td></tr></table></figure>

<h3 id="字段解析："><a href="#字段解析：" class="headerlink" title="字段解析："></a>字段解析：</h3><table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Prot</strong></td>
<td>协议类型（TCP &#x2F; UDP）</td>
</tr>
<tr>
<td><strong>LocalAddress:Port</strong></td>
<td>虚拟服务地址（VIP:Port）——客户端访问的地址</td>
</tr>
<tr>
<td><strong>Scheduler</strong></td>
<td>调度算法（如 <code>rr</code> 表示 Round Robin 轮询）</td>
</tr>
<tr>
<td><strong>Forward</strong></td>
<td>转发模式（见下表）</td>
</tr>
<tr>
<td><strong>Weight</strong></td>
<td>服务器权重，影响调度比例</td>
</tr>
<tr>
<td><strong>ActiveConn</strong></td>
<td>当前活跃连接数（已建立的 TCP 会话）</td>
</tr>
<tr>
<td><strong>InActConn</strong></td>
<td>非活跃连接数（如已关闭或等待关闭的会话）</td>
</tr>
</tbody></table>
<h3 id="常见转发模式说明："><a href="#常见转发模式说明：" class="headerlink" title="常见转发模式说明："></a>常见转发模式说明：</h3><table>
<thead>
<tr>
<th>模式</th>
<th>关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NAT</td>
<td><code>Masq</code></td>
<td>LVS 修改请求包目标地址并转发（最常用，通用）</td>
</tr>
<tr>
<td>DR</td>
<td><code>Route</code></td>
<td>LVS 仅修改 MAC 层，将请求发给真实服务器，响应直返客户端（高性能）</td>
</tr>
<tr>
<td>TUN</td>
<td><code>Tunnel</code></td>
<td>LVS 封装 IPIP 隧道转发请求，响应直返客户端（跨网段场景）</td>
</tr>
</tbody></table>
<blockquote>
<p>示例解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP  100.10.0.1:443 rr</span><br><span class="line">  -&gt; 11.0.54.202:6443 Masq 1 5 0</span><br></pre></td></tr></table></figure>

<p>表示：客户端访问 <code>100.104.0.1:443</code> 时，LVS 会使用 <strong>轮询算法</strong> 将请求转发给三台后端节点：</p>
<ul>
<li>11.0.54.202:6443</li>
<li>11.0.56.240:6443</li>
<li>11.0.61.78:6443<br>转发模式是 <code>Masq</code>（NAT 模式），当前活跃连接分别为 5&#x2F;3&#x2F;4。</li>
</ul>
</blockquote>
<hr>
<h2 id="三、常用命令清单"><a href="#三、常用命令清单" class="headerlink" title="三、常用命令清单"></a>三、常用命令清单</h2><h3 id="1️⃣-查看当前-IPVS-规则"><a href="#1️⃣-查看当前-IPVS-规则" class="headerlink" title="1️⃣ 查看当前 IPVS 规则"></a>1️⃣ 查看当前 IPVS 规则</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm -L -n</span><br></pre></td></tr></table></figure>

<h3 id="2️⃣-按连接统计信息显示"><a href="#2️⃣-按连接统计信息显示" class="headerlink" title="2️⃣ 按连接统计信息显示"></a>2️⃣ 按连接统计信息显示</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm -Ln --stats</span><br></pre></td></tr></table></figure>

<h3 id="3️⃣-按连接数显示详细统计"><a href="#3️⃣-按连接数显示详细统计" class="headerlink" title="3️⃣ 按连接数显示详细统计"></a>3️⃣ 按连接数显示详细统计</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm -Ln --rate</span><br></pre></td></tr></table></figure>

<h3 id="4️⃣-添加一个虚拟服务"><a href="#4️⃣-添加一个虚拟服务" class="headerlink" title="4️⃣ 添加一个虚拟服务"></a>4️⃣ 添加一个虚拟服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm -A -t 192.168.0.1:80 -s rr</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-A</code>: 添加虚拟服务（Virtual Service）</li>
<li><code>-t</code>: TCP 服务</li>
<li><code>-s</code>: 指定调度算法（<code>rr</code>, <code>wrr</code>, <code>lc</code>, <code>wlc</code>, <code>lblc</code>, <code>lblcr</code>, <code>sh</code>, <code>dh</code> 等）</li>
</ul>
<h3 id="5️⃣-添加真实服务器（Real-Server）"><a href="#5️⃣-添加真实服务器（Real-Server）" class="headerlink" title="5️⃣ 添加真实服务器（Real Server）"></a>5️⃣ 添加真实服务器（Real Server）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm -a -t 192.168.0.1:80 -r 10.0.0.2:80 -m -w 2</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-a</code>: 添加 Real Server</li>
<li><code>-r</code>: 后端真实服务器 IP:Port</li>
<li><code>-m</code>: 使用 NAT（Masq）模式</li>
<li><code>-w</code>: 权重设置</li>
</ul>
<h3 id="6️⃣-删除虚拟服务或-Real-Server"><a href="#6️⃣-删除虚拟服务或-Real-Server" class="headerlink" title="6️⃣ 删除虚拟服务或 Real Server"></a>6️⃣ 删除虚拟服务或 Real Server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm -D -t 192.168.0.1:80</span><br><span class="line">ipvsadm -d -t 192.168.0.1:80 -r 10.0.0.2:80</span><br></pre></td></tr></table></figure>

<h3 id="7️⃣-保存-恢复配置"><a href="#7️⃣-保存-恢复配置" class="headerlink" title="7️⃣ 保存 &#x2F; 恢复配置"></a>7️⃣ 保存 &#x2F; 恢复配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm-save &gt; /etc/sysconfig/ipvsadm</span><br><span class="line">ipvsadm-restore &lt; /etc/sysconfig/ipvsadm</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、典型应用场景"><a href="#四、典型应用场景" class="headerlink" title="四、典型应用场景"></a>四、典型应用场景</h2><table>
<thead>
<tr>
<th>场景</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Kubernetes kube-proxy (ipvs 模式)</strong></td>
<td>使用 <code>ipvsadm</code> 进行服务负载均衡，性能优于 iptables</td>
</tr>
<tr>
<td><strong>高性能四层负载均衡</strong></td>
<td>在大规模集群中作为 L4 负载均衡器 (TCP&#x2F;UDP)</td>
</tr>
<tr>
<td><strong>HA 集群前端负载</strong></td>
<td>搭配 Keepalived 实现 VIP 漂移（高可用 LVS）</td>
</tr>
<tr>
<td><strong>监控与调试</strong></td>
<td>排查连接调度、后端健康检查状态</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、实战建议与技巧"><a href="#五、实战建议与技巧" class="headerlink" title="五、实战建议与技巧"></a>五、实战建议与技巧</h2><ul>
<li><p>🔹 <strong>查看当前连接情况</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch -n1 <span class="string">&#x27;ipvsadm -Ln --rate&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>🔹 <strong>快速找出 VIP 所属 real servers</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm -Ln | grep -A3 <span class="string">&#x27;100.104.0.1:443&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>🔹 <strong>配合 Kubernetes 调试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get svc -A</span><br><span class="line">ipvsadm -Ln | grep &lt;ClusterIP&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>🔹 <strong>清空所有 IPVS 规则</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipvsadm -C</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="六、总结与思考"><a href="#六、总结与思考" class="headerlink" title="六、总结与思考"></a>六、总结与思考</h2><table>
<thead>
<tr>
<th>维度</th>
<th>LVS &#x2F; IPVS</th>
</tr>
</thead>
<tbody><tr>
<td>性能</td>
<td>内核级转发，百万级 QPS</td>
</tr>
<tr>
<td>场景</td>
<td>Kubernetes、LB、网关</td>
</tr>
<tr>
<td>对比</td>
<td>优于 iptables，但仅支持 L4</td>
</tr>
<tr>
<td>工具</td>
<td>ipvsadm（手工操作） &#x2F; kube-proxy（自动管理）</td>
</tr>
<tr>
<td>建议</td>
<td>配合 <code>keepalived</code> 使用，实现 HA</td>
</tr>
</tbody></table>
<hr>
<h2 id="📄-附录：调度算法简表"><a href="#📄-附录：调度算法简表" class="headerlink" title="📄 附录：调度算法简表"></a>📄 附录：调度算法简表</h2><table>
<thead>
<tr>
<th>算法</th>
<th>名称</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><code>rr</code></td>
<td>Round Robin</td>
<td>平均分配</td>
</tr>
<tr>
<td><code>wrr</code></td>
<td>Weighted RR</td>
<td>按权重分配</td>
</tr>
<tr>
<td><code>lc</code></td>
<td>Least Connection</td>
<td>动态负载均衡</td>
</tr>
<tr>
<td><code>wlc</code></td>
<td>Weighted LC</td>
<td>按权重加权最小连接</td>
</tr>
<tr>
<td><code>lblc</code></td>
<td>Locality-Based LC</td>
<td>会话本地性</td>
</tr>
<tr>
<td><code>lblcr</code></td>
<td>Locality-Based Replicated LC</td>
<td>会话本地性 + 冗余</td>
</tr>
<tr>
<td><code>sh</code></td>
<td>Source Hashing</td>
<td>基于源 IP 哈希</td>
</tr>
<tr>
<td><code>dh</code></td>
<td>Destination Hashing</td>
<td>基于目的 IP 哈希</td>
</tr>
</tbody></table>
<hr>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>jq常见用法</title>
    <url>/2024/09/29/jq%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><code>jq</code> 是一个非常强大的命令行 JSON 处理工具，它可以帮助您快速地查询、过滤、映射和转换 JSON 数据。</p>
<ol>
<li><p><strong>查看特定字段</strong>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;.fieldName&#x27;</span><br></pre></td></tr></table></figure>
<p> 替换 <code>fieldName</code> 为您想要查询的字段名。</p>
</li>
<li><p><strong>查看数组中的特定元素</strong>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;.fieldName[0]&#x27;  # 获取数组的第一个元素</span><br><span class="line">jq &#x27;.fieldName[-1]&#x27; # 获取数组的最后一个元素</span><br><span class="line">jq &#x27;.fieldName[]&#x27;   # 遍历数组的所有元素</span><br></pre></td></tr></table></figure>
<p> 数组索引从 0 开始。</p>
</li>
<li><p><strong>过滤数组元素</strong>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;.fieldName[] | select(.condition)&#x27;</span><br></pre></td></tr></table></figure>
<p> 替换 <code>condition</code> 为过滤条件，例如 <code>.name == &quot;desiredName&quot;</code>。</p>
</li>
<li><p><strong>获取嵌套字段</strong>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;.parentFieldName[].childFieldName&#x27;</span><br></pre></td></tr></table></figure>
<p> 如果 <code>parentFieldName</code> 是一个数组，这将获取每个元素的 <code>childFieldName</code> 字段。</p>
</li>
<li><p><strong>获取多个字段</strong>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;&#123;field1, field2&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p> 这将创建一个包含 <code>field1</code> 和 <code>field2</code> 的对象。</p>
</li>
<li><p><strong>提取键值对</strong>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;to_entries[] | &#123;key, value&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p> 将 JSON 对象转换为键值对数组。</p>
</li>
<li><p><strong>合并多个字段</strong>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;.fieldName as $item ireduce . as $acc + &#123;($item): $item&#125; &#x27;</span><br></pre></td></tr></table></figure>
<p> 这将合并多个字段到一个对象中。</p>
</li>
<li><p><strong>格式化输出</strong>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;.&#x27;  # 默认输出</span><br><span class="line">jq &#x27;.pretty&#x27;  # 格式化输出</span><br><span class="line">jq &#x27;.compact&#x27;  # 压缩输出</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>条件表达式</strong>：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;if .condition then &quot;true&quot; else &quot;false&quot; end&#x27;</span><br></pre></td></tr></table></figure>
<p> 使用条件表达式来输出不同的结果。</p>
</li>
<li><p><strong>数组操作</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;.arrayField + [newItem]&#x27;  # 添加新元素到数组</span><br><span class="line">jq &#x27;.arrayField - [index]&#x27;    # 从数组中删除元素</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>统计数组元素数量</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;.arrayField | length&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>排序数组</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;.arrayField | sort&#x27;  # 默认升序排序</span><br><span class="line">jq &#x27;.arrayField | sort_by(-&amp;value)&#x27;  # 降序排序</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>搜索和替换</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;.arrayField[] | select(.field == &quot;value&quot;) | .field = &quot;newValue&quot;&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从 JSON 字符串中解析</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;.fromJSON&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将 JSON 对象转换为数组</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jq &#x27;to_entries[] | .value&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用管道</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pods --output=json | jq &#x27;.items[] | .metadata.name&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>实践</strong>：</p>
<pre><code>直接输出为完整的 JSON 格式
jq &#39;.[] | &#123;address: .address, weight: .weight&#125;&#39; &lt;&lt;&lt; &#39;[&#123;&quot;protocol_port&quot;:80,&quot;address&quot;:&quot;10.xxx&quot;,&quot;port_id&quot;:&quot;&quot;,&quot;weight&quot;:1&#125;,&#123;&quot;protocol_port&quot;:80,&quot;address&quot;:&quot;10.xxx&quot;,&quot;port_id&quot;:&quot;&quot;,&quot;weight&quot;:1&#125;]&#39;
#输出为表格格式：
jq -r &#39;.[] | [.address, .weight] | @tsv&#39; &lt;&lt;&lt; &#39;[&#123;&quot;protocol_port&quot;:80,&quot;address&quot;:&quot;10.xxx&quot;,&quot;port_id&quot;:&quot;&quot;,&quot;weight&quot;:1&#125;,&#123;&quot;protocol_port&quot;:80,&quot;address&quot;:&quot;10.xxx&quot;,&quot;port_id&quot;:&quot;&quot;,&quot;weight&quot;:1&#125;]&#39; | column -t
</code></pre>
<p>这将获取所有 pod 的名称。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s RBAC解释</title>
    <url>/2024/09/29/k8s-RBAC%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h3 id="抽象概括"><a href="#抽象概括" class="headerlink" title="抽象概括"></a>抽象概括</h3><ul>
<li><strong>谁</strong> 是否可以对  <strong>什么东西</strong> 进行  <strong>怎么样</strong> 的访问操作。</li>
</ul>
<h3 id="RBAC模型"><a href="#RBAC模型" class="headerlink" title="RBAC模型"></a>RBAC模型</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">User（用户）：每个用户都有唯一的UID识别，并被授予不同的角色</span><br><span class="line">Role（角色）：不同角色具有不同的权限</span><br><span class="line">Permission（权限）：访问权限</span><br><span class="line">用户-角色映射：用户和角色之间的映射关系</span><br><span class="line">角色-权限映射：角色和权限之间的映射</span><br></pre></td></tr></table></figure>

<h3 id="RBAC-API-对象："><a href="#RBAC-API-对象：" class="headerlink" title="RBAC API 对象："></a>RBAC API 对象：</h3><ul>
<li><em>Role</em></li>
<li><em>ClusterRole</em></li>
<li><em>RoleBinding</em></li>
<li><em>ClusterRoleBinding</em>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/shispring/shispring.github.io/refs/heads/main/2024/08/28/Anolis-OS-8%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E9%9B%86/91.jpg"></p>
<p><img src="https://raw.githubusercontent.com/shispring/shispring.github.io/refs/heads/main/2024/08/28/Anolis-OS-8%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E9%9B%86/05.jpg"></p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s api server接口交互</title>
    <url>/2024/09/29/k8s-api-server%E6%8E%A5%E5%8F%A3%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h3 id="apiserver"><a href="#apiserver" class="headerlink" title="apiserver"></a>apiserver</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://wghdr.top/?p=335</span><br></pre></td></tr></table></figure>

<h3 id="查看api方法："><a href="#查看api方法：" class="headerlink" title="查看api方法："></a>查看api方法：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get --raw /</span><br><span class="line">kubectl get --raw /apis/apps/v1 | jq .resources[].name</span><br><span class="line"></span><br><span class="line">或者开启apiserver</span><br><span class="line">kubectl proxy --port=8080</span><br><span class="line"></span><br><span class="line"><span class="comment">#默认资源</span></span><br><span class="line">curl 127.0.0.1:8000/apis/v1</span><br><span class="line">curl http://127.0.0.1:8080/apis/batch/v1</span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展资源</span></span><br><span class="line">curl 127.0.0.1:8001/apis/apps/v1</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过kubectl获取url请求</span></span><br><span class="line">kubectl get pod &#123;podName&#125; -v=9</span><br><span class="line"></span><br><span class="line"><span class="comment">#短连接</span></span><br><span class="line">- kubectl get xxx</span><br><span class="line"><span class="comment">#长连接</span></span><br><span class="line">- watch接口是对list接口的一种改进，在调用watch接口后，首先会一次性返回list的数据，同时会保持会话连接，后续的接口对象的curd，都会产生事件由apiserver将变更数据推送给调用端，调用端接收数据后，再</span><br><span class="line">更新初始接收到的list的全量数据以及其他操作</span><br><span class="line"><span class="comment">#client-go informer机制</span></span><br><span class="line">- watch依然比较麻烦，毕竟list获取的数据以及后续watch到的数据，需要调用端在内部处理和更新缓存。</span><br></pre></td></tr></table></figure>

<h3 id="api结构及原理"><a href="#api结构及原理" class="headerlink" title="api结构及原理"></a>api结构及原理</h3><p><img src="https://github.com/shispring/shispring.github.io/blob/main/2024/08/28/Anolis-OS-8%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E9%9B%86/55.jpg?raw=true"><br><img src="https://github.com/shispring/shispring.github.io/blob/main/2024/08/28/Anolis-OS-8%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E9%9B%86/87.jpg?raw=true"></p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>k8s apiserver 客户端认证方式</title>
    <url>/2024/09/30/k8s-apiserver-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>apiserver有三种级别的客户端认证方式<br>1、HTTPS证书认证：基于CA根证书签名的双向数字证书认证方式<br>2、HTTP Token认证：通过一个Token来识别合法用户<br>3、HTTP Base认证：通过用户名+密码的认证方式  </p>
<h1 id="HTTP-Token认证：通过一个Token来识别合法用户"><a href="#HTTP-Token认证：通过一个Token来识别合法用户" class="headerlink" title="HTTP Token认证：通过一个Token来识别合法用户"></a>HTTP Token认证：通过一个Token来识别合法用户</h1><p>1、创建可以访问api的用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建账号</span><br><span class="line">kubectl create serviceaccount curl-admin -n kube-system</span><br><span class="line"></span><br><span class="line"># 角色绑定</span><br><span class="line">kubectl create clusterrolebinding curl-admin --clusterrole=cluster-admin --serviceaccount=kube-system:curl-admin</span><br><span class="line"></span><br><span class="line"># 创建secret</span><br><span class="line">在 Kubernetes v1.25 及以后的版本中，创建 ServiceAccount 时不会自动生成关联的 Secret。你需要手动创建一个 Secret 并将其与 ServiceAccount 关联。</span><br><span class="line"></span><br><span class="line">kubectl apply -f - &lt;&lt;EOF</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: curl-admin</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io/service-account.name: &quot;curl-admin&quot;</span><br><span class="line">type: kubernetes.io/service-account-token</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看TOKEN</span><br><span class="line">kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk &#x27;/curl-admin/&#123;print $1&#125;&#x27;)</span><br></pre></td></tr></table></figure>

<p>2、设置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、获取TOKEN信息</span><br><span class="line"># kubectl describe secrets $(kubectl get secrets -n kube-system |grep admin |cut -f1 -d &#x27; &#x27;) -n kube-system |grep -E &#x27;^token&#x27; |cut -f2 -d&#x27;:&#x27;|tr -d &#x27;  &#x27;|tr -d &#x27; &#x27;</span><br><span class="line"></span><br><span class="line">2、定义TOKEN环境变量</span><br><span class="line"># TOKEN=$(kubectl describe secrets $(kubectl get secrets -n kube-system |grep admin |cut -f1 -d &#x27; &#x27;) -n kube-system |grep -E &#x27;^token&#x27; |cut -f2 -d&#x27;:&#x27;|tr -d &#x27;  &#x27;|tr -d &#x27; &#x27;)</span><br><span class="line"></span><br><span class="line">3、获取api-server地址，注意过滤集群信息</span><br><span class="line"># 单个集群</span><br><span class="line">kubectl config view |grep server|cut -f 2- -d &quot;:&quot; | tr -d &quot; &quot;</span><br><span class="line"></span><br><span class="line">#多个集群时</span><br><span class="line"># kubectl config view -o jsonpath=&#x27;&#123;&quot;Cluster name\tServer\n&quot;&#125;&#123;range .clusters[*]&#125;&#123;.name&#125;&#123;&quot;\t&quot;&#125;&#123;.cluster.server&#125;&#123;&quot;\n&quot;&#125;&#123;end&#125;&#x27;</span><br><span class="line"></span><br><span class="line"># kubectl config view -o jsonpath=&#x27;&#123;range .clusters[*]&#125;&#123;.name&#125;&#123;&quot;\t&quot;&#125;&#123;.cluster.server&#125;&#123;&quot;\n&quot;&#125;&#123;end&#125;&#x27; | grep &quot;test-cluster-xxx&quot; | awk &#x27;&#123;print $2&#125;&#x27;</span><br><span class="line"></span><br><span class="line">4、设置api-server地址环境变量</span><br><span class="line">#单个集群</span><br><span class="line"># APISERVER=$(kubectl config view |grep server|cut -f 2- -d &quot;:&quot; | tr -d &quot; &quot;)</span><br><span class="line"></span><br><span class="line">#多个集群</span><br><span class="line"># APISERVER=$(kubectl config view -o jsonpath=&#x27;&#123;range .clusters[*]&#125;&#123;.name&#125;&#123;&quot;\t&quot;&#125;&#123;.cluster.server&#125;&#123;&quot;\n&quot;&#125;&#123;end&#125;&#x27; | grep &quot;jpshi&quot; | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、通过TOKEN方式访问api-server</p>
<ul>
<li>pod外访问<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Authorization: Bearer $TOKEN&quot; $APISERVER/api  --insecure</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;APIVersions&quot;,</span><br><span class="line">  &quot;versions&quot;: [</span><br><span class="line">    &quot;v1&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;serverAddressByClientCIDRs&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;clientCIDR&quot;: &quot;0.0.0.0/0&quot;,</span><br><span class="line">      &quot;serverAddress&quot;: &quot;192.168.0.130:6443&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Authorization: Bearer $TOKEN&quot; $APISERVER  --insecure</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;paths&quot;: [</span><br><span class="line">    &quot;/api&quot;,</span><br><span class="line">    &quot;/api/v1&quot;,</span><br><span class="line">    &quot;/apis&quot;,</span><br><span class="line">    &quot;/apis/&quot;,</span><br><span class="line">    &quot;/apis/admissionregistration.k8s.io&quot;,</span><br><span class="line">    &quot;/apis/admissionregistration.k8s.io/v1beta1&quot;,</span><br><span class="line">    &quot;/apis/apiextensions.k8s.io&quot;,</span><br><span class="line">    &quot;/apis/apiextensions.k8s.io/v1beta1&quot;,</span><br><span class="line"> 	......</span><br><span class="line">    &quot;/version&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>pod内访问<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)</span><br><span class="line">CACERT=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</span><br><span class="line">curl --cacert $CACERT --header &quot;Authorization: Bearer $TOKEN&quot;  https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT/api</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;APIVersions&quot;,</span><br><span class="line">  &quot;versions&quot;: [</span><br><span class="line">    &quot;v1&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;serverAddressByClientCIDRs&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;clientCIDR&quot;: &quot;0.0.0.0/0&quot;,</span><br><span class="line">      &quot;serverAddress&quot;: &quot;10.0.1.149:443&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>k8s cordon drain taint</title>
    <url>/2024/09/04/k8s-cordon-drain-taint/</url>
    <content><![CDATA[<h3 id="cordon-标记节点不可调度"><a href="#cordon-标记节点不可调度" class="headerlink" title="cordon: 标记节点不可调度"></a>cordon: 标记节点不可调度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 如果一个node被标记为cordon，新创建的pod不会被调度到此node上，已经调度上去的不会被移走。</span><br></pre></td></tr></table></figure>
<h3 id="drain-驱逐节点上的pod"><a href="#drain-驱逐节点上的pod" class="headerlink" title="drain: 驱逐节点上的pod"></a>drain: 驱逐节点上的pod</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- drain包含两种状态：cordon不可被调度，evicted驱逐当前节点所以pod</span><br></pre></td></tr></table></figure>
<h3 id="taint-设置节点的污点"><a href="#taint-设置节点的污点" class="headerlink" title="taint:设置节点的污点"></a>taint:设置节点的污点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、污点的格式: key=value:&lt;effect&gt;  或  key:&lt;effect&gt;</span><br><span class="line">2、key和value是污点的标签，可以自行拟定</span><br><span class="line">3、effect描述污点的作用,effect支持如下三个选项:</span><br><span class="line">  - PreferNoSchedule：尽量避免把pod调度到具有该污点的node上，除非没有其他节点可调度</span><br><span class="line">  - NoSchedule:：不会把pod调度到具有该污点的node上，但不会影响当前node已存在的pod</span><br><span class="line">  - NoExecute：不会把pod调度到具有该污点的node上，同时还会驱逐node上已存在的pod</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Toleration Key</th>
<th>Effect</th>
<th>作用含义</th>
</tr>
</thead>
<tbody><tr>
<td><em>(空 key, 仅 op&#x3D;Exists)</em></td>
<td>—</td>
<td>容忍任意污点（这是一个通配的容忍度）</td>
</tr>
<tr>
<td>node.kubernetes.io&#x2F;disk-pressure</td>
<td>NoSchedule</td>
<td>允许 Pod 调度到磁盘压力大的节点</td>
</tr>
<tr>
<td>node.kubernetes.io&#x2F;memory-pressure</td>
<td>NoSchedule</td>
<td>允许 Pod 调度到内存压力大的节点</td>
</tr>
<tr>
<td>node.kubernetes.io&#x2F;network-unavailable</td>
<td>NoSchedule</td>
<td>允许 Pod 调度到网络不可用的节点（常见于新节点）</td>
</tr>
<tr>
<td>node.kubernetes.io&#x2F;not-ready</td>
<td>NoExecute</td>
<td>允许 Pod 在节点未就绪时继续运行，不会立刻驱逐</td>
</tr>
<tr>
<td>node.kubernetes.io&#x2F;pid-pressure</td>
<td>NoSchedule</td>
<td>允许 Pod 调度到进程数（PID）压力大的节点</td>
</tr>
<tr>
<td>node.kubernetes.io&#x2F;unreachable</td>
<td>NoExecute</td>
<td>允许 Pod 在节点不可达（网络断开等）时继续存活</td>
</tr>
<tr>
<td>node.kubernetes.io&#x2F;unschedulable</td>
<td>NoSchedule</td>
<td>允许 Pod 调度到被标记为不可调度的节点（比如 cordon 状态）</td>
</tr>
</tbody></table>
<h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置node不可调度</span></span><br><span class="line">kubectl cordon &lt;NODE&gt;</span><br><span class="line"><span class="comment">#验证</span></span><br><span class="line">kubectl  describe node &lt;NODE&gt; | grep Unschedulable</span><br><span class="line"></span><br><span class="line"><span class="comment">#drain停机维护</span></span><br><span class="line">kubectl cordon &lt;NODE&gt;</span><br><span class="line">kubectl drain &lt;NODE&gt; --ignore-daemonsets --delete-local-data --force --grace-period=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kubectl drain node-1 --grace-period=60 --<span class="built_in">timeout</span>=10m --ignore-daemonsets --delete-local-data</span><br><span class="line">参数说明：</span><br><span class="line">--grace-period=60：每个 Pod 有 60 秒的优雅关闭时间。</span><br><span class="line">--<span class="built_in">timeout</span>=10m：整个驱逐操作最多等待 10 分钟。</span><br><span class="line">--ignore-daemonsets：忽略 DaemonSet 管理的 Pod，不会尝试驱逐它们。</span><br><span class="line">--delete-local-data：强制删除使用本地存储的数据，即使 Pod 使用了本地卷。</span><br><span class="line"></span><br><span class="line"><span class="comment">#uncordon恢复节点可调度</span></span><br><span class="line">kubectl uncordon &lt;NODE&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置污点,指定标签为dedicated=special-user,策略为NoSchedule</span></span><br><span class="line">kubectl taint nodes &lt;NODE&gt; dedicated=special-user:NoSchedule</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置成无value</span></span><br><span class="line">kubectl taint nodes &lt;NODE&gt; bar:NoSchedule</span><br><span class="line"></span><br><span class="line"><span class="comment">#移除key为dedicated的NoSchedule污点</span></span><br><span class="line">kubectl taint nodes &lt;NODE&gt; dedicated:NoSchedule-</span><br><span class="line"><span class="comment">#移除key为dedicated的所有污点</span></span><br><span class="line">kubectl taint nodes &lt;NODE&gt; dedicated-</span><br><span class="line"><span class="comment">#设置&lt;NODE&gt;污点,策略为NoExecute</span></span><br><span class="line">kubectl taint nodes &lt;NODE&gt; dedicated=special-user:NoExecute</span><br><span class="line"><span class="comment">#注意一点,不要混淆节点不可调度,节点上存在污点节点仍然是可以调度的,只要pod中存在容忍即可调度到&lt;NODE&gt;节点</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>k8s event controller工作原理</title>
    <url>/2024/12/08/k8s-event-controller%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://silenceper.com/blog/202003/kubernetes-event/">https://silenceper.com/blog/202003/kubernetes-event/</a></p>
</blockquote>
<p>在 Kubernetes 中，Event Controller 是集群内部的一部分，用于管理事件资源（Event 对象）。它的主要职责是监听、存储和处理集群中的事件，这些事件是 Kubernetes 中其他组件和用户操作的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get events --sort-by=<span class="string">&#x27;&#123;.metadata.creationTimestamp&#125;&#x27;</span> -n default</span><br><span class="line">kubectl get events --sort-by=<span class="string">&#x27;&#123;.metadata.creationTimestamp&#125;&#x27;</span> -o jsonpath=<span class="string">&#x27;&#123;range .items[*]&#125;&#123;.metadata.name&#125;&#123;&quot;\n&quot;&#125;&#123;end&#125;&#x27;</span> -n default</span><br><span class="line">kubectl get events xxxx.182de6068e2be852 -n default -o yaml </span><br></pre></td></tr></table></figure>

<ol>
<li>Event 的定义与来源</li>
</ol>
<p>Event 是 Kubernetes 中的一个核心资源，表示集群中发生的一个操作或状态变更。每个 Event 都是一个短期的记录，包含以下信息：<br>•涉及的对象（involvedObject）：与事件相关的资源（Pod、Node、Deployment 等）。<br>•类型：事件类型是 Normal（正常）或 Warning（警告）。<br>•原因：事件的简短描述（如 BackOff、Scheduled）。<br>•消息：事件的详细信息。<br>•时间戳：事件发生的时间。<br>•事件源：触发事件的组件（如 kubelet、scheduler、controller-manager 等）。</p>
<ol start="2">
<li>Event Controller 的作用</li>
</ol>
<p>Event Controller 的核心功能是：<br>•监听事件源：通过 API Server 监控事件的发生（使用 Kubernetes 的 Watch 机制）。<br>•记录事件：将事件持久化存储到 etcd 中。<br>•清理旧事件：定期清理超出 TTL（默认 1 小时）的事件，确保事件系统不会无限制地占用资源。</p>
<p>事件驱动机制的工作原理</p>
<p>Kubernetes 是基于 事件驱动模型 的，这体现在以下几个方面：</p>
<ol>
<li>事件的传播与通知</li>
</ol>
<p>事件是通过 Watch&#x2F;Informer 机制传播的：<br>•组件监听 API Server：Kubernetes 中的 Controller（如 Deployment Controller、Node Controller）通过 Watch 机制实时监听资源对象的变更。<br>•产生事件：当资源对象状态发生变化时，组件会向 API Server 报告事件。例如，Pod 被调度到一个节点后，Scheduler 会产生一个事件 Scheduled。<br>•事件流转：事件被写入 API Server，Event Controller 和其他监听组件（如自定义 Controller）会收到通知。</p>
<ol start="2">
<li>事件类型<br>•Normal 事件：表示系统的正常行为，例如 Pod 被成功调度。<br>•Warning 事件：表示可能的异常情况，例如 Pod 无法拉取镜像或节点不可用。</li>
</ol>
<p>Event Controller 对 CRD 自定义 Controller 的影响</p>
<ol>
<li>事件触发 CRD Controller 的动作<br>•Informer 的事件驱动机制：CRD 自定义 Controller 使用 Kubernetes 提供的 Informer 来监听 CRD 对象的创建、更新和删除事件。Informer 会从 API Server 获取事件并调用相应的处理逻辑。<br>•队列机制：事件触发后，CRD Controller 通常将事件加入队列（如 workqueue），并异步执行对应的操作。</li>
</ol>
<p>例如：<br>•用户创建一个自定义资源（CRD 实例）。<br>•Informer 监听到该事件，并将事件加入工作队列。<br>•自定义 Controller 的 Reconcile Loop 被触发，执行相应的逻辑。</p>
<ol start="2">
<li><p>使用事件进行调试与可观察性<br>•CRD 自定义 Controller 通常会创建 Event 对象记录操作结果（如更新资源状态）。<br>•这些事件便于管理员调试和观察 CRD Controller 的行为。</p>
</li>
<li><p>事件的级联影响<br>•自定义 Controller 的行为可能引发新的事件。例如，Controller 更新一个 Pod 的 Label，会触发 Deployment Controller 产生新事件 Updated.</p>
</li>
</ol>
<p>事件对系统整体的影响<br>1.调度与控制的基础：<br>•Scheduler 监听 Pod 的创建事件来决定调度策略。<br>•Deployment Controller 监听 Pod 的状态事件来决定扩容或重建策略。</p>
<p>2.系统状态的监控与追踪：<br>•事件为集群提供了一个透明的状态变更历史。<br>•运维人员可以通过 kubectl describe 查看事件记录。</p>
<p>3.问题的根因分析：<br>•事件链可以帮助快速定位问题。例如，Pod 创建失败的原因通常可以通过查看相关的事件找到。</p>
<p>实践中如何生成和使用事件<br>1.生成自定义事件<br>自定义 Controller 可以通过 Kubernetes 提供的 EventRecorder 接口生成事件：</p>
<p>eventRecorder.Event(resource, “Warning”, “CustomReason”, “Custom message”)</p>
<p>2.监控事件<br>通过 kubectl 查看事件：</p>
<p>kubectl get events –all-namespaces</p>
<p>3.分析与排查问题</p>
<p>•Warning 事件通常是问题的直接表现。<br>•结合事件时间顺序，可以追踪操作的完整链路。</p>
<p>通过事件驱动机制，Kubernetes 提供了强大的异步处理能力和可观察性，能够支撑复杂的分布式系统操作逻辑。自定义的 CRD Controller 充分利用这一机制，可以实现动态、灵活的资源管理和协调。</p>
]]></content>
  </entry>
  <entry>
    <title>k8s node not ready 排查</title>
    <url>/2024/09/26/k8s-node-not-ready-%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<h3 id="1-节点-NotReady-的原因"><a href="#1-节点-NotReady-的原因" class="headerlink" title="1. 节点 NotReady 的原因"></a>1. 节点 NotReady 的原因</h3><ol>
<li><p><strong>Kubelet 失败</strong>：</p>
<ul>
<li>Kubelet 进程未启动或崩溃，导致节点无法向 API 服务器报告其状态。</li>
</ul>
</li>
<li><p><strong>网络问题</strong>：</p>
<ul>
<li>节点与控制平面之间的网络连接不畅，无法与 API 服务器通信。</li>
</ul>
</li>
<li><p><strong>资源不足</strong>：</p>
<ul>
<li>节点上的 CPU、内存、磁盘等资源耗尽，导致无法正常调度 Pod 或处理请求。</li>
</ul>
</li>
<li><p><strong>Docker 或容器运行时问题</strong>：</p>
<ul>
<li>容器运行时（如 Docker、containerd）故障，无法启动或管理 Pod。</li>
</ul>
</li>
<li><p><strong>节点条件不满足</strong>：</p>
<ul>
<li>节点可能因为 DiskPressure、MemoryPressure 或 PIDPressure 等条件被标记为 NotReady。</li>
</ul>
</li>
<li><p><strong>防火墙或安全组配置</strong>：</p>
<ul>
<li>网络策略、iptables 或云平台的安全组阻止了与控制平面的通信。</li>
</ul>
</li>
</ol>
<h3 id="2-补救措施"><a href="#2-补救措施" class="headerlink" title="2. 补救措施"></a>2. 补救措施</h3><p>如果节点长时间处于 NotReady 状态，可以采取以下措施：</p>
<ol>
<li><p><strong>检查 Kubelet 日志</strong>：</p>
<ul>
<li>查看 Kubelet 日志，了解其是否正常启动，是否有错误信息。</li>
<li>使用命令：<code>journalctl -u kubelet</code> 或 <code>kubectl logs -n kube-system &lt;kubelet-pod-name&gt;</code>。</li>
<li>Kubelet 通常是以 daemonset 的形式运行在每个节点上。要查看集群中 Kubelet Pod 的列表，可以使用以下命令：kubectl get pods -n kube-system -l k8s-app&#x3D;kubelet。</li>
</ul>
</li>
<li><p><strong>检查资源状态</strong>：</p>
<ul>
<li>使用命令 <code>kubectl describe node &lt;node-name&gt;</code> 查看节点状态和条件，确定是否由于资源压力导致 NotReady。</li>
</ul>
</li>
<li><p><strong>重启 Kubelet</strong>：</p>
<ul>
<li>如果 Kubelet 出现问题，尝试重启该服务：<code>sudo systemctl restart kubelet</code>。</li>
</ul>
</li>
<li><p><strong>检查网络连接</strong>：</p>
<ul>
<li>确认节点与 API 服务器的网络连接正常，使用 <code>ping</code> 或 <code>curl</code> 测试连接。</li>
</ul>
</li>
<li><p><strong>清理资源</strong>：</p>
<ul>
<li>如果是资源不足，考虑清理不必要的 Pod，或增加节点的资源（CPU、内存）。</li>
</ul>
</li>
<li><p><strong>检查防火墙和安全组</strong>：</p>
<ul>
<li>确保防火墙规则或安全组配置允许节点与控制平面之间的通信。</li>
</ul>
</li>
<li><p><strong>驱动更新或重新安装</strong>：</p>
<ul>
<li>检查 Docker 或容器运行时的版本和配置，如果存在问题，考虑更新或重新安装。</li>
</ul>
</li>
<li><p><strong>使用 cordon 和 drain</strong>：</p>
<ul>
<li>如果节点不能恢复，使用 <code>kubectl cordon &lt;node-name&gt;</code> 阻止新的 Pod 调度到该节点，使用 <code>kubectl drain &lt;node-name&gt;</code> 将现有 Pod 移走，进行故障排查或维护。</li>
<li>cordon命令目的：将节点标记为不可调度，防止新的 Pod 被调度到该节点上。</li>
<li>drain命令目的：迁移节点上的所有 Pod，除了 DaemonSet 管理的 Pod。kubectl drain <node-name> –ignore-daemonsets –delete-emptydir-data</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>节点状态为 NotReady 的原因可能涉及 Kubelet、资源、网络等多方面的问题。通过检查日志、资源状态和网络连接等方式，可以快速定位问题并采取相应的补救措施，确保集群的健康和可用性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get ds -n kube-system</span><br><span class="line">kubectl get pods -n kube-system -l k8s-app=kubelet</span><br><span class="line"></span><br><span class="line">kubectl describe node &lt;node-name&gt;  -n kube-system | grep -A 10 Conditions</span><br><span class="line">kubectl describe node &lt;node-name&gt;  -n kube-system | grep -A 10 Events</span><br><span class="line">kubectl describe pod &lt;kubelet-pod-name&gt; -n kube-system | grep Events -A  10</span><br><span class="line"></span><br><span class="line">kubectl cordon node01</span><br><span class="line">kubectl drain node01 --ignore-daemonsets --delete-emptydir-data</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>k8s operator 开发事项</title>
    <url>/2024/10/15/k8s-operator-%E5%BC%80%E5%8F%91%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="Kubernetes-相关-API-包介绍"><a href="#Kubernetes-相关-API-包介绍" class="headerlink" title="Kubernetes 相关 API 包介绍"></a><strong>Kubernetes 相关 API 包介绍</strong></h2><h3 id="1-k8s-io-apimachinery-pkg-apis-meta-v1"><a href="#1-k8s-io-apimachinery-pkg-apis-meta-v1" class="headerlink" title="1. k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;apis&#x2F;meta&#x2F;v1"></a>1. <strong>k8s.io&#x2F;apimachinery&#x2F;pkg&#x2F;apis&#x2F;meta&#x2F;v1</strong></h3><ul>
<li><strong>功能</strong>：提供处理 Kubernetes 元数据的类型和函数。</li>
<li><strong>常用场景</strong>：<ul>
<li>创建、更新、删除 Kubernetes 资源时所需的元数据类型（如 <code>ObjectMeta</code>）。</li>
<li>时间戳、Label 选择器等辅助类型。</li>
</ul>
</li>
</ul>
<h3 id="2-k8s-io-api"><a href="#2-k8s-io-api" class="headerlink" title="2. k8s.io&#x2F;api"></a>2. <strong>k8s.io&#x2F;api</strong></h3><ul>
<li><strong>用途</strong>：定义 Kubernetes 各个 API 资源的 Go 语言结构体，按 API 组分类。</li>
<li><strong>关键模块</strong>：<ul>
<li><strong>core&#x2F;v1</strong>：核心资源（Pods、Services、ConfigMaps、Secrets）。</li>
<li><strong>apps&#x2F;v1</strong>：管理工作负载（Deployments、StatefulSets、DaemonSets）。</li>
<li><strong>batch&#x2F;v1</strong>：任务调度相关资源（Jobs、CronJobs）。</li>
<li><strong>networking&#x2F;v1</strong>：网络资源（Ingress、NetworkPolicy）。</li>
<li><strong>autoscaling&#x2F;v1、v2</strong>：自动扩缩容（HorizontalPodAutoscaler）。</li>
<li><strong>rbac&#x2F;v1</strong>：访问控制（Role、ClusterRole、RoleBinding）。</li>
</ul>
</li>
</ul>
<h3 id="3-k8s-io-client-go"><a href="#3-k8s-io-client-go" class="headerlink" title="3. k8s.io&#x2F;client-go"></a>3. <strong>k8s.io&#x2F;client-go</strong></h3><h4 id="k8s-io-client-go-kubernetes"><a href="#k8s-io-client-go-kubernetes" class="headerlink" title="k8s.io&#x2F;client-go&#x2F;kubernetes"></a><strong>k8s.io&#x2F;client-go&#x2F;kubernetes</strong></h4><ul>
<li><strong>功能</strong>：提供便捷的 API 接口用于管理和操作 Kubernetes 资源。<ul>
<li>封装与 Kubernetes API 的交互，支持资源 CRUD 操作。</li>
<li>支持身份认证和上下文管理。</li>
<li>提供事件、日志和资源监控支持。</li>
</ul>
</li>
</ul>
<h4 id="k8s-io-client-go-tools"><a href="#k8s-io-client-go-tools" class="headerlink" title="k8s.io&#x2F;client-go&#x2F;tools"></a><strong>k8s.io&#x2F;client-go&#x2F;tools</strong></h4><ul>
<li><strong>工具包</strong>：简化开发的辅助工具。<ul>
<li><strong>cache</strong>：Informer 缓存机制，提高 API 性能。</li>
<li><strong>clientcmd</strong>：解析 kubeconfig 文件，支持多集群配置。</li>
<li><strong>record</strong>：记录事件到 Kubernetes 系统。</li>
<li><strong>leaderelection</strong>：实现分布式系统中的领导选举。</li>
</ul>
</li>
</ul>
<h4 id="k8s-io-client-go-util"><a href="#k8s-io-client-go-util" class="headerlink" title="k8s.io&#x2F;client-go&#x2F;util"></a><strong>k8s.io&#x2F;client-go&#x2F;util</strong></h4><ul>
<li><strong>实用工具</strong>：<ul>
<li><strong>retry</strong>：实现指数退避的重试机制，处理临时错误。</li>
<li><strong>wait</strong>：等待某个条件满足的机制。</li>
<li><strong>homedir</strong>：获取用户主目录的路径，方便查找 kubeconfig。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Kubernetes-Operator-开发最佳实践"><a href="#Kubernetes-Operator-开发最佳实践" class="headerlink" title="Kubernetes Operator 开发最佳实践"></a><strong>Kubernetes Operator 开发最佳实践</strong></h2><h3 id="1-使用-Informers-和-Listers"><a href="#1-使用-Informers-和-Listers" class="headerlink" title="1. 使用 Informers 和 Listers"></a>1. <strong>使用 Informers 和 Listers</strong></h3><ul>
<li><strong>原因</strong>：减少与 API 服务器的直接交互，避免请求限额问题。</li>
<li><strong>做法</strong>：使用 Informers 缓存资源状态，提升性能。</li>
</ul>
<h3 id="2-实现幂等的-Reconcile-方法"><a href="#2-实现幂等的-Reconcile-方法" class="headerlink" title="2. 实现幂等的 Reconcile 方法"></a>2. <strong>实现幂等的 Reconcile 方法</strong></h3><ul>
<li><strong>原因</strong>：Reconcile 方法可能被多次调用，确保其幂等性避免状态不一致。</li>
<li><strong>实践</strong>：<ul>
<li>获取当前资源状态，与期望状态对比并更新。</li>
<li>避免在 Reconcile 中执行随机任务或不可重复操作。</li>
</ul>
</li>
</ul>
<h3 id="3-错误处理和重试机制"><a href="#3-错误处理和重试机制" class="headerlink" title="3. 错误处理和重试机制"></a>3. <strong>错误处理和重试机制</strong></h3><ul>
<li><strong>原因</strong>：应对 API 服务器不可用或资源冲突。</li>
<li><strong>做法</strong>：<ul>
<li>使用 <code>retry.RetryOnConflict</code> 处理资源冲突。</li>
<li>记录不可恢复的错误，触发告警或采取补救措施。</li>
</ul>
</li>
</ul>
<h3 id="4-使用-Finalizers-进行资源清理"><a href="#4-使用-Finalizers-进行资源清理" class="headerlink" title="4. 使用 Finalizers 进行资源清理"></a>4. <strong>使用 Finalizers 进行资源清理</strong></h3><ul>
<li><strong>作用</strong>：确保删除自定义资源前完成必要的清理（如删除外部资源）。</li>
</ul>
<h3 id="5-遵循最小权限原则-RBAC"><a href="#5-遵循最小权限原则-RBAC" class="headerlink" title="5. 遵循最小权限原则 (RBAC)"></a>5. <strong>遵循最小权限原则 (RBAC)</strong></h3><ul>
<li><strong>原因</strong>：减少安全风险，避免权限滥用。</li>
<li><strong>做法</strong>：<ul>
<li>仅授予必要的权限。</li>
<li>定期审查 RBAC 配置。</li>
</ul>
</li>
</ul>
<h3 id="6-使用-Context-管理请求"><a href="#6-使用-Context-管理请求" class="headerlink" title="6. 使用 Context 管理请求"></a>6. <strong>使用 Context 管理请求</strong></h3><ul>
<li><strong>原因</strong>：确保请求超时和取消逻辑的一致性。</li>
</ul>
<h3 id="7-日志记录与监控"><a href="#7-日志记录与监控" class="headerlink" title="7. 日志记录与监控"></a>7. <strong>日志记录与监控</strong></h3><ul>
<li><strong>做法</strong>：<ul>
<li>使用结构化日志（如 <code>logr</code>）。</li>
<li>集成 Prometheus 暴露监控指标。</li>
</ul>
</li>
</ul>
<h3 id="8-全面的测试覆盖"><a href="#8-全面的测试覆盖" class="headerlink" title="8. 全面的测试覆盖"></a>8. <strong>全面的测试覆盖</strong></h3><ul>
<li><strong>单元测试</strong>：测试 Reconcile 的逻辑和处理流程。</li>
<li><strong>集成测试</strong>：使用 <code>envtest</code> 模拟 Kubernetes 环境。</li>
<li><strong>端到端测试</strong>：在实际集群上验证控制器行为。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>k8s operator开发步骤</title>
    <url>/2024/09/25/k8s-operator%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h3 id="安装kubebuilder"><a href="#安装kubebuilder" class="headerlink" title="安装kubebuilder"></a>安装kubebuilder</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L -o kubebuilder &lt;https://go.kubebuilder.io/dl/latest/$&gt;(go env GOOS)/$(go env GOARCH)</span><br><span class="line">chmod +x kubebuilder &amp;&amp; mv kubebuilder /usr/local/bin/</span><br></pre></td></tr></table></figure>

<h3 id="1-创建脚手架工程"><a href="#1-创建脚手架工程" class="headerlink" title="1. 创建脚手架工程"></a><strong>1. 创建脚手架工程</strong></h3><ul>
<li><code>kubebuilder init --domain edas.io</code><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">kubebuilder init 命令参数:</span><br><span class="line">-domain：指定 <span class="variable constant_">CRD</span> 的域名，通常使用组织或项目的域名，确保 <span class="variable constant_">CRD</span> 名称唯一。</span><br><span class="line">-repo：指定 <span class="title class_">Go</span> 模块的路径，通常是 <span class="title class_">GitHub</span> 上的路径，用于代码组织。</span><br><span class="line">-version：指定使用的 <span class="title class_">Kubernetes</span> <span class="variable constant_">API</span> 版本，默认为 v1。</span><br><span class="line">-make-symlinks：创建指向 <span class="variable constant_">API</span> 和 <span class="title class_">Controller</span> 代码的符号链接，便于管理。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-创建-API"><a href="#2-创建-API" class="headerlink" title="2. 创建 API"></a><strong>2. 创建 API</strong></h3><ul>
<li><code>kubebuilder create api --group apps --version v1alpha1 --kind Application</code></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">kubebuilder create api 命令参数:</span><br><span class="line">-group：指定 <span class="variable constant_">API</span> 组名，用于区分不同的资源。</span><br><span class="line">-version：指定 <span class="variable constant_">API</span> 版本，通常为 v1 或其他。</span><br><span class="line">-kind：指定自定义资源的类型名称，通常采用大写驼峰命名法。</span><br><span class="line">-resource：是否创建 <span class="variable constant_">CRD</span> 资源，默认为是。</span><br><span class="line">-controller：是否创建控制器，默认为是。</span><br><span class="line">-controller：可以不添加任何参数，系统会提示输入基本配置。</span><br></pre></td></tr></table></figure>

<h3 id="3-定义-CRD"><a href="#3-定义-CRD" class="headerlink" title="3. 定义 CRD"></a><strong>3. 定义 CRD</strong></h3><ul>
<li><code>make manifests</code> 命令生成 CRD 文件，便于在集群中应用。</li>
</ul>
<h3 id="4-编写-Controller-逻辑"><a href="#4-编写-Controller-逻辑" class="headerlink" title="4. 编写 Controller 逻辑"></a><strong>4. 编写 Controller 逻辑</strong></h3><ul>
<li>编辑生成的控制器代码，添加业务逻辑，处理自定义资源的增、删、改、查等操作。</li>
</ul>
<h3 id="5-构建和部署-Operator"><a href="#5-构建和部署-Operator" class="headerlink" title="5.构建和部署 Operator"></a><strong>5.构建和部署 Operator</strong></h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">make docker-build # 构建镜像</span><br><span class="line">make docker-push # 推送镜像</span><br><span class="line">make deploy：安装controller到k8s （make undeploy：删除controller）</span><br><span class="line"></span><br><span class="line">#或者：</span><br><span class="line">#安装<span class="variable constant_">CRD</span>到k8s，可以先手动安装（make uninstall：删除<span class="variable constant_">CRD</span>）</span><br><span class="line">make install </span><br><span class="line"></span><br><span class="line">kubectl get crd</span><br></pre></td></tr></table></figure>

<h3 id="6-测试和验证："><a href="#6-测试和验证：" class="headerlink" title="6.测试和验证："></a><strong>6.测试和验证</strong>：</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"># 启动controller</span><br><span class="line">make run</span><br></pre></td></tr></table></figure>

<h3 id="7-卸载CRD："><a href="#7-卸载CRD：" class="headerlink" title="7.卸载CRD："></a><strong>7.卸载CRD</strong>：</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"># 卸载crd</span><br><span class="line">make uninstall</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>开发流程包括项目初始化、API 创建、控制器实现、生成 CRD、构建和部署，最后进行测试和验证。<br>参考文档：<br><a href="https://podsbook.com/posts/kubernetes/operator">https://podsbook.com/posts/kubernetes/operator</a><br><a href="https://www.rushui.net/posts/kubebuilder-demo-simple">https://www.rushui.net/posts/kubebuilder-demo-simple</a></p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>k8s patch 用法</title>
    <url>/2024/10/29/k8s-patch-%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="3-种-patch-类型"><a href="#3-种-patch-类型" class="headerlink" title="3 种 patch 类型"></a>3 种 patch 类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参考：</span><br><span class="line"> https://xie.infoq.cn/article/8fbdf51461881b87333b904cf</span><br><span class="line"></span><br><span class="line">1 strategic patch（默认）：根据不同字段 patchStrategy 决定具体的合并 patch 策略。 Strategic merge patch 并非通用的 RFC 标准，而是 Kubernetes 特有的一种更新 Kubernetes 资源对象的方式。与 JSON merge patch 和 JSON patch 相比，strategic merge patch 更为强大。</span><br><span class="line"></span><br><span class="line">2 JSON merge patch：遵循 JSON Merge Patch, RFC 7386[1] 规范，根据 patch 中提供的期望更改的字段及其对应的值，更新到目标中。</span><br><span class="line"></span><br><span class="line">3 JSON patch：遵循 JSON Patch, RFC 6902[2] 规范，通过明确的指令表示具体的操作。</span><br><span class="line">`kubectl patch` 的 `--type=&#x27;json&#x27;` 方式是一种非常灵活的 JSON Patch 操作，可以实现 添加、删除、更新多个字段 的功能。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="使用-JSON-patch-更新资源"><a href="#使用-JSON-patch-更新资源" class="headerlink" title="使用 JSON patch 更新资源"></a>使用 JSON patch 更新资源</h2><p>JSON Patch 遵循 <a href="https://tools.ietf.org/html/rfc6902">RFC 6902</a> 标准。常用操作有：  </p>
<ul>
<li><code>add</code>：向指定路径添加新字段。</li>
<li><code>remove</code>：删除指定路径的字段。</li>
<li><code>replace</code>：更新已有字段的值。</li>
<li><code>copy</code>：复制一个字段到另一个位置。</li>
<li><code>move</code>：移动字段。</li>
<li><code>test</code>：用于断言字段是否存在，常用于保证安全更新。</li>
</ul>
<hr>
<h3 id="1-更新已有字段的值（replace）"><a href="#1-更新已有字段的值（replace）" class="headerlink" title="1. 更新已有字段的值（replace）"></a>1. 更新已有字段的值（<code>replace</code>）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl patch cm ingress-nginx-controller -n ingress-nginx --<span class="built_in">type</span>=<span class="string">&#x27;json&#x27;</span> \</span><br><span class="line">-p=<span class="string">&#x27;[&#123;&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/data/ssl-protocols&quot;, &quot;value&quot;: &quot;TLSv1.2 TLSv1.3&quot;&#125;]&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>op: &quot;replace&quot;</code>：替换现有字段值。</li>
<li><code>path: &quot;/data/ssl-protocols&quot;</code>：要更新的字段路径。</li>
<li><code>value</code>：新的值。</li>
</ul>
<hr>
<h3 id="2-添加多个新字段（add）"><a href="#2-添加多个新字段（add）" class="headerlink" title="2. 添加多个新字段（add）"></a>2. 添加多个新字段（<code>add</code>）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl patch cm ingress-nginx-controller -n ingress-nginx --<span class="built_in">type</span>=<span class="string">&#x27;json&#x27;</span> \</span><br><span class="line">-p=<span class="string">&#x27;[</span></span><br><span class="line"><span class="string">  &#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/data/ssl-protocols&quot;, &quot;value&quot;: &quot;TLSv1 TLSv1.1 TLSv1.2 TLSv1.3&quot;&#125;,</span></span><br><span class="line"><span class="string">  &#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/data/ssl-ciphers&quot;, &quot;value&quot;: &quot;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA256:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:@SECLEVEL=0&quot;&#125;</span></span><br><span class="line"><span class="string">]&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>op: &quot;add&quot;</code>：为 ConfigMap 增加新的键值对。</li>
<li>多个字段用数组表示，每个 JSON Patch 操作为一个对象。</li>
</ul>
<hr>
<h3 id="3-删除多个字段（remove）"><a href="#3-删除多个字段（remove）" class="headerlink" title="3. 删除多个字段（remove）"></a>3. 删除多个字段（<code>remove</code>）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl patch cm ingress-nginx-controller -n ingress-nginx --<span class="built_in">type</span>=<span class="string">&#x27;json&#x27;</span> \</span><br><span class="line">-p=<span class="string">&#x27;[</span></span><br><span class="line"><span class="string">  &#123;&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/data/ssl-protocols&quot;&#125;,</span></span><br><span class="line"><span class="string">  &#123;&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/data/ssl-ciphers&quot;&#125;</span></span><br><span class="line"><span class="string">]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查主机port占用</span></span><br><span class="line">kubectl get deploy ingress-nginx-controller -n ingress-nginx -o jsonpath=<span class="string">&#x27;&#123;.spec.template.spec.containers[0].ports&#125;&#x27;</span> | jq</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除主机port</span></span><br><span class="line">kubectl patch deploy ingress-nginx-controller -n ingress-nginx \</span><br><span class="line">--<span class="built_in">type</span>=<span class="string">&#x27;json&#x27;</span> \</span><br><span class="line">-p=<span class="string">&#x27;[</span></span><br><span class="line"><span class="string">  &#123;&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/spec/template/spec/containers/0/ports/0/hostPort&quot;&#125;,</span></span><br><span class="line"><span class="string">  &#123;&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/spec/template/spec/containers/0/ports/1/hostPort&quot;&#125;,</span></span><br><span class="line"><span class="string">  &#123;&quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/spec/template/spec/containers/0/ports/2/hostPort&quot;&#125;</span></span><br><span class="line"><span class="string">]&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>op: &quot;remove&quot;</code>：删除指定字段。</li>
<li>如果字段不存在，会报错，可以先用 <code>kubectl get</code> 检查字段。</li>
</ul>
<hr>
<h3 id="4-复制字段（copy）"><a href="#4-复制字段（copy）" class="headerlink" title="4. 复制字段（copy）"></a>4. 复制字段（<code>copy</code>）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl patch cm ingress-nginx-controller -n ingress-nginx --<span class="built_in">type</span>=<span class="string">&#x27;json&#x27;</span> \</span><br><span class="line">-p=<span class="string">&#x27;[&#123;&quot;op&quot;: &quot;copy&quot;, &quot;from&quot;: &quot;/data/ssl-protocols&quot;, &quot;path&quot;: &quot;/data/backup-ssl-protocols&quot;&#125;]&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>op: &quot;copy&quot;</code>：从 <code>/data/ssl-protocols</code> 复制值到 <code>/data/backup-ssl-protocols</code>。</li>
</ul>
<hr>
<h3 id="5-条件测试字段（test）并更新"><a href="#5-条件测试字段（test）并更新" class="headerlink" title="5. 条件测试字段（test）并更新"></a>5. 条件测试字段（<code>test</code>）并更新</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl patch cm ingress-nginx-controller -n ingress-nginx --<span class="built_in">type</span>=<span class="string">&#x27;json&#x27;</span> \</span><br><span class="line">-p=<span class="string">&#x27;[</span></span><br><span class="line"><span class="string">  &#123;&quot;op&quot;: &quot;test&quot;, &quot;path&quot;: &quot;/data/ssl-protocols&quot;, &quot;value&quot;: &quot;TLSv1 TLSv1.2&quot;&#125;,</span></span><br><span class="line"><span class="string">  &#123;&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/data/ssl-protocols&quot;, &quot;value&quot;: &quot;TLSv1.2 TLSv1.3&quot;&#125;</span></span><br><span class="line"><span class="string">]&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>op: &quot;test&quot;</code>：检查 <code>ssl-protocols</code> 的值是否匹配。如果不匹配，则不会执行替换操作。</li>
</ul>
<hr>
<h3 id="6-merge-json-用法"><a href="#6-merge-json-用法" class="headerlink" title="6. merge &amp; json 用法"></a>6. merge &amp; json 用法</h3><table>
<thead>
<tr>
<th align="left">项目</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>merge</code></td>
<td align="left">直接将指定字段合并到现有资源，不要求父节点已存在（最适合补充 annotations）</td>
</tr>
<tr>
<td align="left"><code>json</code></td>
<td align="left">纯 JSON Patch 语义，要求每一层路径存在，不存在就会 400 错误（适合复杂 patch）</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在 JSON patch 语义中，如果父节点 (annotations) 不存在，直接 patch 子字段（annotations.xxx）是非法的，会被服务器拒绝。</span><br><span class="line"></span><br><span class="line">kubectl patch ingress nginx-demo -n xxx \</span><br><span class="line">--type=&#x27;merge&#x27; \</span><br><span class="line">-p=&#x27;&#123;</span><br><span class="line">  &quot;metadata&quot;: &#123;</span><br><span class="line">    &quot;annotations&quot;: &#123;</span><br><span class="line">      &quot;nginx.ingress.kubernetes.io/proxy-connect-timeout&quot;: &quot;60&quot;,</span><br><span class="line">      &quot;nginx.ingress.kubernetes.io/proxy-send-timeout&quot;: &quot;600&quot;,</span><br><span class="line">      &quot;nginx.ingress.kubernetes.io/proxy-read-timeout&quot;: &quot;600&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br><span class="line">#json使用</span><br><span class="line">kubectl patch ingress nginx-demo -n xxx \</span><br><span class="line">  --type=&#x27;json&#x27; \</span><br><span class="line">  -p=&#x27;[</span><br><span class="line">    &#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/metadata/annotations/nginx.ingress.kubernetes.io~1proxy-connect-timeout&quot;,  &quot;value&quot;: &quot;60&quot;&#125;,</span><br><span class="line">    &#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/metadata/annotations/nginx.ingress.kubernetes.io~1proxy-send-timeout&quot;,  &quot;value&quot;: &quot;600&quot;&#125;,</span><br><span class="line">    &#123;&quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/metadata/annotations/nginx.ingress.kubernetes.io~1proxy-read-timeout&quot;,  &quot;value&quot;: &quot;600&quot;&#125;</span><br><span class="line">  ]&#x27;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用 <code>--type=&#39;json&#39;</code> 进行 PATCH 操作非常灵活，特别适合批量修改配置。  </p>
<ul>
<li><code>add</code>：新增字段。</li>
<li><code>replace</code>：更新现有字段。</li>
<li><code>remove</code>：删除不需要的字段。</li>
<li><code>copy</code> 和 <code>move</code>：在 JSON 中重构结构。</li>
<li><code>test</code>：用于确保一致性，避免不正确的更新。</li>
</ul>
<p>这些操作特别适合集群自动化运维和精细化的配置变更。</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>k8s service account demo</title>
    <url>/2024/09/09/k8s-service-account-demo/</url>
    <content><![CDATA[<p>在 Kubernetes 中使用 Service Account（SA）时，可以通过配置自定义的 Service Account 来实现对集群资源的访问权限。下面是一个创建 Service Account 并配置其访问集群资源的案例。</p>
<h3 id="步骤-1：创建-Service-Account"><a href="#步骤-1：创建-Service-Account" class="headerlink" title="步骤 1：创建 Service Account"></a>步骤 1：创建 Service Account</h3><p>首先，创建一个 Service Account。例如，命名为 <code>custom-sa</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create serviceaccount custom-sa</span><br></pre></td></tr></table></figure>

<p>这将会在当前命名空间中创建一个名为 <code>custom-sa</code> 的 Service Account。在 Kubernetes 1.24 及之后的版本中，Service Account 不再默认生成 Secret。为 Service Account 手动创建 Secret：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">custom-sa-secret</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/service-account.name:</span> <span class="string">&quot;custom-sa&quot;</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/service-account-token</span></span><br></pre></td></tr></table></figure>
<p>然后应用该 YAML 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f custom-sa-secret.yaml</span><br></pre></td></tr></table></figure>
<p>确认 Secret 被绑定： 使用以下命令查看 Service Account 是否绑定了 Secret：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe sa custom-sa</span><br></pre></td></tr></table></figure>
<p>确认 secrets 部分列出了 custom-sa-secret。</p>
<h3 id="步骤-2：创建-Role-或-ClusterRole"><a href="#步骤-2：创建-Role-或-ClusterRole" class="headerlink" title="步骤 2：创建 Role 或 ClusterRole"></a>步骤 2：创建 Role 或 ClusterRole</h3><p><strong>Role</strong> 用于定义在指定命名空间中的权限，而 <strong>ClusterRole</strong> 用于集群范围的权限。根据需要，你可以创建一个 <code>Role</code> 或 <code>ClusterRole</code>。</p>
<h4 id="创建-Role（针对某一命名空间的权限）："><a href="#创建-Role（针对某一命名空间的权限）：" class="headerlink" title="创建 Role（针对某一命名空间的权限）："></a>创建 Role（针对某一命名空间的权限）：</h4><p>假设你想为该 Service Account 赋予在某个命名空间中读取 Pods 的权限，你可以这样创建一个 <code>Role</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]  <span class="comment"># &quot;&quot; 代表 core API group</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>保存为 <code>role.yaml</code> 文件后，执行以下命令来应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f role.yaml</span><br></pre></td></tr></table></figure>

<h4 id="创建-ClusterRole（全集群范围的权限）："><a href="#创建-ClusterRole（全集群范围的权限）：" class="headerlink" title="创建 ClusterRole（全集群范围的权限）："></a>创建 ClusterRole（全集群范围的权限）：</h4><p>如果你想授予集群范围的权限，可以创建一个 <code>ClusterRole</code>。例如，授予读取集群中所有命名空间下 Pods 的权限：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-pod-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>保存为 <code>clusterrole.yaml</code>，然后执行以下命令来应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f clusterrole.yaml</span><br></pre></td></tr></table></figure>

<h3 id="步骤-3：绑定-Role-或-ClusterRole-到-Service-Account"><a href="#步骤-3：绑定-Role-或-ClusterRole-到-Service-Account" class="headerlink" title="步骤 3：绑定 Role 或 ClusterRole 到 Service Account"></a>步骤 3：绑定 Role 或 ClusterRole 到 Service Account</h3><p>为了使 Service Account 具有访问权限，必须将其与 <code>Role</code> 或 <code>ClusterRole</code> 绑定。</p>
<h4 id="绑定-Role："><a href="#绑定-Role：" class="headerlink" title="绑定 Role："></a>绑定 Role：</h4><p>如果你创建了 <code>Role</code>，使用以下 <code>RoleBinding</code> 将 <code>custom-sa</code> 与 <code>Role</code> 绑定：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-pods-binding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">custom-sa</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p>应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f rolebinding.yaml</span><br></pre></td></tr></table></figure>

<h4 id="绑定-ClusterRole："><a href="#绑定-ClusterRole：" class="headerlink" title="绑定 ClusterRole："></a>绑定 ClusterRole：</h4><p>如果你使用的是 <code>ClusterRole</code>，可以通过 <code>ClusterRoleBinding</code> 进行绑定：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">read-pods-cluster-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">custom-sa</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-pod-reader</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p>应用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f clusterrolebinding.yaml</span><br></pre></td></tr></table></figure>

<h3 id="步骤-4：创建-Kubeconfig-文件"><a href="#步骤-4：创建-Kubeconfig-文件" class="headerlink" title="步骤 4：创建 Kubeconfig 文件"></a>步骤 4：创建 Kubeconfig 文件</h3><p>为了使这个 Service Account 能够通过 kubeconfig 文件访问集群，需要以下步骤：</p>
<ol>
<li>获取 Service Account 的 token：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TOKEN=$(kubectl get secret custom-sa-secret -o jsonpath=<span class="string">&#x27;&#123;.data.token&#125;&#x27;</span> | <span class="built_in">base64</span> --decode)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取集群的 CA 证书：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CA_CERT=$(kubectl get secret custom-sa-secret -o jsonpath=<span class="string">&#x27;&#123;.data.ca\.crt&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>获取集群的 API server 地址：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SERVER=$(kubectl config view --minify -o jsonpath=<span class="string">&#x27;&#123;.clusters[0].cluster.server&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建 kubeconfig 文件：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; custom-sa.kubeconfig</span></span><br><span class="line"><span class="string">apiVersion: v1</span></span><br><span class="line"><span class="string">kind: Config</span></span><br><span class="line"><span class="string">clusters:</span></span><br><span class="line"><span class="string">- cluster:</span></span><br><span class="line"><span class="string">    certificate-authority-data: $&#123;CA_CERT&#125;</span></span><br><span class="line"><span class="string">    server: $&#123;SERVER&#125;</span></span><br><span class="line"><span class="string">  name: kubernetes</span></span><br><span class="line"><span class="string">contexts:</span></span><br><span class="line"><span class="string">- context:</span></span><br><span class="line"><span class="string">    cluster: kubernetes</span></span><br><span class="line"><span class="string">    user: custom-sa</span></span><br><span class="line"><span class="string">  name: custom-sa-context</span></span><br><span class="line"><span class="string">current-context: custom-sa-context</span></span><br><span class="line"><span class="string">users:</span></span><br><span class="line"><span class="string">- name: custom-sa</span></span><br><span class="line"><span class="string">  user:</span></span><br><span class="line"><span class="string">    token: $&#123;TOKEN&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl --kubeconfig=./custom-sa.kubeconfig get sa -n kube-system</span><br></pre></td></tr></table></figure>

<h3 id="ClusterRole-与-Role-的区别"><a href="#ClusterRole-与-Role-的区别" class="headerlink" title="ClusterRole 与 Role 的区别"></a>ClusterRole 与 Role 的区别</h3><ul>
<li><strong>Role</strong>：仅限于某个命名空间，不能跨命名空间生效。它用于授予某个命名空间内资源的权限。</li>
<li><strong>ClusterRole</strong>：在整个集群范围内生效，可以跨命名空间访问资源。它用于管理集群级别的资源或多个命名空间的资源。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>创建一个 <code>Service Account</code>。</li>
<li>创建一个 <code>Role</code> 或 <code>ClusterRole</code>，根据需求分配权限。</li>
<li>将 <code>Service Account</code> 通过 <code>RoleBinding</code> 或 <code>ClusterRoleBinding</code> 绑定到 <code>Role</code> 或 <code>ClusterRole</code>。</li>
<li>使用 <code>Service Account</code> 的 token 配置 kubeconfig 文件，使其可以访问集群。</li>
</ol>
<hr>
<p>在 Kubernetes 1.24 及以上版本中，手动为 ServiceAccount 创建并绑定一个 Secret 令牌时，需要特别注意 <code>metadata.annotations</code> 的设置，直接通过 <code>kubectl create secret</code> 命令不会自动添加这些注解，因此容易出错。这里是最终的解决步骤：</p>
<h3 id="使用命令的解决方法"><a href="#使用命令的解决方法" class="headerlink" title="使用命令的解决方法"></a>使用命令的解决方法</h3><ol>
<li><p><strong>创建 ServiceAccount</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create serviceaccount my-sa -n kube-system</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>手动创建并绑定 Secret</strong>：<br>手动创建一个符合要求的 <code>ServiceAccountToken</code> Secret，确保它包含必要的 <code>metadata.annotations</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> kubectl create secret generic my-sa-token \</span><br><span class="line">--namespace kube-system \</span><br><span class="line">--<span class="built_in">type</span> kubernetes.io/service-account-token \</span><br><span class="line">--dry-run=client -o yaml | \</span><br><span class="line">kubectl annotate --<span class="built_in">local</span> -f - \</span><br><span class="line">  kubernetes.io/service-account.name=my-sa -o yaml | \</span><br><span class="line">kubectl apply -f -</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h3><p>执行以下命令，确保 Secret 与 ServiceAccount 已正确关联：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl -n kube-system get serviceaccount my-sa -o yaml</span><br><span class="line">kubectl -n kube-system get secret my-sa-token -o yaml</span><br></pre></td></tr></table></figure>

<h3 id="获取令牌"><a href="#获取令牌" class="headerlink" title="获取令牌"></a>获取令牌</h3><p>从 Secret 中获取并解码 <code>token</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl -n kube-system get secret my-sa-token -o jsonpath=<span class="string">&quot;&#123;.data.token&#125;&quot;</span> | <span class="built_in">base64</span> --decode</span><br></pre></td></tr></table></figure>

<hr>
<p>清理前面步骤中创建的 <code>ServiceAccount</code>、<code>Secret</code> 和 <code>ClusterRoleBinding</code> 等测试资源：</p>
<ol>
<li><p><strong>删除 ServiceAccount</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete serviceaccount my-sa -n kube-system</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除 Secret</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete secret my-sa-token -n kube-system</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除 ClusterRoleBinding</strong>：<br>如果创建了 <code>ClusterRoleBinding</code> 用于 <code>my-sa</code>，可以使用以下命令删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete clusterrolebinding my-sa-binding</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这将清理所有与 <code>my-sa</code> 相关的资源。执行完后可以检查确认相关资源已删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl -n kube-system get serviceaccount my-sa</span><br><span class="line">kubectl -n kube-system get secret my-sa-token</span><br><span class="line">kubectl get clusterrolebinding my-sa-binding</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>k8s实用工具</title>
    <url>/2024/11/29/k8s%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="stern"><a href="#stern" class="headerlink" title="stern"></a>stern</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#https://github.com/stern/stern</span><br><span class="line">#安装方式</span><br><span class="line">kubectl krew install stern</span><br><span class="line"></span><br><span class="line">#二进制</span><br><span class="line">https://github.com/stern/stern/releases/tag/v1.32.0</span><br></pre></td></tr></table></figure>

<h2 id="kubetail"><a href="#kubetail" class="headerlink" title="kubetail"></a>kubetail</h2><ul>
<li>命令行版<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#https://github.com/johanhaleby/kubetail</span></span><br><span class="line">wget https://github.com/johanhaleby/kubetail/archive/refs/tags/1.6.20.tar.gz</span><br><span class="line">tar zxvf 1.6.20.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> kubetail-1.6.20</span><br><span class="line"><span class="built_in">cp</span> kubetail /usr/local/bin/</span><br><span class="line"><span class="built_in">cp</span> kubetail.plugin.zsh /etc/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#eg:</span></span><br><span class="line">kt <span class="string">&quot;backend|stark&quot;</span> --regex</span><br></pre></td></tr></table></figure></li>
<li>UI版<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo add kubetail https://kubetail-org.github.io/helm-charts/</span><br><span class="line">helm install kubetail kubetail/kubetail --namespace kubetail-system --create-namespace</span><br><span class="line"></span><br><span class="line">helm list -n kubetail-system</span><br><span class="line"></span><br><span class="line">#注意修改镜像</span><br><span class="line">helm get values kubetail -a -n kubetail-system</span><br><span class="line"></span><br><span class="line">#起本地端口，浏览器查看服务</span><br><span class="line">kubectl port-forward --address 0.0.0.0 -n kubetail-system svc/kubetail-dashboard 8888:8080</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="kubecolor"><a href="#kubecolor" class="headerlink" title="kubecolor"></a>kubecolor</h2><ul>
<li><a href="https://github.com/hidetatz/kubecolor">https://github.com/hidetatz/kubecolor</a></li>
</ul>
<h2 id="k9s"><a href="#k9s" class="headerlink" title="k9s"></a>k9s</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#https://github.com/derailed/k9s</span></span><br><span class="line">curl -sS https://webinstall.dev/k9s | bash</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.config/envman/PATH.<span class="built_in">env</span></span><br></pre></td></tr></table></figure>

<h2 id="runlike-查询docker的启动命令"><a href="#runlike-查询docker的启动命令" class="headerlink" title="runlike (查询docker的启动命令)"></a>runlike (查询docker的启动命令)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Anolis OS 8.2 安装python3</span><br><span class="line">rpm -ivh https://mirrors.aliyun.com/anolis/8.2/BaseOS/x86_64/os/Packages/python3-pip-wheel-9.0.3-16.el8.noarch.rpm</span><br><span class="line"></span><br><span class="line">#安装csvkit</span><br><span class="line">pip3 install csvkit</span><br><span class="line">#安装 runlike</span><br><span class="line">pip3 install runlike</span><br><span class="line">pip3 show runlike</span><br><span class="line">#查询命令安装位置</span><br><span class="line">find ~/.local/bin /usr/local/bin /usr/bin -name runlike 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">/usr/local/bin/runlike &lt;containerd_id&gt; | sed &#x27;s/ \-\-/ \\\n--/g&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>k8s最佳实践(二)</title>
    <url>/2024/11/08/k8s%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E4%BA%8C/</url>
    <content><![CDATA[<p>在 Kubernetes 中，Network Policies、Admission Webhooks 和 Admission Controllers 是实现集群安全、资源控制与策略验证的关键部分。以下是关于这几项功能的实践总结：</p>
<ol>
<li>常见 Network Policies 策略</li>
</ol>
<p>Network Policies 是基于命名空间的网络隔离策略，通过设置 Pod 的入站和出站流量规则来控制网络访问。常见策略及其特点如下：</p>
<pre><code>•	默认隔离：通过创建一个 Network Policy 将所有 ingress 或 egress 设置为空，即默认阻止流量，只有明确允许的流量才能访问。这在实际应用中非常适合对敏感服务进行隔离，减少网络攻击面。
•	特定端口限制：只允许某些端口的入站流量。例如，将数据库服务的 Network Policy 配置为只允许从特定应用 Pod 的请求，并限制在特定的端口（如 3306）上连接。这种策略有效地减少了开放端口的数量，提高了安全性。
•	基于标签的策略：在 Network Policies 中，基于 Pod 标签来允许流量。这使得可以灵活地控制服务之间的访问，例如允许同一应用的多个组件互相通信，但限制外部流量。
•	跨命名空间的访问控制：默认情况下，Network Policies 只在当前命名空间内生效。对于需要跨命名空间的访问，可以通过 namespaceSelector 指定允许的命名空间流量。此策略适用于多租户环境中，确保各租户之间的隔离性。
•	双向隔离（Ingress 和 Egress）：一些应用场景需要双向流量控制。例如，限制应用 Pod 只能从特定 IP 段或外部服务获得数据，并控制它们的流出流量。这有助于防止敏感信息泄露，并减少外部威胁。
•	CIDR 限制：通过 CIDR 范围控制 IP 地址访问，例如仅允许来自某一特定子网的流量。对于需要局部网络保护的 Pod，这种策略可有效阻止未经允许的访问。
</code></pre>
<p>关注点：</p>
<pre><code>•	优先级：Network Policies 不具备优先级，策略应用是基于 “允许优先”。多条策略的组合可能会导致意外的流量过滤或开放。
•	性能：在大型集群中，复杂的 Network Policies 可能影响网络性能，尤其是基于大量 IP 地址或复杂标签的规则。
•	兼容性：不同 CNI 插件（如 Calico、Weave）支持的 Network Policies 细节上可能存在差异，需确保策略兼容性。
</code></pre>
<ol start="2">
<li>Admission Webhook 注意事项</li>
</ol>
<p>Admission Webhook 是在资源创建或更新请求达到 API Server 时，对其进行拦截和动态处理的一种机制。它分为两类：Validating Webhook（用于验证请求合法性）和 Mutating Webhook（用于动态修改请求）。</p>
<pre><code>•	动态修改资源：Mutating Webhook 可以在创建资源时自动注入一些字段（如默认镜像拉取策略、标签等），适合自动化配置的场景。实践中，如 Sidecar 容器的自动注入可通过此功能实现。
•	顺序和优先级：多个 Admission Webhook 的执行是无序的，如果有依赖关系，需注意可能的顺序冲突。例如，确保 Mutating Webhook 在 Validating Webhook 之前触发，以避免未修改的资源触发不必要的验证错误。
•	失败策略：在配置 Admission Webhook 时，可设置 failurePolicy 为 Ignore 或 Fail。在生产环境中，建议对非关键性检查使用 Ignore 以确保高可用性，对关键检查（如安全性验证）使用 Fail。
•	性能影响：Admission Webhook 会影响 API Server 的响应时间，尤其是当 Webhook 服务响应延迟较高时。在实践中可通过减少 Webhook 校验的资源范围或避免阻塞性请求来优化性能。
•	兼容性：Admission Webhook 需要 K8s 1.9 以上版本支持，对低版本集群可能需要其他认证或审计机制替代。
</code></pre>
<ol start="3">
<li>Admission Controller 的注意事项</li>
</ol>
<p>Admission Controller 是 Kubernetes 中用于在 API Server 处理请求的过程中动态拦截和检查资源配置的组件。它内置了一系列控制器，负责配置、验证和强制执行集群策略。</p>
<pre><code>•	PodSecurityPolicy（PSP）：限制 Pod 安全上下文（如运行用户、特权权限等），用于提升集群安全性。PSP 是一种有效的权限控制工具，但它的使用较复杂，容易导致权限不足的 Pod 无法创建。PSP 从 Kubernetes 1.21 开始已被标记为弃用，建议使用 OPA Gatekeeper 替代实现。
•	ResourceQuota：通过限制命名空间的资源上限（如 CPU、内存、对象数量等），防止资源滥用。设置时需要合理配置，以避免单一命名空间的资源超额导致其他服务受影响。特别是在多租户集群中，有效的 ResourceQuota 是资源控制的关键。
•	LimitRange：在 Pod 或容器级别设置资源的最小、最大请求值，防止资源不足或资源浪费。开发中应确保合理的默认值，避免 Pod 配置过于宽泛或局限。
•	ImagePolicyWebhook：控制镜像的使用，可以防止拉取未经批准或不安全的镜像。适用于需要集中控制镜像仓库访问的场景，提升集群的整体安全性。
•	NamespaceLifecycle：确保在删除命名空间时清理相关资源，以避免资源泄漏。此 Admission Controller 对动态调整命名空间的生命周期管理尤为重要。
</code></pre>
<p><img src="https://raw.githubusercontent.com/shispring/picgo/master/frc-c9ec2afa9d8d6c07ac428c1aea35f1ea.jpeg" alt="webhook1" title="webhook1"></p>
<p><img src="https://raw.githubusercontent.com/shispring/picgo/master/admission-controller-phases.png" alt="webhook2" title="webhook2"></p>
<ol start="4">
<li><p>总结与最佳实践</p>
<p> •	分层防护：结合 Network Policies、RBAC、PSP 等，形成多层次的集群安全体系。<br> •	测试和验证：在生产集群应用策略前，可使用沙盒环境测试 Admission Webhook 和 Network Policies 的效果，以避免策略冲突导致服务中断。<br> •	性能与可用性：确保 Admission Webhook 的执行快速、稳定，避免对集群的可用性产生影响。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>k8s最佳实践(-)</title>
    <url>/2024/11/08/k8s%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>Kubernetes（K8s）开发涉及到大量的组件和细节性问题。以下是 Kubernetes 开发中的最佳实践，以及需要关注的组件、调度算法、资源管理等关键内容，以便全面掌握 Kubernetes 开发过程的方方面面。</p>
<ol>
<li><p>核心组件的理解与设计最佳实践</p>
<p> •	API Server：作为 Kubernetes 的控制平面，API Server 处理所有集群内部组件与用户的请求。对于 API Server 的开发，要关注认证（Authentication）、授权（Authorization）、准入控制（Admission Control）等机制，并确保集群资源的安全性和权限管理。<br> •	etcd：Kubernetes 中的键值存储数据库，保存所有集群的状态。高可用和数据一致性对 etcd 来说尤为重要。推荐使用备份机制，并在多节点集群中启用 etcd 集群来提高可靠性。<br> •	Controller Manager：控制循环是 Kubernetes 的核心概念之一，Controller Manager 中负责资源调节和自动化的各种控制器。理解控制器如何检测和纠正状态差异，对于开发新的控制器有很大帮助。<br> •	Scheduler：负责将 Pod 分配到适当的节点上。在 Scheduler 中，需注意如何使用优先级函数、过滤策略（Predicates）、得分策略（Scores）等，确保 Pod 的资源需求与节点资源的最佳匹配。<br> •	Kubelet：运行在每个节点上的核心代理，负责管理 Pod 生命周期和容器运行。Kubelet 需要频繁与 API Server 通信，因此需要特别注意网络连接和性能优化。</p>
</li>
<li><p>调度器（Scheduler）的关键算法和优化</p>
</li>
</ol>
<p>Kubernetes 调度器的调度过程分为预选（Predicates）和优选（Priorities）两部分：</p>
<pre><code>•	预选（Predicates）：在调度开始时，通过过滤节点资源（如 CPU、内存、地域等条件），排除不适合的节点。这包括以下关键算法：
•	PodFitsResources：判断节点是否有足够资源满足 Pod 的需求。
•	PodFitsHost：适合具有特定节点需求的 Pod。
•	PodFitsTopology：检查拓扑需求，例如反亲和性（Anti-Affinity）规则。
•	优选（Priorities）：选择预选中最合适的节点。优选算法会为每个节点打分并选择得分最高的节点。常见优选算法包括：
•	LeastRequestedPriority：优先选择资源使用率低的节点。
•	BalancedResourceAllocation：尽量将 Pod 分配到资源分布均匀的节点上。
•	InterPodAffinityPriority：根据 Pod 的亲和性或反亲和性需求打分。
</code></pre>
<p>调度器的调优在大型集群中尤为重要。例如，可以通过 自定义调度策略 来满足业务需求，或者增加 多调度器 支持不同业务的多种调度策略。</p>
<ol start="3">
<li><p>资源管理和扩展性</p>
<p> •	资源请求和限制（Requests &amp; Limits）：在 Pod 中设置合理的资源请求和限制，确保系统组件和业务组件的资源隔离。对于 CPU 密集型或内存密集型应用，调整资源请求和限制能够避免资源争用。<br> •	节点自动扩展（Cluster Autoscaler）：在集群中启用 Cluster Autoscaler，可以根据 Pod 的 Pending 状态自动增加节点。结合 Horizontal Pod Autoscaler（HPA），可以根据流量自动扩展 Pod。<br> •	资源配额（Resource Quotas）和限制（LimitRanges）：在命名空间中设置资源配额，避免某一命名空间资源消耗过多而影响集群整体可用性。</p>
</li>
<li><p>安全性与认证</p>
<p> •	RBAC（Role-Based Access Control）：为用户、服务账户分配适当的权限。使用 RBAC 可以细粒度地控制 API 访问权限，保护集群安全。<br> •	Network Policies：定义 Pod 网络流量的访问控制策略，确保集群网络安全。合理的 Network Policies 可以隔离不同应用之间的通信。<br> •	Admission Controller：准入控制器可以用来在资源创建、更新等过程中进行动态策略检查，如 Pod 安全策略（PodSecurityPolicy）、限制异常配置等。</p>
</li>
<li><p>性能优化</p>
<p> •	容器和镜像优化：避免在容器中运行不必要的进程。使用更小的基础镜像（如 Alpine）能有效减少镜像大小，提升镜像的拉取速度。<br> •	缓存和存储：配置合理的存储类，选择适合应用需求的存储系统（如 NFS、Ceph）。对于高频读写应用，使用缓存策略可以提升存储性能。<br> •	监控与日志：利用 Prometheus 和 Grafana 监控集群资源状态，及时发现性能瓶颈。使用 Fluentd 等工具集中收集日志，便于快速排查问题。</p>
</li>
<li><p>开发调试和测试</p>
<p> •	开发环境搭建：使用 minikube、kind 等工具可以快速搭建本地开发环境；在本地模拟生产环境，减少上线前的测试成本。<br> •	Kubectl Debug：使用 kubectl debug 可以快速进入故障容器环境，查看运行状态。<br> •	CI&#x2F;CD 集成：结合 GitLab CI、Jenkins 等 CI&#x2F;CD 工具自动部署测试，确保每次代码变更自动触发测试和部署流程。</p>
</li>
<li><p>Kubernetes 扩展性设计</p>
<p> •	Operator 模式：使用 Operator 可以将 Kubernetes 的声明式 API 扩展到管理复杂应用的生命周期。例如，可以使用 Operator 实现应用的自动备份、恢复和扩展。<br> •	CRD（Custom Resource Definitions）：CRD 允许开发者定义自定义资源类型，扩展 Kubernetes 的 API，为特定业务逻辑定制资源对象。<br> •	Webhooks：使用 Admission Webhook 可用于在资源创建或修改时进行额外校验，Mutation Webhook 则用于自动填充或修改资源字段。</p>
</li>
<li><p>日志与监控实践</p>
<p> •	Prometheus 和 Grafana：利用 Prometheus 采集资源指标，使用 Grafana 创建可视化仪表盘实时监控集群资源状态。<br> •	ELK Stack（Elasticsearch、Logstash、Kibana）：用于集中式日志收集和分析，可以帮助快速定位集群故障原因。<br> •	Alertmanager：结合 Prometheus 的 Alertmanager 设置告警，确保在节点故障或资源紧张时能及时响应。</p>
</li>
<li><p>调度优化与高可用</p>
<p> •	节点分配策略：通过节点池和亲和性策略，合理分配工作负载，保证关键业务的高可用性。<br> •	Pod 优先级与抢占：使用 Pod 优先级和抢占策略，确保高优先级的工作负载有资源调度保证。<br> •	分区容错：通过 TopologySpreadConstraints 设置不同区域的容错策略，增强跨可用区的容灾能力。</p>
</li>
</ol>
<p>总结</p>
<p>Kubernetes 开发中的最佳实践涵盖了从资源管理、性能调优、安全性到监控和扩展等多方面内容。理解 Kubernetes 核心组件和调度机制，合理设计 CRD 和 Operator，以及使用 CI&#x2F;CD 和监控系统，能显著提升开发和运维的效率。同时，关注网络和资源隔离、权限管理，能帮助在大规模环境中实现高可用、安全的 Kubernetes 集群。</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>krew &amp;&amp; kubecm</title>
    <url>/2024/09/25/krew-kubecm/</url>
    <content><![CDATA[<h2 id="一、安装kubectl"><a href="#一、安装kubectl" class="headerlink" title="一、安装kubectl"></a>一、安装kubectl</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置yum源</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.28/rpm/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.28/rpm/repodata/repomd.xml.key</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#清除旧的yum缓存，生成新缓存，检查yum源</span></span><br><span class="line">yum clean all &amp;&amp; yum makecache &amp;&amp; yum repolist</span><br><span class="line"></span><br><span class="line">yum --showduplicate list kubectl</span><br><span class="line"></span><br><span class="line">yum install -y kubectl-1.28.12</span><br></pre></td></tr></table></figure>

<h2 id="二、安装krew"><a href="#二、安装krew" class="headerlink" title="二、安装krew"></a>二、安装krew</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#https://www.voidking.com/dev-kubectl-krew/</span></span><br><span class="line"><span class="comment">#https://github.com/kubernetes-sigs/krew/releases</span></span><br><span class="line"><span class="comment">#下载</span></span><br><span class="line">wget https://github.com/kubernetes-sigs/krew/releases/download/v0.4.4/krew-linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar zxvf krew-linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">./krew-linux_amd64 install krew</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置环境变量.bash_profile</span></span><br><span class="line"><span class="built_in">alias</span> k=<span class="string">&#x27;kubectl &#x27;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$&#123;KREW_ROOT:-<span class="variable">$HOME</span>/.krew&#125;</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、krew相关命令"><a href="#三、krew相关命令" class="headerlink" title="三、krew相关命令"></a>三、krew相关命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl krew -h</span><br><span class="line">kubectl krew version</span><br><span class="line"></span><br><span class="line">kubectl krew update</span><br><span class="line">kubectl krew search ingress</span><br><span class="line"></span><br><span class="line">kubectl krew search xxx</span><br><span class="line">kubectl krew install xxx</span><br><span class="line"></span><br><span class="line">kubectl xxx -h</span><br><span class="line"></span><br><span class="line">kubectl krew list</span><br><span class="line"></span><br><span class="line"><span class="comment">#除了使用krew安装kubectl插件之外，还有另外一个更加直接的办法安装kubectl插件：下载插件的二进制文件，和kubectl文件放到一起</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载</span></span><br><span class="line">kubectl krew uninstall</span><br></pre></td></tr></table></figure>

<h2 id="四、安装kubecm"><a href="#四、安装kubecm" class="headerlink" title="四、安装kubecm"></a>四、安装kubecm</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#KubeCm 是一个多集群 KubeConfig 访问凭证管理工具，支持展示、切换、添加、删除 KubeConfig 访问凭证到$HOME/.kube/config文件中，方便多集群管理场景。</span></span><br><span class="line"><span class="comment">#https://kubecm.cloud/#/en-us/install</span></span><br><span class="line">kubectl krew install kc</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置环境变量.bash_profile</span></span><br><span class="line"><span class="built_in">alias</span> kc=<span class="string">&#x27;kubectl kc&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> kc=<span class="string">&#x27;kubectl kc&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ks=<span class="string">&#x27;kubectl kc switch &#x27;</span></span><br><span class="line"></span><br><span class="line">kc add -f test-shbt</span><br><span class="line"></span><br><span class="line">kc add -cf test-shbt.conf --context-name test-shbt</span><br><span class="line"></span><br><span class="line">kc list</span><br><span class="line"></span><br><span class="line">kc rename</span><br><span class="line"></span><br><span class="line">kc delete </span><br><span class="line"></span><br><span class="line">kc add -cf test-bjmd.conf --context-name  test-bjmd</span><br><span class="line"></span><br><span class="line">kc switch</span><br></pre></td></tr></table></figure>

<h2 id="五、安装node-shell"><a href="#五、安装node-shell" class="headerlink" title="五、安装node-shell"></a>五、安装node-shell</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#也可以使用debug</span></span><br><span class="line">kubectl debug node/&lt;node_name&gt; -it --image=swr.cn-north-4.myhuaweicloud.com/ddn-k8s/gcr.io/google-containers/busybox:latest -- sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#kubectl node-shell 的工作原理是通过 kubectl debug 在 目标 Node 上创建一个 nsenter 容器</span></span><br><span class="line">kubectl krew install node-shell</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查找并编辑二进制文件</span></span><br><span class="line"><span class="built_in">which</span> kubectl-node_shell</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改默认的镜像，改为国内源</span></span><br><span class="line"><span class="built_in">cat</span> ~/.krew/bin/kubectl-node_shell | grep -E <span class="string">&quot;docker.io/library/alpine:latest&quot;</span></span><br><span class="line">default_image=<span class="string">&quot;swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/library/alpine:latest&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行验证</span></span><br><span class="line">kubectl node-shell &lt;node_name&gt; -- sh -c <span class="string">&quot;ping baidu.com&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>kubeadm + containerd + calico 部署k8s 1.28</title>
    <url>/2024/11/25/kubeadm-containerd-calico-%E9%83%A8%E7%BD%B2k8s-1-28/</url>
    <content><![CDATA[<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><blockquote>
<p><a href="https://github.com/mingcheng/deploy-k8s-within-aliyun-mirror">https://github.com/mingcheng/deploy-k8s-within-aliyun-mirror</a></p>
</blockquote>
<h2 id="一、机器配置"><a href="#一、机器配置" class="headerlink" title="一、机器配置"></a>一、机器配置</h2><ul>
<li><strong>确保节点的mac地址和product_uuid的唯一性</strong></li>
<li><strong>每台主机不低于2GB 内存大小，CPU大于2核心</strong></li>
<li><strong>集群中的所有主机网络互通</strong></li>
</ul>
<table>
<thead>
<tr>
<th>角色</th>
<th>主机ip</th>
<th>配置</th>
<th>系统版本</th>
<th>内核版本</th>
</tr>
</thead>
<tbody><tr>
<td>k8s-master</td>
<td>11.123.248.100</td>
<td>4C 8G</td>
<td>Anolis OS release 8</td>
<td>5.10</td>
</tr>
<tr>
<td>k8s-node01</td>
<td>11.123.248.101</td>
<td>2C 4G</td>
<td>Anolis OS release 8</td>
<td>5.10</td>
</tr>
<tr>
<td>k8s-node02</td>
<td>11.123.248.102</td>
<td>2C 4G</td>
<td>Anolis OS release 8</td>
<td>5.10</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置主机名</span></span><br><span class="line"><span class="comment">#master节点</span></span><br><span class="line">hostnamectl set-hostname k8s-master</span><br><span class="line"></span><br><span class="line"><span class="comment">#node节点11.123.248.101</span></span><br><span class="line">hostnamectl set-hostname k8s-node01</span><br><span class="line"><span class="comment">#node节点11.123.248.102</span></span><br><span class="line">hostnamectl set-hostname k8s-node02</span><br></pre></td></tr></table></figure>

<h2 id="二、所有节点操作设置"><a href="#二、所有节点操作设置" class="headerlink" title="二、所有节点操作设置"></a>二、所有节点操作设置</h2><ul>
<li>通用安装内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置带时间的个性主机名（非必须）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PS1=&#x27;\[\e[37;1m\][\[\e[36;40m\]\t\[\e[32;40m\]\u\[\e[33;40m\]@\[\e[31;40m\]\h \[\e[34;40m\]\w\[\e[37;1m\]]\\$\[\e[m\]&#x27;&quot;</span> &gt;&gt;.bashrc</span><br><span class="line"><span class="built_in">source</span> .bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置hosts</span></span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; /etc/hosts &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">11.123.248.100  k8s-master</span></span><br><span class="line"><span class="string">11.123.248.101  k8s-node01</span></span><br><span class="line"><span class="string">11.123.243.102  k8s-node02</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭防火墙</span></span><br><span class="line">systemctl stop firewalld &amp;&amp; systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment">#永久禁用SElinux</span></span><br><span class="line">setenforce 0 </span><br><span class="line">sed -i <span class="string">&#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27;</span> /etc/selinux/config</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭swap</span></span><br><span class="line">swapoff -a &amp;&amp; sed -i <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加网桥过滤及内核转发配置文件，并使之生效</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1</span></span><br><span class="line"><span class="string">vm.swappiness = 0</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sysctl --system</span><br><span class="line"></span><br><span class="line"><span class="comment">#加载k8s和containerd所需的overlay和br_netfilter两个模块</span></span><br><span class="line">modprobe overlay</span><br><span class="line">modprobe br_netfilter</span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/modules-load.d/k8s.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">overlay	</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">lsmod | grep  -e br_netfilter -e overlay</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装ipvs模块，保证在节点重启后能自动加载所需模块---kube-proxy开启ipvs的前置条件</span></span><br><span class="line">yum install ipset ipvsadm -y</span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string">modprobe -- ip_vs</span></span><br><span class="line"><span class="string">modprobe -- ip_vs_rr</span></span><br><span class="line"><span class="string">modprobe -- ip_vs_wrr</span></span><br><span class="line"><span class="string">modprobe -- ip_vs_sh</span></span><br><span class="line"><span class="string">modprobe -- nf_conntrack</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用rpm安装containerd</span></span><br><span class="line">wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum list | grep containerd</span><br><span class="line">yum -y install containerd.io</span><br><span class="line"><span class="comment">#设置配置文件</span></span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br></pre></td></tr></table></figure>

<ul>
<li>修改containerd的配置文件：&#x2F;etc&#x2F;containerd&#x2F;config.toml</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#参考地址：</span></span><br><span class="line"><span class="comment">#https://github.com/mingcheng/deploy-k8s-within-aliyun-mirror/blob/master/README.md#containerd</span></span><br><span class="line"><span class="comment">#变更1，修改CgroupDriver为：systemd</span></span><br><span class="line">[plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.containerd.runtimes.runc.options]</span><br><span class="line">...</span><br><span class="line">SystemdCgroup = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#变更2,sandbox_image改镜像地址及版本</span></span><br><span class="line">[plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>]</span><br><span class="line">...</span><br><span class="line">sandbox_image = <span class="string">&quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#变更3，修改默认的runtime_type</span></span><br><span class="line">[plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.containerd.runtimes.runc]</span><br><span class="line">...</span><br><span class="line">runtime_type = <span class="string">&quot;io.containerd.runc.v2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#变更4,配置下载镜像</span></span><br><span class="line">[plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors]</span><br><span class="line">	[plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors.<span class="string">&quot;docker.io&quot;</span>]</span><br><span class="line">		endpoint = [<span class="string">&quot;https://nty7c4os.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">  [plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors.<span class="string">&quot;k8s.gcr.io&quot;</span>]</span><br><span class="line">		endpoint = [<span class="string">&quot;registry.aliyuncs.com/google_containers&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>重新启动containerd，安装runc</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#启动containerd</span></span><br><span class="line">systemctl <span class="built_in">enable</span> containerd</span><br><span class="line">systemctl restart containerd</span><br><span class="line">systemctl status containerd</span><br><span class="line">containerd --version</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载runc，注意：如果idc主机无法下载，可在别处下载，然后上传过来</span></span><br><span class="line">wget https://github.com/opencontainers/runc/releases/download/v1.1.12/runc.amd64</span><br><span class="line"><span class="built_in">mv</span> runc.amd64 /usr/sbin/runc &amp;&amp; <span class="built_in">chmod</span> +x /usr/sbin/runc &amp;&amp; runc -v</span><br><span class="line"></span><br><span class="line"><span class="comment">#增加阿里云的kubernetes源</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.28/rpm/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://mirrors.aliyun.com/kubernetes-new/core/stable/v1.28/rpm/repodata/repomd.xml.key</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment">#缓存元数据</span></span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看kubernetes源当前状态</span></span><br><span class="line">yum --showduplicate list kubeadm kubectl kublet</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装k8s组件，kubelet、kubeadm、kubectl</span></span><br><span class="line">yum install -y kubectl-1.28.12 kubelet-1.28.12 kubeadm-1.28.12 </span><br><span class="line"><span class="comment">#修改kubelet默认cgroup驱动</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/sysconfig/kubelet &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">KUBELET_EXTRA_ARGS=&quot;--cgroup-driver=systemd&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet --now</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装命令自动补全</span></span><br><span class="line">kubeadm completion bash &gt; /etc/bash_completion.d/kubeadm</span><br><span class="line">kubectl completion bash &gt; /etc/bash_completion.d/kubectl</span><br><span class="line"><span class="built_in">source</span> /etc/bash_completion.d/kubeadm</span><br><span class="line"><span class="built_in">source</span> /etc/bash_completion.d/kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置crictl配置</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/crictl.yaml &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">runtime-endpoint: unix:///var/run/containerd/containerd.sock</span></span><br><span class="line"><span class="string">image-endpoint: unix:///var/run/containerd/containerd.sock</span></span><br><span class="line"><span class="string">timeout: 10</span></span><br><span class="line"><span class="string">debug: true</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h2 id="三、master节点配置"><a href="#三、master节点配置" class="headerlink" title="三、master节点配置"></a>三、master节点配置</h2><ul>
<li>kubeadm 初始化集群操作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#1、拉取集群所需镜像</span></span><br><span class="line">kubeadm config images list</span><br><span class="line">kubeadm config images pull --image-repository registry.aliyuncs.com/google_containers</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、初始化集群，注意--pod-network-cidr配置与后续CNI所需配置的cidr一致</span></span><br><span class="line">kubeadm init --control-plane-endpoint <span class="variable">$k8s</span>-master:6443 \</span><br><span class="line">--kubernetes-version=v1.28.12 \</span><br><span class="line">--pod-network-cidr=172.16.0.0/16 \  </span><br><span class="line">--service-cidr=10.96.0.0/16 </span><br><span class="line">--service-dns-domain=cluster.local \</span><br><span class="line">--image-repository=registry.aliyuncs.com/google_containers \</span><br><span class="line">--cri-socket=unix:///run/containerd/containerd.sock \</span><br><span class="line">--upload-certs</span><br><span class="line"></span><br><span class="line"><span class="comment">#–image-repository：选择用于拉取镜像的镜像仓库（默认为“k8s.gcr.io” ）</span></span><br><span class="line"><span class="comment">#–kubernetes-version：选择特定的Kubernetes版本（默认为“stable-1”）</span></span><br><span class="line"><span class="comment">#–service-cidr：为服务的VIP指定使用的IP地址范围（默认为“10.96.0.0/12”）</span></span><br><span class="line"><span class="comment">#–pod-network-cidr：指定Pod网络的IP地址范围。如果设置，则将自动为每个节点分配CIDR。</span></span><br><span class="line"><span class="comment">#–control-plane-endpoint=xxx.xxx.xxx.xxx:6443 。指定api-server地址，如果是公网，最好指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出内容</span></span><br><span class="line"><span class="comment">#加入控制平面：</span></span><br><span class="line"><span class="comment"># kubeadm join 11.123.248.100:6443 --token 8e48x7.b7krn71bk2lkc4km \</span></span><br><span class="line"><span class="comment"># --discovery-token-ca-cert-hash sha256:67deea843bb9e43865a7c228eb364ee8659628ab43424fd3f6426002916ac817 \</span></span><br><span class="line"><span class="comment"># --control-plane --certificate-key 8ed465b862780ca5510e7439543fd0f70bc3bb3cb57441ea0a44b4b266c60805</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="comment">#node节点加入</span></span><br><span class="line"><span class="comment">#kubeadm join 11.123.248.100:6443 --token 8e48x7.b7krn71bk2lkc4km \</span></span><br><span class="line"><span class="comment">#--discovery-token-ca-cert-hash sha256:67deea843bb9e43865a7c228eb364ee8659628ab43424fd3f6426002916ac817</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3、拷贝配置</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line"><span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">kubectl get node</span><br><span class="line"></span><br><span class="line"><span class="comment">#tips:此时因没有安装CNI，集群master节点是NOTREADY状态</span></span><br><span class="line"><span class="comment">#检查具体出现问题的节点详情：</span></span><br><span class="line">kubectl describe node k8s-master</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查事件(Event)</span></span><br><span class="line">kubectl describe node k8s-master | grep -A 10 <span class="string">&#x27;Conditions:&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="四、node节点"><a href="#四、node节点" class="headerlink" title="四、node节点"></a>四、node节点</h2><ul>
<li>加入集群操作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#加入集群，可设置--cri-socket配置</span></span><br><span class="line">kubeadm <span class="built_in">join</span> 11.123.248.100:6443 --token 8e48x7.b7krn71bk2lkc4km \</span><br><span class="line">--cri-socket unix:///run/containerd/containerd.sock \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:67deea843bb9e43865a7c228eb364ee8659628ab43424fd3f6426002916ac817</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>将master节点&#x2F;root&#x2F;.kube&#x2F;config 拷贝至node节点&#x2F;root&#x2F;.kube&#x2F;config</li>
<li>tips</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#节点删除后，重新加入集群</span></span><br><span class="line"><span class="comment">#master节点删除</span></span><br><span class="line">kubectl delete node k8s-node01</span><br><span class="line"></span><br><span class="line"><span class="comment">#node节点操作</span></span><br><span class="line"><span class="comment">#1、停止kubelet/containerd--&gt;删除各配置文件--&gt;启动containerd/kubelet</span></span><br><span class="line">systemctl stop kubelet</span><br><span class="line">systemctl stop containerd</span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/cni/</span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/kubelet/*</span><br><span class="line"><span class="built_in">rm</span> -rf /etc/cni/</span><br><span class="line"><span class="built_in">rm</span> -f /etc/kubernetes/kubelet.conf</span><br><span class="line"><span class="built_in">rm</span> -f /etc/kubernetes/pki/ca.crt</span><br><span class="line">systemctl start containerd</span><br><span class="line">systemctl start kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、重新加入</span></span><br><span class="line">kubeadm <span class="built_in">join</span> 11.123.248.100:6443 --token 8e48x7.b7krn71bk2lkc4km \</span><br><span class="line">--cri-socket unix:///run/containerd/containerd.sock \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:67deea843bb9e43865a7c228eb364ee8659628ab43424fd3f6426002916ac817</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、master节点执行一下命令，获取加入指令：</span></span><br><span class="line">kubeadm token create --print-join-command</span><br></pre></td></tr></table></figure>

<h2 id="五、Calico安装参考"><a href="#五、Calico安装参考" class="headerlink" title="五、Calico安装参考"></a>五、Calico安装参考</h2><ul>
<li>步骤1</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装步骤：https://docs.tigera.io/calico/latest/getting-started/kubernetes/quickstart</span></span><br><span class="line"><span class="comment">#1、安装operator</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.0/manifests/tigera-operator.yaml</span><br><span class="line"><span class="comment">#2、下载自定义yaml配置，注意修改kubeadm init --pod-network-cidr变量对应的cidr</span></span><br><span class="line">wget https://raw.githubusercontent.com/projectcalico/calico/v3.28.0/manifests/custom-resources.yaml</span><br><span class="line"><span class="comment"># 可以通过 kubectl cluster-info dump | grep cidr 查看集群cidr配置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>步骤2：master及node节点均安装一下容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#镜像替换参考地址：</span></span><br><span class="line"><span class="comment">#https://docker.aityp.com/s/docker.io</span></span><br><span class="line"><span class="comment">#https://docker.aityp.com/r/docker.io/calico</span></span><br><span class="line"></span><br><span class="line">ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/pod2daemon-flexvol:v3.28.0</span><br><span class="line">ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/pod2daemon-flexvol:v3.28.0  docker.io/calico/pod2daemon-flexvol:v3.28.0</span><br><span class="line"></span><br><span class="line">ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/cni:v3.28.0</span><br><span class="line">ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/cni:v3.28.0  docker.io/calico/cni:v3.28.0</span><br><span class="line"></span><br><span class="line">ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/node:v3.28.0</span><br><span class="line">ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/node:v3.28.0  docker.io/calico/node:v3.28.0</span><br><span class="line"></span><br><span class="line">ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/apiserver:v3.28.0</span><br><span class="line">ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/apiserver:v3.28.0  docker.io/calico/apiserver:v3.28.0</span><br><span class="line"></span><br><span class="line">ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/kube-controllers:v3.28.0</span><br><span class="line">ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/kube-controllers:v3.28.0  docker.io/calico/kube-controllers:v3.28.0</span><br><span class="line"></span><br><span class="line">ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/typha:v3.28.0</span><br><span class="line">ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/typha:v3.28.0  docker.io/calico/typha:v3.28.0</span><br><span class="line"></span><br><span class="line">ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/node-driver-registrar:v3.28.0</span><br><span class="line">ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/node-driver-registrar:v3.28.0  docker.io/calico/node-driver-registrar:v3.28.0</span><br><span class="line"></span><br><span class="line">ctr images pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/csi:v3.28.0</span><br><span class="line">ctr images tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/calico/csi:v3.28.0  docker.io/calico/csi:v3.28.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>启动calico配置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置启动calico</span></span><br><span class="line">kubectl apply -f custom-resources.yaml</span><br><span class="line"></span><br><span class="line">kubectl get pods -o wide --all-namespaces</span><br><span class="line">或者</span><br><span class="line">watch kubectl get pods -n calico-system</span><br><span class="line"></span><br><span class="line"><span class="comment">#失败强制删除</span></span><br><span class="line">kubectl delete pod csi-node-driver-7rhsg -n calico-system --force</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查集群启动情况，ComponentStatus is deprecated in v1.19+</span></span><br><span class="line"><span class="comment">#kubectl get cs </span></span><br><span class="line"><span class="comment">#kubectl get ComponentStatus</span></span><br><span class="line">kubectl get --raw=<span class="string">&#x27;/readyz?verbose&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="六、集群启动信息"><a href="#六、集群启动信息" class="headerlink" title="六、集群启动信息"></a>六、集群启动信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl cluster-info</span><br><span class="line"></span><br><span class="line">kubectl get nodes -o wide</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>kubebuilder使用demo</title>
    <url>/2024/11/18/kubebuilder%E4%BD%BF%E7%94%A8demo/</url>
    <content><![CDATA[<p>  从头开始去构建一个 CRD 控制器并不容易，需要对 Kubernetes 的 API 有深入了解，并且 RBAC 集成、镜像构建、持续集成和部署等都需要很大工作量。为了解决这个问题，社区就推出了对应的简单易用的 Operator 框架，比较主流的是 kubebuilder 和 Operator Framework。</p>
<h2 id="一、创建项目并初始化"><a href="#一、创建项目并初始化" class="headerlink" title="一、创建项目并初始化"></a>一、创建项目并初始化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建go项目</span></span><br><span class="line"><span class="built_in">mkdir</span> lb</span><br><span class="line"><span class="built_in">cd</span> lb</span><br><span class="line">go mod init test.net</span><br><span class="line"></span><br><span class="line"><span class="comment">#设计好GVK表述，以下生成的的crd名为：loadbalances.network.k8s.test.net</span></span><br><span class="line">kubebuilder init --domain k8s.test.net</span><br><span class="line">kubebuilder create api --group network --version v1 --kind LoadBalance</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成crd, 该命令可以确保项目中的Kubernetes资源定义文件是最新的</span></span><br><span class="line">make manifests</span><br><span class="line"></span><br><span class="line"><span class="comment">#tips</span></span><br><span class="line"><span class="comment">#命名空间配置文件：config/default/kustomization.yaml</span></span><br></pre></td></tr></table></figure>

<h2 id="二、调试开发"><a href="#二、调试开发" class="headerlink" title="二、调试开发"></a>二、调试开发</h2><h3 id="①重点处理文件"><a href="#①重点处理文件" class="headerlink" title="①重点处理文件"></a>①重点处理文件</h3><ul>
<li>api&#x2F;v1alpha1&#x2F;loadbalance_types.go</li>
<li>internal&#x2F;controller&#x2F;loadbalance_controller.go</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#变更spec：</span></span><br><span class="line">vim api/v1alpha1/loadbalance_types.go</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">#关注 Reconcile 方法实现业务逻辑</span></span><br><span class="line">vim internal/controller/loadbalance_controller.go</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新生成crd等文件</span></span><br><span class="line">make manifests generate</span><br><span class="line"><span class="comment">#查看生成的yaml：</span></span><br><span class="line"><span class="built_in">ls</span> config/crd/bases/network.k8s.test.net_loadbalances.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装crd到k8s集群,这里用于kustomize</span></span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看crd是否安装成功</span></span><br><span class="line">kubectl get crd</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动controller</span></span><br><span class="line">make run</span><br></pre></td></tr></table></figure>

<h3 id="②另一终端验证"><a href="#②另一终端验证" class="headerlink" title="②另一终端验证"></a>②另一终端验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署cr</span></span><br><span class="line">kubectl apply -f config/samples/network_v1_loadbalance.yaml</span><br><span class="line"></span><br><span class="line">kubectl get loadbalance</span><br></pre></td></tr></table></figure>

<h3 id="③删除资源"><a href="#③删除资源" class="headerlink" title="③删除资源"></a>③删除资源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete loadbalance loadbalance-sample</span><br><span class="line"></span><br><span class="line"><span class="comment"># ctrl + c 停止程序,卸载crd</span></span><br><span class="line">make uninstall</span><br></pre></td></tr></table></figure>

<h2 id="三、构建镜像–-部署–-卸载部署"><a href="#三、构建镜像–-部署–-卸载部署" class="headerlink" title="三、构建镜像–&gt;部署–&gt;卸载部署"></a>三、构建镜像–&gt;部署–&gt;卸载部署</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、注意修改Dockfile镜像地址，可能无法拉取</span></span><br><span class="line">sed -i <span class="string">&#x27;s#golang:1.22#swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/library/golang:1.22.5#&#x27;</span> Dockerfile</span><br><span class="line">sed -i <span class="string">&#x27;s#gcr.io/distroless/static:nonroot#swr.cn-north-4.myhuaweicloud.com/ddn-k8s/gcr.io/distroless/static:nonroot#&#x27;</span> Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、开始构建镜像（root用户）</span></span><br><span class="line">make docker-build IMG=loadbalance/lb:0.0.1</span><br><span class="line"><span class="comment">#push 到远程仓库，先docker login</span></span><br><span class="line"><span class="comment">#make docker-build docker-push IMG=loadbalance/lb:0.0.1</span></span><br><span class="line">或者</span><br><span class="line">docker build -t loadbalance/lb:0.0.1 .</span><br><span class="line"><span class="comment">#docker push loadbalance/lb:0.0.1 xxxx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定构建平台</span></span><br><span class="line"><span class="comment">#make docker-buildx IMG=loadbalance/lb:0.0.1 PLATFORM=linux/amd64</span></span><br><span class="line"><span class="comment">#支持多种平台构建</span></span><br><span class="line"><span class="comment">#docker buildx build --platform linux/amd64,linux/arm64 -t loadbalance/lb:0.0.1 .</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看构建的镜像</span></span><br><span class="line"><span class="built_in">sudo</span> docker images</span><br><span class="line">REPOSITORY                  TAG               IMAGE ID       CREATED              SIZE</span><br><span class="line">loadbalance/lb              0.0.1             3d702a7b6e16   About a minute ago   72.1MB</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署到当前集群</span></span><br><span class="line">make deploy IMG=loadbalance/lb:0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#验证</span></span><br><span class="line">kubectl get svc,deploy,pod -n lb-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载部署</span></span><br><span class="line">make undeploy</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cronjob test</span><br><span class="line">https://github.com/kubernetes-sigs/kubebuilder/tree/master/docs/book/src/cronjob-tutorial/testdata/project</span><br><span class="line"></span><br><span class="line">https://github.com/kubernetes-sigs/kubebuilder/blob/master/docs/kubebuilder_annotation.md</span><br><span class="line">+[header]:[module]:[submodule]:[key-value elements]</span><br><span class="line"></span><br><span class="line">#云原生社区</span><br><span class="line">https://cloudnative.to/kubebuilder/</span><br><span class="line"></span><br><span class="line">#标记注释</span><br><span class="line">https://cloudpods.csdn.net/657812bcb8e5f01e1e449ece.html</span><br><span class="line"></span><br><span class="line">https://xie.infoq.cn/article/7a315f5168fda5e2e534ca406</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 官网例子</span><br><span class="line">https://github.com/kubernetes/sample-controller</span><br><span class="line">https://github.com/jetstack/kubebuilder-sample-controller</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>nsenter 与kubectl debug</title>
    <url>/2024/10/31/kubectl-debug%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="kubectl-debug"><a href="#kubectl-debug" class="headerlink" title="kubectl debug"></a><code>kubectl debug</code></h2><h3 id="一、常用命令"><a href="#一、常用命令" class="headerlink" title="一、常用命令"></a>一、常用命令</h3><ol>
<li><p><strong>调试现有容器</strong><br>调试某个正在运行的容器，附加一个新的调试容器：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl debug -it &lt;pod-name&gt; -n &lt;namespace&gt; --image swr.cn-north-4.myhuaweicloud.com/ddn-k8s/gcr.io/google-containers/busybox:latest --profile=netadmin --target=&lt;target-container-name&gt; -- sh</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-image</code>：指定调试容器的镜像（例如 <code>busybox</code> 或 <code>ubuntu</code>）。</li>
<li><code>-target=&lt;target-container-name&gt;</code>：指定调试的目标容器，便于访问容器内的文件系统和网络。</li>
</ul>
</li>
<li><p><strong>调试节点</strong><br>在指定节点上启动调试容器，用于节点本地调试：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl debug node/&lt;node-name&gt; -it --image=swr.cn-north-4.myhuaweicloud.com/ddn-k8s/gcr.io/google-containers/busybox:latest</span><br></pre></td></tr></table></figure>
<p> 该命令将会在指定的节点上运行一个临时容器，并附带节点的文件系统和环境。</p>
</li>
</ol>
<h3 id="二、删除调试容器"><a href="#二、删除调试容器" class="headerlink" title="二、删除调试容器"></a>二、删除调试容器</h3><ol>
<li><p><strong>手动删除调试容器</strong><br>调试完成后，通过以下命令删除调试产生的临时容器：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete pod &lt;pod-name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<p> 如果不想删除整个 Pod，可以只删除 Ephemeral Containers 的配置，但目前 Kubernetes 并不直接支持对 Ephemeral Containers 的单独删除（这是设计选择）。在这种情况下，通常需要删除整个 Pod 并重新创&gt;建。</p>
</li>
<li><p><strong>重启 Pod（删除后重建）</strong><br>对于不可变应用，可以考虑重启 Pod（删除原有 Pod，由控制器重新创建），以清理所有调试状态。</p>
</li>
</ol>
<hr>
<h2 id="nsenter"><a href="#nsenter" class="headerlink" title="nsenter"></a>nsenter</h2><p><code>nsenter</code> 是一个用于在 Linux 命名空间中执行命令的工具，可以让你进入其他进程的命名空间进行调试。与 <code>kubectl debug</code> 相比，<code>nsenter</code> 更加底层和灵活，但使用起来也稍显复杂。以下是使用 <code>nsenter</code> 的场景、操作步骤以及与 <code>kubectl debug</code> 的比较。</p>
<h3 id="一、使用-nsenter-的场景"><a href="#一、使用-nsenter-的场景" class="headerlink" title="一、使用 nsenter 的场景"></a>一、使用 <code>nsenter</code> 的场景</h3><ol>
<li><strong>底层访问</strong>：当需要深入到容器内的某些细节时，例如调试内核级别的问题或网络问题，<code>nsenter</code> 可以提供更直接的访问。</li>
<li><strong>没有 Kubelet 访问</strong>：在某些情况下，可能没有权限或无法通过 Kubernetes API 访问 Pod，这时可以直接在节点上使用 <code>nsenter</code>。</li>
<li><strong>特殊容器环境</strong>：对于某些特殊或自定义的容器环境，<code>kubectl debug</code> 可能无法满足需求，此时 <code>nsenter</code> 提供了更多的灵活性。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装：</span><br><span class="line">sudo apt-get install util-linux -y  # Ubuntu/Debian</span><br><span class="line">sudo yum install util-linux -y     # CentOS/Red Hat</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="二、nsenter-的操作步骤"><a href="#二、nsenter-的操作步骤" class="headerlink" title="二、nsenter 的操作步骤"></a>二、<code>nsenter</code> 的操作步骤</h3><ol>
<li><p><strong>找到容器的 PID</strong>：<br>使用 <code>docker ps</code> 或 <code>crictl ps</code> 命令找到目标容器的 PID。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect &lt;containerID&gt; | grep Pid</span><br><span class="line">crictl inspect &lt;containerID&gt; | grep Pid</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>nsenter</code> 进入命名空间</strong>：<br>使用找到的 PID 进入容器的命名空间。以下是一个例子：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入容器的挂载、UTS、IPC、网络和 PID 命名空间。</span></span><br><span class="line">nsenter --target &lt;pid&gt; --mount --uts --ipc --net --pid</span><br><span class="line">iptables -t nat -S</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入容器的网络命名空间</span></span><br><span class="line">nsenter -n -t &lt;pid&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进行调试</strong>：<br>进入容器后，你可以运行各种命令进行调试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#一些命令</span><br><span class="line">#进入网络命名空间 (--net)</span><br><span class="line">nsenter --net=/proc/&lt;pid&gt;/ns/net</span><br><span class="line">#查看网络接口：</span><br><span class="line">ip addr</span><br><span class="line"></span><br><span class="line">#查看路由表：</span><br><span class="line">ip route</span><br><span class="line"></span><br><span class="line">#检查 DNS 解析：</span><br><span class="line">cat /etc/resolv.conf</span><br><span class="line">nslookup &lt;hostname&gt;</span><br><span class="line"></span><br><span class="line">#查看 NAT 和防火墙规则：</span><br><span class="line">iptables -L -n -v</span><br><span class="line"></span><br><span class="line">#挂载命名空间 (--mnt)</span><br><span class="line">nsenter --mnt=/proc/&lt;pid&gt;/ns/mnt</span><br><span class="line"></span><br><span class="line">#检查磁盘使用情况：</span><br><span class="line">df -h</span><br><span class="line">du -sh &lt;path&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#多命名空间组合</span><br><span class="line">nsenter --net=/proc/&lt;pid&gt;/ns/net --mnt=/proc/&lt;pid&gt;/ns/mnt</span><br><span class="line"></span><br><span class="line">#排查后退出命名空间</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="nsenter-与-kubectl-debug-的比较"><a href="#nsenter-与-kubectl-debug-的比较" class="headerlink" title="nsenter 与 kubectl debug 的比较"></a><code>nsenter</code> 与 <code>kubectl debug</code> 的比较</h3><table>
<thead>
<tr>
<th>特性</th>
<th><code>nsenter</code></th>
<th><code>kubectl debug</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>灵活性</strong></td>
<td>高，支持任何 Linux 命名空间</td>
<td>主要针对 Kubernetes 的 Pod 和容器</td>
</tr>
<tr>
<td><strong>使用复杂度</strong></td>
<td>较高，需要手动找到 PID</td>
<td>较低，使用 Kubernetes API 进行操作</td>
</tr>
<tr>
<td><strong>环境依赖</strong></td>
<td>需要在节点上运行，依赖容器运行环境</td>
<td>依赖 Kubernetes 集群环境</td>
</tr>
<tr>
<td><strong>适用范围</strong></td>
<td>通用，可用于任何容器运行时</td>
<td>专为 Kubernetes 设计</td>
</tr>
<tr>
<td><strong>调试深度</strong></td>
<td>深入，直接与宿主机交互</td>
<td>通过添加临时容器进行调试</td>
</tr>
<tr>
<td><strong>清理操作</strong></td>
<td>手动清理，退出命名空间即可</td>
<td>自动清理 Ephemeral Containers</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>使用 <code>nsenter</code> 适合需要底层访问和灵活性的调试场景，但操作较为复杂。</li>
<li><code>kubectl debug</code> 提供了简单易用的界面，适合日常容器调试，尤其是在 Kubernetes 环境中。</li>
</ul>
<p>根据具体需求选择合适的工具进行调试。</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>kubectl 相关脚本</title>
    <url>/2024/11/13/kubectl-%E7%9B%B8%E5%85%B3%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="统计node上pod数量"><a href="#统计node上pod数量" class="headerlink" title="统计node上pod数量"></a>统计node上pod数量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for node in $(kubectl get nodes -o name | egrep -v &quot;docker01|docker23|docker08|docker15&quot;); do</span><br><span class="line">  echo &quot;$node: $(kubectl get pods -n wdfwd --field-selector spec.nodeName=$&#123;node##*/&#125; --no-headers | wc -l) Pods&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="删除处理Terminating的pod"><a href="#删除处理Terminating的pod" class="headerlink" title="删除处理Terminating的pod"></a>删除处理Terminating的pod</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pods --all-namespaces | grep Terminating | while read line; do</span><br><span class="line">  pod_name=$(echo $line | awk &#x27;&#123;print $2&#125;&#x27; ) \</span><br><span class="line">  name_space=$(echo $line | awk &#x27;&#123;print $1&#125;&#x27; ); \</span><br><span class="line">  kubectl delete pods $pod_name -n $name_space --grace-period=0 --force</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="查看当前集群所有pod状态"><a href="#查看当前集群所有pod状态" class="headerlink" title="查看当前集群所有pod状态"></a>查看当前集群所有pod状态</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k get pod -A | awk &#x27;&#123;print $4&#125;&#x27; | sort | uniq -c | sort -rn</span><br></pre></td></tr></table></figure>

<h2 id="统计制定命名空间下pod的镜像、环境变量、执行参数"><a href="#统计制定命名空间下pod的镜像、环境变量、执行参数" class="headerlink" title="统计制定命名空间下pod的镜像、环境变量、执行参数"></a>统计制定命名空间下pod的镜像、环境变量、执行参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 定义要统计的命名空间，可以自行修改或添加</span><br><span class="line">NAMESPACES=(&quot;default&quot; &quot;kube-system&quot;) </span><br><span class="line"></span><br><span class="line"># 遍历每个命名空间</span><br><span class="line">for ns in &quot;$&#123;NAMESPACES[@]&#125;&quot;; do</span><br><span class="line">  echo &quot;命名空间: $ns&quot;</span><br><span class="line">  echo &quot;===============================&quot;</span><br><span class="line"></span><br><span class="line">  # 获取当前命名空间中的所有Pod信息</span><br><span class="line">  kubectl get pods -n &quot;$ns&quot; -o json | jq -c &#x27;.items[]&#x27; | while read -r pod; do</span><br><span class="line">    pod_name=$(echo &quot;$pod&quot; | jq -r &#x27;.metadata.name&#x27;)</span><br><span class="line">    echo &quot;Pod: $pod_name&quot;</span><br><span class="line">    echo &quot;-------------------&quot;</span><br><span class="line"></span><br><span class="line">    # 获取Pod中的容器列表</span><br><span class="line">    echo &quot;$pod&quot; | jq -c &#x27;.spec.containers[]&#x27; | while read -r container; do</span><br><span class="line">      container_name=$(echo &quot;$container&quot; | jq -r &#x27;.name&#x27;)</span><br><span class="line">      image=$(echo &quot;$container&quot; | jq -r &#x27;.image&#x27;)</span><br><span class="line"></span><br><span class="line">      echo &quot;  容器名: $container_name&quot;</span><br><span class="line">      echo &quot;  镜像: $image&quot;</span><br><span class="line"></span><br><span class="line">      # 获取环境变量</span><br><span class="line">      echo &quot;  环境变量:&quot;</span><br><span class="line">      envs=$(echo &quot;$container&quot; | jq -c &#x27;.env[]?&#x27;)</span><br><span class="line">      if [[ -z &quot;$envs&quot; ]]; then</span><br><span class="line">        echo &quot;    无&quot;</span><br><span class="line">      else</span><br><span class="line">        echo &quot;$envs&quot; | while read -r env; do</span><br><span class="line">          env_name=$(echo &quot;$env&quot; | jq -r &#x27;.name&#x27;)</span><br><span class="line">          env_value=$(echo &quot;$env&quot; | jq -r &#x27;.value // empty&#x27;)</span><br><span class="line">          value_from=$(echo &quot;$env&quot; | jq -r &#x27;.valueFrom // empty&#x27;)</span><br><span class="line"></span><br><span class="line">          if [[ -n &quot;$env_value&quot; ]]; then</span><br><span class="line">            echo &quot;    $env_name: $env_value&quot;</span><br><span class="line">          elif [[ -n &quot;$value_from&quot; ]]; then</span><br><span class="line">            # 处理 valueFrom 来源信息</span><br><span class="line">            config_map_ref=$(echo &quot;$env&quot; | jq -r &#x27;.valueFrom.configMapKeyRef.name // empty&#x27;)</span><br><span class="line">            secret_ref=$(echo &quot;$env&quot; | jq -r &#x27;.valueFrom.secretKeyRef.name // empty&#x27;)</span><br><span class="line">            field_ref=$(echo &quot;$env&quot; | jq -r &#x27;.valueFrom.fieldRef.fieldPath // empty&#x27;)</span><br><span class="line">            </span><br><span class="line">            if [[ -n &quot;$config_map_ref&quot; ]]; then</span><br><span class="line">              echo &quot;    $env_name (from ConfigMap: $config_map_ref)&quot;</span><br><span class="line">            elif [[ -n &quot;$secret_ref&quot; ]]; then</span><br><span class="line">              echo &quot;    $env_name (from Secret: $secret_ref)&quot;</span><br><span class="line">            elif [[ -n &quot;$field_ref&quot; ]]; then</span><br><span class="line">              echo &quot;    $env_name (from FieldRef: $field_ref)&quot;</span><br><span class="line">            else</span><br><span class="line">              echo &quot;    $env_name: 未知来源&quot;</span><br><span class="line">            fi</span><br><span class="line">          fi</span><br><span class="line">        done</span><br><span class="line">      fi</span><br><span class="line"></span><br><span class="line">      # 获取执行参数</span><br><span class="line">      echo &quot;  执行参数:&quot;</span><br><span class="line">      args=$(echo &quot;$container&quot; | jq -c &#x27;.args // []&#x27;)</span><br><span class="line">      if [[ &quot;$args&quot; == &quot;[]&quot; ]]; then</span><br><span class="line">        echo &quot;    无&quot;</span><br><span class="line">      else</span><br><span class="line">        echo &quot;$args&quot; | jq -r &#x27;.[] | &quot;    \(. // &quot;null&quot;)&quot;&#x27;</span><br><span class="line">      fi</span><br><span class="line"></span><br><span class="line">      echo &quot;-------------------&quot;</span><br><span class="line">    done</span><br><span class="line">    echo &quot;&quot;</span><br><span class="line">  done</span><br><span class="line">  echo &quot;===============================&quot;</span><br><span class="line">  echo &quot;&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>linux network相关命令</title>
    <url>/2024/08/23/linux%20network%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="了解节点网络拓扑的几种工具和方法："><a href="#了解节点网络拓扑的几种工具和方法：" class="headerlink" title="了解节点网络拓扑的几种工具和方法："></a>了解节点网络拓扑的几种工具和方法：</h2><h3 id="1-ip-命令"><a href="#1-ip-命令" class="headerlink" title="1. ip 命令"></a>1. <strong><code>ip</code> 命令</strong></h3><p><code>ip</code> 命令是一个功能强大的网络工具，通常用于查看和管理网络接口、路由表、策略路由和隧道。</p>
<ul>
<li><p><strong>查看网络接口和IP地址：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看路由表：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip route show</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看邻居（ARP 表）：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip neigh show</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-netstat-或-ss-命令"><a href="#2-netstat-或-ss-命令" class="headerlink" title="2. netstat 或 ss 命令"></a>2. <strong><code>netstat</code> 或 <code>ss</code> 命令</strong></h3><p><code>netstat</code> 和 <code>ss</code> 命令用于显示网络连接、路由表、接口统计信息和多播成员信息。</p>
<ul>
<li><p><strong>netstat使用</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看所有网络连接</span></span><br><span class="line">netstat -tuln</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看路由表</span></span><br><span class="line">netstat -rn</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">ip route show</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看网络接口统计信息</span></span><br><span class="line">netstat -i</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ss应用：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ss -tuln</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看进程使用的套接字信息</span></span><br><span class="line">ss -ptan</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-nmap"><a href="#3-nmap" class="headerlink" title="3. nmap"></a>3. <strong><code>nmap</code></strong></h3><p><code>nmap</code> 是一个强大的网络扫描工具，通常用于网络发现和安全审计。它可以扫描网络并获取有关局域网中其他设备的信息。</p>
<ul>
<li><p><strong>扫描整个子网中的活跃设备：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.1.0/24</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取详细的主机和服务信息：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -A 192.168.1.1</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-traceroute"><a href="#4-traceroute" class="headerlink" title="4. traceroute"></a>4. <strong><code>traceroute</code></strong></h3><p><code>traceroute</code> 命令用于跟踪数据包在网络中的路径，帮助识别网络路径和延迟情况。</p>
<ul>
<li><strong>跟踪到目标主机的路由：</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">traceroute example.com</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-arp-scan"><a href="#5-arp-scan" class="headerlink" title="5. arp-scan"></a>5. <strong><code>arp-scan</code></strong></h3><p><code>arp-scan</code> 是一个网络发现工具，用于快速扫描局域网中的设备。</p>
<ul>
<li><strong>扫描整个子网中的设备：</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp-scan -l</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-ifconfig-和-route"><a href="#6-ifconfig-和-route" class="headerlink" title="6. ifconfig 和 route"></a>6. <strong><code>ifconfig</code> 和 <code>route</code></strong></h3><p>虽然已经被 <code>ip</code> 命令取代，但在某些旧系统上依然可以使用。</p>
<ul>
<li><p><strong>查看网络接口：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看路由表：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-ethtool"><a href="#7-ethtool" class="headerlink" title="7. ethtool"></a>7. <strong><code>ethtool</code></strong></h3><p><code>ethtool</code> 用于查询和设置以太网设备参数，可以获取接口的详细信息。</p>
<ul>
<li><strong>查看网卡详细信息：</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ethtool eth0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-nmcli"><a href="#8-nmcli" class="headerlink" title="8. nmcli"></a>8. <strong><code>nmcli</code></strong></h3><p><code>nmcli</code> 是 NetworkManager 提供的命令行工具，用于查看和管理网络连接。</p>
<ul>
<li><p><strong>查看所有网络连接：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli connection show</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看设备状态：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli device status</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-bmon"><a href="#9-bmon" class="headerlink" title="9. bmon"></a>9. <strong><code>bmon</code></strong></h3><p><code>bmon</code> 是一个带有图形界面的带宽监控和诊断工具，用于实时监控网络流量。</p>
<ul>
<li><strong>启动 <code>bmon</code> 监控网络流量：</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bmon</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-iptraf-ng"><a href="#10-iptraf-ng" class="headerlink" title="10. iptraf-ng"></a>10. <strong><code>iptraf-ng</code></strong></h3><p><code>iptraf-ng</code> 是一个基于终端的实时网络监控工具，能够监控网络流量和连接。</p>
<ul>
<li><strong>启动 <code>iptraf-ng</code> 监控：</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装</span></span><br><span class="line">yum search iptraf</span><br><span class="line">yum install -y iptraf-ng </span><br><span class="line"></span><br><span class="line">iptraf-ng</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入X视图模式后的统计界面</span></span><br><span class="line">iptraf-ng -d eth0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="11-tcping"><a href="#11-tcping" class="headerlink" title="11. tcping"></a>11. <strong><code>tcping</code></strong></h3><ul>
<li><p><strong>TCPing</strong>：基于 TCP 协议，通过三次握手连接指定端口进行探测。如果目标主机的应用程序未能及时响应或端口临时不可用，会显示为失败。</p>
</li>
<li><p><strong>Ping</strong>：基于 ICMP 协议（Internet Control Message Protocol），直接探测网络层连接性。如果目标主机的网络栈正常运行，但应用层服务存在问题，Ping 仍可能显示为正常。</p>
</li>
<li><p>TCPing 针对具体的服务端口（如 23333）测试，如果目标服务存在连接限制（如最大连接数、超时设置），可能会导致 TCPing 丢包。</p>
</li>
<li><p>Ping 不涉及具体的服务端口，仅测试目标主机的网络连通性。</p>
</li>
<li><p>如果目标主机的服务（监听 23333 端口）处理压力大，可能会导致部分连接请求（TCPing 探测）未能响应。</p>
</li>
<li><p>Ping 使用较少的资源和处理能力，因此即使服务端性能有限，Ping 的结果也可能保持稳定。</p>
</li>
<li><p>防火墙可能对 ICMP 流量和 TCP 流量设置不同的策略。例如：</p>
<ul>
<li>放行 ICMP 流量，但限制指定端口的 TCP 流量。</li>
<li>对高频 TCP 请求（如 TCPing）触发限速或阻断。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="如何进一步查看网络情况"><a href="#如何进一步查看网络情况" class="headerlink" title="如何进一步查看网络情况"></a><strong>如何进一步查看网络情况</strong></h3><p>为了更深入地分析，建议从以下几方面入手：</p>
<h4 id="1-捕获流量数据"><a href="#1-捕获流量数据" class="headerlink" title="1. 捕获流量数据"></a><strong>1. 捕获流量数据</strong></h4><p>使用 <code>tcpdump</code> 或 Wireshark 捕获目标端口的流量，查看失败的 TCP 探测对应的包状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth0 host 10.100.15.200 and port 3333 -w tcping_capture.pcap</span><br></pre></td></tr></table></figure>
<p>在 Wireshark 中分析是否存在 TCP 重传、RST 包或服务端的延迟响应。</p>
<h4 id="2-检查服务端状态"><a href="#2-检查服务端状态" class="headerlink" title="2. 检查服务端状态"></a><strong>2. 检查服务端状态</strong></h4><p>在目标主机上，检查监听端口 <code>3333</code> 的服务状态：</p>
<ul>
<li>确认是否达到连接数限制：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep 3333</span><br></pre></td></tr></table></figure></li>
<li>查看服务日志中是否有报错或超时。</li>
</ul>
<h4 id="3-路由与网络层分析"><a href="#3-路由与网络层分析" class="headerlink" title="3. 路由与网络层分析"></a><strong>3. 路由与网络层分析</strong></h4><ul>
<li><strong>Traceroute</strong>：检查到目标的路由路径，是否有某些节点导致了延迟或丢包。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">traceroute 10.100.15.200</span><br></pre></td></tr></table></figure></li>
<li><strong>MTR</strong>：结合 ICMP 和 TCP 路由信息，实时监控路径稳定性。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mtr -r 10.100.15.200</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-检查防火墙配置"><a href="#4-检查防火墙配置" class="headerlink" title="4. 检查防火墙配置"></a><strong>4. 检查防火墙配置</strong></h4><p>在客户端和服务端，分别检查防火墙或安全策略配置：</p>
<ul>
<li>确认是否对 <code>23333</code> 端口流量有限制（如速率限制）。</li>
<li>调整防火墙规则，允许更多并发连接。</li>
</ul>
<h4 id="5-测试其他协议"><a href="#5-测试其他协议" class="headerlink" title="5. 测试其他协议"></a><strong>5. 测试其他协议</strong></h4><p>对比使用其他协议（如 UDP）进行测试，以进一步排除不同协议栈可能的问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf -c 10.100.15.200 -p 3333</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="问题排查与解决步骤"><a href="#问题排查与解决步骤" class="headerlink" title="问题排查与解决步骤"></a><strong>问题排查与解决步骤</strong></h3><table>
<thead>
<tr>
<th>步骤</th>
<th>操作方法</th>
<th>预期结果与意义</th>
</tr>
</thead>
<tbody><tr>
<td>检查服务端口状态</td>
<td>使用 <code>netstat</code> 检查端口占用和连接状态。</td>
<td>确认服务端是否超出连接限制，是否存在监听问题。</td>
</tr>
<tr>
<td>捕获流量分析</td>
<td>使用 <code>tcpdump</code> 或 Wireshark 捕获流量，分析是否存在超时、RST 或重传包。</td>
<td>确认丢包原因是由网络波动还是服务处理延迟引起。</td>
</tr>
<tr>
<td>路由与路径检查</td>
<td>使用 <code>traceroute</code> 和 <code>mtr</code> 检查路径中的节点性能与稳定性。</td>
<td>确认是否存在路径中某个节点引起的延迟或丢包问题。</td>
</tr>
<tr>
<td>服务端日志检查</td>
<td>查看目标服务的运行日志，关注超时、拒绝连接等问题。</td>
<td>确认是否服务处理能力不足或负载高导致的连接问题。</td>
</tr>
<tr>
<td>调整 TCP 设置</td>
<td>增大 TCP 超时、发送&#x2F;接收窗口大小，优化服务端的连接队列。</td>
<td>降低瞬时丢包率对应用的影响，提高吞吐量。</td>
</tr>
</tbody></table>
<p>通过上述分析，结合抓包与服务端日志，应该能定位到 TCPing 丢包的具体原因，并制定解决方案。</p>
<h2 id="相关命令安装"><a href="#相关命令安装" class="headerlink" title="相关命令安装"></a>相关命令安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y iperf3 ethtool bc net-tools sysstat hwloc hwloc-gui iptraf-ng stress-ng</span><br><span class="line">#压测CPU、内存</span><br><span class="line">stress-ng --cpu 36 --cpu-method all --timeout 0</span><br><span class="line">stress-ng --vm 8 --vm-bytes 80G --timeout 0</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>linux 安装 glances</title>
    <url>/2024/08/22/linux-%E5%AE%89%E8%A3%85-glances/</url>
    <content><![CDATA[<h2 id="linux-安装-glances"><a href="#linux-安装-glances" class="headerlink" title="linux 安装 glances"></a>linux 安装 glances</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install ncurses-devel -y</span><br><span class="line"></span><br><span class="line">#安装3.8以上的python环境</span><br><span class="line">pyenv install 3.12.2</span><br><span class="line"></span><br><span class="line">#验证安装模块</span><br><span class="line">python -c &quot;import curses; print(&#x27;curses module installed successfully&#x27;)&quot;</span><br><span class="line"></span><br><span class="line"># 安装需求包</span><br><span class="line">pip install fastapi</span><br><span class="line">pip install uvicorn</span><br><span class="line">pip install jinja2</span><br><span class="line"></span><br><span class="line">#安装glances</span><br><span class="line">pip install --upgrade glances</span><br><span class="line"></span><br><span class="line">#查看安装位置</span><br><span class="line">whereis glances</span><br><span class="line"></span><br><span class="line">#配置环境变量(vim .bashrc)</span><br><span class="line">alias glances=&#x27;/root/.pyenv/shims/glances  &#x27;</span><br><span class="line"></span><br><span class="line">#启动</span><br><span class="line">glances</span><br><span class="line">#网页查看</span><br><span class="line">glances -w</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux 工具</title>
    <url>/2024/10/24/linux-%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li>yq</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#https://github.com/mikefarah/yq/releases</span></span><br><span class="line">wget https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar vxf yq_linux_amd64.tar.gz ./</span><br><span class="line"><span class="built_in">mv</span> ./yq_linux_amd64 /usr/local/bin/yq</span><br></pre></td></tr></table></figure>

<h2 id="ping加时间戳"><a href="#ping加时间戳" class="headerlink" title="ping加时间戳"></a>ping加时间戳</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># https://www.wlbcoder.com/cn/2020/08/experience-in-shell-programming/</span><br><span class="line"></span><br><span class="line">yum -y install epel-release</span><br><span class="line">--------------------------</span><br><span class="line">#如果安装失败</span><br><span class="line"># Step 1. 安装 EPEL8 仓库</span><br><span class="line">yum install -y https://mirrors.aliyun.com/epel/epel-release-latest-8.noarch.rpm</span><br><span class="line"></span><br><span class="line"># Step 2. 列出仓库</span><br><span class="line">yum repolist | grep epel</span><br><span class="line"></span><br><span class="line"># Step 3. 更新缓存</span><br><span class="line">yum makecache</span><br><span class="line"></span><br><span class="line"># Step 4. 安装 dnsperf</span><br><span class="line">yum install -y dnsperf</span><br><span class="line">--------------------------</span><br><span class="line"></span><br><span class="line">yum -y install moreutils</span><br><span class="line">ping baidu.com | ts &#x27;[%Y-%m-%d %H:%M:%S]&#x27;</span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line">ping baidu.com | awk &#x27;&#123; print strftime(&quot;%Y.%m.%d %H:%M:%S&quot;,systime())&quot;\t&quot; $0; fflush() &#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pstree -asp `echo $$`</span><br><span class="line"></span><br><span class="line">systemctl status sshd</span><br><span class="line"></span><br><span class="line">pstree -asp &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<h2 id="script用法-输出内容到文件"><a href="#script用法-输出内容到文件" class="headerlink" title="script用法(输出内容到文件)"></a>script用法(输出内容到文件)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">script -q image-info.txt</span><br><span class="line">cat /etc/os-release</span><br><span class="line">uname -r</span><br><span class="line">cat /etc/resolv.conf</span><br><span class="line">cat /etc/docker/daemon.json</span><br><span class="line">rpm -qa | grep -E &quot;docker|docker-compose|telnet|nslookup|toa|tree|jq&quot; | sort</span><br><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">docker version</span><br><span class="line">systemctl is-enabled docker</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看依赖</span><br><span class="line">rpm -qpR docker-ce-26.1.3-1.el8.x86_64.rpm</span><br><span class="line"></span><br><span class="line">#查询软件包的详细信息</span><br><span class="line">rpm -qi xxx</span><br><span class="line"></span><br><span class="line">#查询未安装软件包的详细信息</span><br><span class="line">rpm -qip 包全名</span><br><span class="line"></span><br><span class="line">yum deplist xxx</span><br></pre></td></tr></table></figure>

<h2 id="端口转发代理"><a href="#端口转发代理" class="headerlink" title="端口转发代理"></a>端口转发代理</h2><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置代理，从本机端口转发主机A</span><br><span class="line">ssh -f -N -g -L 0.0.0.0:8080:&lt;A_HOST_IP&gt;:80 -L 0.0.0.0:8443:&lt;A_HOST_IP&gt;:443 root@&lt;A_HOST_IP&gt;</span><br></pre></td></tr></table></figure>
<h3 id="iptables（简单的端口映射，iptables-是最轻量级的方案）"><a href="#iptables（简单的端口映射，iptables-是最轻量级的方案）" class="headerlink" title="iptables（简单的端口映射，iptables 是最轻量级的方案）"></a>iptables（简单的端口映射，iptables 是最轻量级的方案）</h3><p>假设</p>
<ul>
<li>B_HOST 是执行 ssh -L 的机器。</li>
<li>A_HOST_IP 是远程目标机器（你要转发流量到这里）。</li>
<li>B_HOST 监听 8080 和 8443 端口，并将流量转发到 A_HOST_IP 的 80 和 443 端口。</li>
</ul>
<p>配置 iptables 规则,在 B_HOST 上执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启 IP 转发（如果未启用）</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">sysctl -w net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line"># 允许将 8080 端口的流量转发到 A_HOST_IP:80</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination &lt;A_HOST_IP&gt;:80</span><br><span class="line"></span><br><span class="line"># 允许将 8443 端口的流量转发到 A_HOST_IP:443</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 8443 -j DNAT --to-destination &lt;A_HOST_IP&gt;:443</span><br><span class="line"></span><br><span class="line"># 允许服务器本身的流量也能转发</span><br><span class="line">iptables -t nat -A OUTPUT -p tcp --dport 8080 -j DNAT --to-destination &lt;A_HOST_IP&gt;:80</span><br><span class="line">iptables -t nat -A OUTPUT -p tcp --dport 8443 -j DNAT --to-destination &lt;A_HOST_IP&gt;:443</span><br><span class="line"></span><br><span class="line"># 伪装 SNAT，保证返回数据包正确回到源客户端</span><br><span class="line">iptables -t nat -A POSTROUTING -p tcp -d &lt;A_HOST_IP&gt; --dport 80 -j MASQUERADE</span><br><span class="line">iptables -t nat -A POSTROUTING -p tcp -d &lt;A_HOST_IP&gt; --dport 443 -j MASQUERADE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#持久化操作</span><br><span class="line">yum install -y iptables-services</span><br><span class="line">systemctl enable iptables</span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure>
<h3 id="nginx（如需要处理-HTTP-HTTPS，如-修改请求头、做负载均衡、SSL-终止，nginx-合适）"><a href="#nginx（如需要处理-HTTP-HTTPS，如-修改请求头、做负载均衡、SSL-终止，nginx-合适）" class="headerlink" title="nginx（如需要处理 HTTP&#x2F;HTTPS，如 修改请求头、做负载均衡、SSL 终止，nginx 合适）"></a>nginx（如需要处理 HTTP&#x2F;HTTPS，如 修改请求头、做负载均衡、SSL 终止，nginx 合适）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置 nginx,编辑 /etc/nginx/nginx.conf 或 /etc/nginx/conf.d/proxy.conf，添加以下内容：</span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://&lt;A_HOST_IP&gt;:80;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8443 ssl;</span><br><span class="line">    ssl_certificate /etc/nginx/cert.pem;  # 需要有效的 SSL 证书</span><br><span class="line">    ssl_certificate_key /etc/nginx/cert.key;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass https://&lt;A_HOST_IP&gt;:443;</span><br><span class="line">        proxy_ssl_verify off;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 重启nginx</span><br><span class="line">systemctl restart nginx</span><br><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure>


<h2 id="find-grep-xargs"><a href="#find-grep-xargs" class="headerlink" title="find&#x2F;grep&#x2F;xargs"></a>find&#x2F;grep&#x2F;xargs</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/UQjMicPWCXSZ6I2XY3kvLw</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="大文件切割机查询"><a href="#大文件切割机查询" class="headerlink" title="大文件切割机查询"></a>大文件切割机查询</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#切割</span><br><span class="line">1、普通文件：</span><br><span class="line">按大小切</span><br><span class="line">split -b 10k third.yanyingapi.log.20240122 -d -a 3 yanying_split_size</span><br><span class="line"></span><br><span class="line">按行数切</span><br><span class="line">split -l 10000 third.yanyingapi.log.20240122 -d -a 3 yanying_split_size</span><br><span class="line"></span><br><span class="line">2、压缩文件：使用管道符“|”注意使用“-”代替文件名</span><br><span class="line">1、按行切割</span><br><span class="line">less third.yanyingapi.log.20240122.gz | split -l 10000000 - -d -a 3 yanying_20240122_line</span><br><span class="line"></span><br><span class="line">2、按文件大小切割</span><br><span class="line">less third.yanyingapi.log.20240122.gz | split -b 400M - -d -a 3 yanying_20240122_size</span><br><span class="line"></span><br><span class="line">#sed截取一定时段的日志</span><br><span class="line">注意事项：</span><br><span class="line">(1)开始时间如果在文件中不存在，则查不到数据</span><br><span class="line">(2)可以不具体到秒，模糊查询，例如 09:35：这种</span><br><span class="line"></span><br><span class="line">1、按照模糊时间</span><br><span class="line">sed -n &#x27;/2024-01-24 18:38:/,/2024-01-24 18:44:/p&#x27; sql.query.log.20240124 &gt; test.log</span><br><span class="line"></span><br><span class="line">2、按照正则，不知道具体时间，可以使用正则表达式来查询</span><br><span class="line">sed -n &#x27;/2024-01-24 18:[0-3][0-6]/p&#x27; sql.query.log.20240124 &gt; test.log</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="ssh端口转发"><a href="#ssh端口转发" class="headerlink" title="ssh端口转发"></a>ssh端口转发</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -f -N -g -L 0.0.0.0:8080:11.10.10.10:80 -L 0.0.0.0:8443:11.10.10.10:443 root@11.10.10.10</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux性能问题排查指令</title>
    <url>/2025/01/08/linux%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="启动时间相关"><a href="#启动时间相关" class="headerlink" title="启动时间相关"></a>启动时间相关</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">w</span><br><span class="line">uptime</span><br><span class="line">who -b</span><br><span class="line">last reboot</span><br><span class="line">date -d &quot;`cut -f1 -d. /proc/uptime` seconds ago&quot;</span><br></pre></td></tr></table></figure>

<h2 id="主机性能指标监控与分析指南"><a href="#主机性能指标监控与分析指南" class="headerlink" title="主机性能指标监控与分析指南"></a><strong>主机性能指标监控与分析指南</strong></h2><blockquote>
<p><a href="https://blog.csdn.net/u010420283/article/details/114502674">https://blog.csdn.net/u010420283/article/details/114502674</a></p>
</blockquote>
<h4 id="1-CPU-性能监控"><a href="#1-CPU-性能监控" class="headerlink" title="1. CPU 性能监控"></a><strong>1. CPU 性能监控</strong></h4><table>
<thead>
<tr>
<th><strong>命令&#x2F;操作</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>top 内快捷键</strong></td>
<td></td>
</tr>
<tr>
<td><code>1</code></td>
<td>显示每个逻辑 CPU 的使用情况。</td>
</tr>
<tr>
<td><code>P</code></td>
<td>按 CPU 使用率排序。</td>
</tr>
<tr>
<td><code>T</code></td>
<td>按运行时间排序。</td>
</tr>
<tr>
<td><code>N</code></td>
<td>按 PID 排序。</td>
</tr>
<tr>
<td><code>i</code></td>
<td>过滤掉空闲进程。</td>
</tr>
<tr>
<td><code>u</code> + 用户名</td>
<td>仅显示指定用户的进程。</td>
</tr>
<tr>
<td><code>f</code> + <code>s</code> + <code>ESC</code></td>
<td>自定义列排序（按列名选择）。</td>
</tr>
<tr>
<td><code>x</code></td>
<td>高亮排序列。</td>
</tr>
<tr>
<td><code>mpstat -P ALL</code></td>
<td>显示每个 CPU 核心的详细使用情况。</td>
</tr>
<tr>
<td><code>sar -P ALL</code></td>
<td>查看每个 CPU 核的使用情况，支持历史数据分析。</td>
</tr>
<tr>
<td><strong>线程查看</strong></td>
<td></td>
</tr>
<tr>
<td><code>top -Hp &lt;PID&gt;</code></td>
<td>查看某进程的线程使用情况。</td>
</tr>
<tr>
<td><code>ps -Tp &lt;PID&gt;</code></td>
<td>查看某进程的线程列表。</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-内存性能监控"><a href="#2-内存性能监控" class="headerlink" title="2. 内存性能监控"></a><strong>2. 内存性能监控</strong></h4><table>
<thead>
<tr>
<th><strong>命令&#x2F;操作</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>free -m</code></td>
<td>查看系统内存使用情况（单位 MB）。</td>
</tr>
<tr>
<td><code>vmstat</code></td>
<td>显示内存、进程、CPU 的综合统计信息。</td>
</tr>
<tr>
<td><code>top</code> 按键 <code>M</code></td>
<td>按内存使用率排序。</td>
</tr>
</tbody></table>
<hr>
<h4 id="3-磁盘性能监控"><a href="#3-磁盘性能监控" class="headerlink" title="3. 磁盘性能监控"></a><strong>3. 磁盘性能监控</strong></h4><table>
<thead>
<tr>
<th><strong>命令&#x2F;操作</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>df -h</code></td>
<td>查看磁盘分区使用情况。</td>
</tr>
<tr>
<td><code>iostat -x 1 5</code></td>
<td>查看磁盘 I&#x2F;O 性能（详细模式）。</td>
</tr>
<tr>
<td><code>iotop</code></td>
<td>实时监控进程的磁盘 I&#x2F;O 使用情况。</td>
</tr>
<tr>
<td><code>pidstat -d -p &lt;PID&gt;</code></td>
<td>查看指定进程的磁盘 I&#x2F;O 使用情况。</td>
</tr>
<tr>
<td><code>lsblk</code></td>
<td>显示块设备信息（挂载点和大小）。</td>
</tr>
</tbody></table>
<hr>
<h4 id="4-网络性能监控"><a href="#4-网络性能监控" class="headerlink" title="4. 网络性能监控"></a><strong>4. 网络性能监控</strong></h4><table>
<thead>
<tr>
<th><strong>命令&#x2F;操作</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ifconfig</code> 或 <code>ip a</code></td>
<td>查看网络接口状态和 IP 地址。</td>
</tr>
<tr>
<td><code>sar -n DEV 1 5</code></td>
<td>查看网络接口的吞吐量（发送和接收）。</td>
</tr>
<tr>
<td><code>nload</code></td>
<td>图形化实时显示网络流量。</td>
</tr>
<tr>
<td><code>netstat -ant</code> 或 <code>ss -ant</code></td>
<td>查看所有的 TCP 连接状态。</td>
</tr>
</tbody></table>
<hr>
<h4 id="5-挂载点与文件系统监控"><a href="#5-挂载点与文件系统监控" class="headerlink" title="5. 挂载点与文件系统监控"></a><strong>5. 挂载点与文件系统监控</strong></h4><table>
<thead>
<tr>
<th><strong>命令&#x2F;操作</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>mount</code></td>
<td>查看挂载点及挂载选项。</td>
</tr>
<tr>
<td><code>du -sh /path/to/dir</code></td>
<td>查看目录的总大小。</td>
</tr>
<tr>
<td><code>df -i</code></td>
<td>查看文件系统的 inode 使用情况。</td>
</tr>
<tr>
<td><code>lsblk</code></td>
<td>显示设备的挂载点和分区信息。</td>
</tr>
</tbody></table>
<hr>
<h4 id="6-系统整体性能监控"><a href="#6-系统整体性能监控" class="headerlink" title="6. 系统整体性能监控"></a><strong>6. 系统整体性能监控</strong></h4><table>
<thead>
<tr>
<th><strong>命令&#x2F;操作</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>uptime</code></td>
<td>查看系统负载和运行时间。</td>
</tr>
<tr>
<td><code>top</code></td>
<td>实时监控系统整体性能。</td>
</tr>
<tr>
<td><code>htop</code></td>
<td>图形化进程监控工具，功能更强大。</td>
</tr>
<tr>
<td><code>vmstat 1 5</code></td>
<td>查看 CPU、内存、I&#x2F;O 的统计信息（每秒刷新一次）。</td>
</tr>
</tbody></table>
<hr>
<h4 id="7-快捷键汇总（基于-top）"><a href="#7-快捷键汇总（基于-top）" class="headerlink" title="7. 快捷键汇总（基于 top）"></a><strong>7. 快捷键汇总（基于 <code>top</code>）</strong></h4><table>
<thead>
<tr>
<th><strong>快捷键</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>u</code> + 用户名</td>
<td>仅显示指定用户的进程。</td>
</tr>
<tr>
<td><code>c</code></td>
<td>显示完整的命令路径。</td>
</tr>
<tr>
<td><code>o</code> + <code>COMMAND=&lt;值&gt;</code></td>
<td>按特定条件过滤进程（需匹配列名）。</td>
</tr>
<tr>
<td><code>P</code></td>
<td>按 CPU 使用率排序。</td>
</tr>
<tr>
<td><code>M</code></td>
<td>按内存使用率排序。</td>
</tr>
<tr>
<td><code>T</code></td>
<td>按运行时间排序。</td>
</tr>
<tr>
<td><code>i</code></td>
<td>过滤掉空闲进程。</td>
</tr>
<tr>
<td><code>x</code></td>
<td>高亮排序列。</td>
</tr>
<tr>
<td><code>f</code> + <code>s</code></td>
<td>自定义排序列。</td>
</tr>
</tbody></table>
<hr>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a><strong>补充说明</strong></h3><ul>
<li><p><strong>I&#x2F;O 等待分析</strong>: </p>
<ul>
<li>如果 <code>wa</code> 值较高（<code>iostat</code> 或 <code>top</code> 中显示），可能是磁盘 I&#x2F;O 性能瓶颈。</li>
<li>可结合 <code>iotop</code> 或 <code>pidstat -d</code> 定位高 I&#x2F;O 进程。</li>
</ul>
</li>
<li><p><strong>负载分析</strong>:</p>
<ul>
<li>负载高但 CPU 使用率低，通常是 I&#x2F;O 或内存不足导致。</li>
<li>配合 <code>iostat</code>、<code>vmstat</code> 和 <code>iotop</code> 工具进一步分析。</li>
</ul>
</li>
</ul>
<h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#安装iostat、pidstat的命令</span><br><span class="line">yum install -y  sysstat</span><br><span class="line">#确认io繁忙状态</span><br><span class="line">iostat -x 1</span><br><span class="line">#查看哪些进程在频繁读写文件</span><br><span class="line">pidstat -d 1 </span><br><span class="line"></span><br><span class="line">#安装dig</span><br><span class="line">yum install -y  bind-utils</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux下go环境部署</title>
    <url>/2022/04/27/linux%E4%B8%8Bgo%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="下载配置"><a href="#下载配置" class="headerlink" title="下载配置"></a>下载配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> go &amp;&amp; <span class="built_in">cd</span> go</span><br><span class="line"></span><br><span class="line">wget https://golang.org/dl/go1.17.1.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用root账号配置全局环境</span></span><br><span class="line"><span class="built_in">sudo</span> tar -zxf  go1.17.1.linux-amd64.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure>

<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> vim  /etc/profile </span><br><span class="line"><span class="comment"># 末尾加如下一行</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/go/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使之生效</span></span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line">$ go version</span><br><span class="line">go version go1.17.1 linux/amd64</span><br><span class="line"></span><br><span class="line">$ go <span class="built_in">env</span> -w GO111MODULE=on </span><br><span class="line">$ go <span class="built_in">env</span> -w GOPROXY=https://mirrors.aliyun.com/goproxy/,direct</span><br></pre></td></tr></table></figure>

<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> hello &amp;&amp; <span class="built_in">cd</span> hello</span><br><span class="line">$ go mod init example/hello</span><br><span class="line">$ vim hello.go</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run .</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<h2 id="引用外包方式"><a href="#引用外包方式" class="headerlink" title="引用外包方式"></a>引用外包方式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go get [rsc.io/quote](http://rsc.io/quote)  </span><br><span class="line">$ vim hello.go</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;rsc.io/quote&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(quote.Go())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add new module requirements and sums.</span></span><br><span class="line">$ go mod tidy</span><br><span class="line">$ go run .</span><br><span class="line">Don<span class="string">&#x27;t communicate by sharing memory, share memory by communicating.</span></span><br><span class="line"><span class="string">Hello, World!</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux安装多版本go环境</title>
    <url>/2024/08/28/linux%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACgo%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="gvm安装多版本go环境"><a href="#gvm安装多版本go环境" class="headerlink" title="gvm安装多版本go环境"></a>gvm安装多版本go环境</h2><ul>
<li>参考地址：<a href="https://github.com/moovweb/gvm">https://github.com/moovweb/gvm</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行shell安装gvm</span></span><br><span class="line">yum install -y git</span><br><span class="line">bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</span><br><span class="line"></span><br><span class="line">或者使用github的镜像代理</span><br><span class="line">git <span class="built_in">clone</span> https://2git.xyz/moovweb/gvm.git</span><br><span class="line">bash ./binscripts/gvm-installer</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看所有可安装go版本</span></span><br><span class="line">gvm listall</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装高版本go环境顺序</span></span><br><span class="line">gvm install go1.4 -B</span><br><span class="line">gvm use go1.4</span><br><span class="line"><span class="built_in">export</span> GOROOT_BOOTSTRAP=<span class="variable">$GOROOT</span></span><br><span class="line">gvm install go1.17.13</span><br><span class="line">gvm use go1.17.13</span><br><span class="line"><span class="built_in">export</span> GOROOT_BOOTSTRAP=<span class="variable">$GOROOT</span></span><br><span class="line">gvm install go1.20</span><br><span class="line">gvm use go1.20 --default</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看安装的go版本</span></span><br><span class="line">gvm list</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看环境变量</span></span><br><span class="line">go <span class="built_in">env</span></span><br></pre></td></tr></table></figure>

<h2 id="go-module与vendor"><a href="#go-module与vendor" class="headerlink" title="go module与vendor"></a>go module与vendor</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#引入新的包时，强制启用Go Modules模式</span></span><br><span class="line">go <span class="built_in">env</span> -w GO111MODULE=<span class="string">&quot;on&quot;</span> GOFLAGS=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#项目自带vendor目录，强制 Go 使用 vendor 目录中的依赖包,而不是从网络上下载依赖。这在项目中已经存在 vendor 目录的情况下非常有用，因为它可以避免重新下载依赖，节省时间和带宽</span></span><br><span class="line">go <span class="built_in">env</span> -w GO111MODULE=<span class="string">&quot;auto&quot;</span> GOFLAGS=<span class="string">&quot;-mod=vendor&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置代理</span></span><br><span class="line">go <span class="built_in">env</span> -w GOPROXY=<span class="string">&quot;https://goproxy.cn,https://goproxy.io,direct&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#新项目初始化模块</span></span><br><span class="line">go mod init</span><br><span class="line"><span class="comment">#确认依赖关系</span></span><br><span class="line">go mod verify</span><br><span class="line"><span class="comment">#解释为什么需要包和模块</span></span><br><span class="line">go mod why</span><br><span class="line"><span class="comment">#下载模块到本地缓存</span></span><br><span class="line">go mod download</span><br><span class="line"><span class="comment">#把模块之间的依赖图显示出来</span></span><br><span class="line">go mod graph</span><br><span class="line"><span class="comment">#增加缺失的包，移除没用的包</span></span><br><span class="line">go mod tidy</span><br><span class="line"><span class="comment">#把依赖拷贝到vendor目录下,更新依赖包</span></span><br><span class="line">go mod vendor</span><br><span class="line"></span><br><span class="line"><span class="comment">#部署和发布：</span></span><br><span class="line"><span class="comment">#在部署时，如果希望避免依赖在网络上的可用性（例如，因防火墙或网络问题），建议使用 vendor 目录。#将最终的二进制文件和 vendor 目录（如果使用）一起部署。</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="安装tcping"><a href="#安装tcping" class="headerlink" title="安装tcping"></a>安装tcping</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gvm install go1.23.9</span><br><span class="line">gvm use go1.23.9 </span><br><span class="line"></span><br><span class="line">#查看环境变量</span><br><span class="line">go env | grep -E &#x27;GOPATH|GOBIN&#x27;</span><br><span class="line"></span><br><span class="line">#安装最新版本</span><br><span class="line">go install github.com/pouriyajamshidi/tcping/v2@latest</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">wget https://github.com/pouriyajamshidi/tcping/releases/download/v2.7.1/tcping-linux-amd64-static.tar.gz</span><br><span class="line">tar zxvf tcping-linux-amd64-static.tar.gz</span><br><span class="line">#tcping 端口</span><br><span class="line">./tcping $&#123;ip&#125; $&#123;port&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>linux负载较高排查步骤</title>
    <url>/2025/01/09/linux%E8%B4%9F%E8%BD%BD%E8%BE%83%E9%AB%98%E6%8E%92%E6%9F%A5%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h3 id="系统负载较高的排查步骤与命令汇总"><a href="#系统负载较高的排查步骤与命令汇总" class="headerlink" title="系统负载较高的排查步骤与命令汇总"></a><strong>系统负载较高的排查步骤与命令汇总</strong></h3><p>以下从 <strong>CPU、内存、磁盘 I&#x2F;O、网络、系统整体</strong> 五个方面总结排查步骤和常用命令，结合具体指标进行分析，帮助快速定位问题。</p>
<hr>
<h4 id="1-CPU-负载排查"><a href="#1-CPU-负载排查" class="headerlink" title="1. CPU 负载排查"></a><strong>1. CPU 负载排查</strong></h4><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>指标&#x2F;参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>top</code></td>
<td><code>%CPU</code></td>
<td>查看 CPU 使用率，按 <code>P</code> 排序高使用率进程。</td>
</tr>
<tr>
<td><code>mpstat -P ALL</code></td>
<td><code>%usr</code>, <code>%sys</code>, <code>%idle</code></td>
<td>查看每个核心的 CPU 使用率，判断是否为单核瓶颈或多核均高。</td>
</tr>
<tr>
<td><code>sar -P ALL</code></td>
<td><code>%iowait</code></td>
<td>检查 CPU 是否因 I&#x2F;O 等待（<code>%iowait</code> 高）导致负载高。</td>
</tr>
<tr>
<td><code>pidstat -p &lt;PID&gt;</code></td>
<td><code>%CPU</code></td>
<td>查看指定进程的 CPU 使用率，是否有异常高耗用。</td>
</tr>
<tr>
<td><code>htop</code></td>
<td>图形化监控</td>
<td>更直观地查看高 CPU 使用率的进程和线程。</td>
</tr>
<tr>
<td><code>iotop</code></td>
<td>CPU 列</td>
<td>检查是否有 I&#x2F;O 相关的 CPU 消耗。</td>
</tr>
</tbody></table>
<p><strong>关键分析</strong>：</p>
<ul>
<li><strong><code>%idle</code> 低</strong>：CPU 使用率高，需排查高耗 CPU 进程。</li>
<li><strong><code>%iowait</code> 高</strong>：可能是磁盘或网络 I&#x2F;O 瓶颈。</li>
<li><strong>单核高负载</strong>：检查是否为单线程任务导致瓶颈。</li>
<li><strong>多核高负载</strong>：通常为并行任务占用，需要优化任务分配。</li>
</ul>
<hr>
<h4 id="2-内存负载排查"><a href="#2-内存负载排查" class="headerlink" title="2. 内存负载排查"></a><strong>2. 内存负载排查</strong></h4><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>指标&#x2F;参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>free -m</code></td>
<td><code>used</code>, <code>free</code>, <code>buffers</code></td>
<td>检查内存使用情况，<code>free</code> 值低可能是内存不足。</td>
</tr>
<tr>
<td><code>vmstat 1 5</code></td>
<td><code>si</code>, <code>so</code></td>
<td>检查内存换入换出（swap in&#x2F;out），<code>si/so</code> 高说明内存不足。</td>
</tr>
<tr>
<td><code>top</code></td>
<td><code>%MEM</code></td>
<td>按 <code>M</code> 排序，定位高内存占用进程。</td>
</tr>
<tr>
<td><code>ps -eo pid,%mem,cmd</code></td>
<td><code>%MEM</code></td>
<td>列出进程内存使用情况，辅助定位内存泄漏进程。</td>
</tr>
<tr>
<td><code>smem</code></td>
<td><code>PSS</code>, <code>USS</code></td>
<td>分析进程的共享内存（<code>PSS</code>）和独占内存（<code>USS</code>）。</td>
</tr>
<tr>
<td><code>iotop</code></td>
<td>SWAP 列</td>
<td>检查是否有进程频繁使用 swap。</td>
</tr>
</tbody></table>
<p><strong>关键分析</strong>：</p>
<ul>
<li><strong>内存不足</strong>：<code>free</code> 值低，可能需要扩展内存或优化内存使用。</li>
<li><strong>swap 使用高</strong>：可能是内存不足导致，swap 会拖慢系统。</li>
<li><strong>高内存占用进程</strong>：排查是否有内存泄漏或需优化程序逻辑。</li>
</ul>
<hr>
<h4 id="3-磁盘-I-O-负载排查"><a href="#3-磁盘-I-O-负载排查" class="headerlink" title="3. 磁盘 I&#x2F;O 负载排查"></a><strong>3. 磁盘 I&#x2F;O 负载排查</strong></h4><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>指标&#x2F;参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>iostat -x 1 5</code></td>
<td><code>%util</code>, <code>await</code></td>
<td><code>%util</code> 高（接近 100%）说明磁盘繁忙，<code>await</code> 高说明磁盘延迟大。</td>
</tr>
<tr>
<td><code>iotop</code></td>
<td>DISK READ&#x2F;WRITE 列</td>
<td>实时查看进程的磁盘读写量，定位高 I&#x2F;O 进程。</td>
</tr>
<tr>
<td><code>pidstat -d -p &lt;PID&gt;</code></td>
<td><code>kB_rd/s</code>, <code>kB_wr/s</code></td>
<td>查看指定进程的磁盘读写速率。</td>
</tr>
<tr>
<td><code>df -h</code></td>
<td><code>Use%</code></td>
<td>检查磁盘使用率是否接近 100%，可能导致 I&#x2F;O 瓶颈。</td>
</tr>
<tr>
<td><code>du -sh /path/to/dir</code></td>
<td>文件夹大小</td>
<td>定位大文件或目录，清理磁盘空间。</td>
</tr>
<tr>
<td><code>lsblk</code></td>
<td>磁盘分区</td>
<td>查看磁盘挂载和分区信息，判断是否有挂载错误。</td>
</tr>
</tbody></table>
<p><strong>关键分析</strong>：</p>
<ul>
<li><strong><code>%util</code> 高，<code>await</code> 高</strong>：磁盘性能瓶颈，需优化磁盘读写或升级存储设备。</li>
<li><strong>高 I&#x2F;O 进程</strong>：检查是否有频繁读写操作，优化程序逻辑。</li>
<li><strong>磁盘空间不足</strong>：清理大文件或扩展磁盘空间。</li>
</ul>
<hr>
<h4 id="4-网络-I-O-负载排查"><a href="#4-网络-I-O-负载排查" class="headerlink" title="4. 网络 I&#x2F;O 负载排查"></a><strong>4. 网络 I&#x2F;O 负载排查</strong></h4><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>指标&#x2F;参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>sar -n DEV 1 5</code></td>
<td><code>rxpck/s</code>, <code>txpck/s</code></td>
<td>查看网络接口的接收&#x2F;发送数据包速率。</td>
</tr>
<tr>
<td><code>iftop</code></td>
<td>流量占用</td>
<td>实时查看具体 IP 或端口的网络流量占用情况。</td>
</tr>
<tr>
<td><code>netstat -ant</code> 或 <code>ss</code></td>
<td>连接状态</td>
<td>检查 TCP 连接是否过多（如大量 <code>TIME_WAIT</code>）。</td>
</tr>
<tr>
<td><code>ip -s link</code></td>
<td>接口状态</td>
<td>查看网络接口的流量统计和错误信息。</td>
</tr>
<tr>
<td><code>nload</code></td>
<td>图形化流量显示</td>
<td>实时查看网络流量，定位高流量接口。</td>
</tr>
</tbody></table>
<p><strong>关键分析</strong>：</p>
<ul>
<li><strong>高流量</strong>：检查是否有异常流量或带宽瓶颈。</li>
<li><strong>TCP 连接过多</strong>：优化连接管理或增加负载均衡。</li>
<li><strong>网络接口错误</strong>：检查是否有丢包或硬件问题。</li>
</ul>
<hr>
<h4 id="5-系统整体性能排查"><a href="#5-系统整体性能排查" class="headerlink" title="5. 系统整体性能排查"></a><strong>5. 系统整体性能排查</strong></h4><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>指标&#x2F;参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>uptime</code></td>
<td><code>load average</code></td>
<td>检查系统负载，了解是否有持续高负载。</td>
</tr>
<tr>
<td><code>vmstat 1 5</code></td>
<td><code>r</code>, <code>b</code>, <code>wa</code></td>
<td><code>r</code> 表示运行队列，<code>b</code> 表示阻塞进程，<code>wa</code> 表示 I&#x2F;O 等待。</td>
</tr>
<tr>
<td><code>top</code></td>
<td>综合监控</td>
<td>查看 CPU、内存、进程、I&#x2F;O 的综合信息。</td>
</tr>
<tr>
<td><code>htop</code></td>
<td>图形化进程监控</td>
<td>更直观地监控系统资源。</td>
</tr>
<tr>
<td><code>iotop</code></td>
<td>综合 I&#x2F;O 占用</td>
<td>实时查看磁盘 I&#x2F;O 和 CPU 关联的进程。</td>
</tr>
</tbody></table>
<p><strong>关键分析</strong>：</p>
<ul>
<li><strong>高负载但 CPU 使用率低</strong>：通常是 I&#x2F;O 或内存瓶颈。</li>
<li><strong>运行队列高</strong>：表明任务处理速度跟不上，需分析具体瓶颈。</li>
<li><strong>阻塞进程多</strong>：通常是 I&#x2F;O 或资源争用问题。</li>
</ul>
<hr>
<h3 id="iostat安装及命令解析"><a href="#iostat安装及命令解析" class="headerlink" title="iostat安装及命令解析"></a>iostat安装及命令解析</h3><blockquote>
<p><a href="https://jueee.github.io/2020/12/2020-12-16-Linux%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8iostat%E5%91%BD%E4%BB%A4">https://jueee.github.io/2020/12/2020-12-16-Linux%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8iostat%E5%91%BD%E4%BB%A4</a></p>
</blockquote>
<ul>
<li>安装：yum -y install sysstat<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选项:</span><br><span class="line">-c：仅显示 CPU 使用情况；</span><br><span class="line">-d：仅显示设备利用率；</span><br><span class="line">-k：显示状态以千字节每秒为单位，而不使用块每秒；</span><br><span class="line">-m：显示状态以兆字节每秒为单位；</span><br><span class="line">-p：仅显示块设备和所有被使用的其他分区的状态；</span><br><span class="line">-t：显示每个报告产生时的时间；</span><br><span class="line">-V：显示版号并退出；</span><br><span class="line">-x：显示扩展状态。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">间隔时间：每次报告的间隔时间（秒）；</span><br><span class="line">次数：显示报告的次数。</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="总结与优化建议"><a href="#总结与优化建议" class="headerlink" title="总结与优化建议"></a><strong>总结与优化建议</strong></h3><blockquote>
<p><a href="https://blog.51cto.com/linhuchong/5241886">https://blog.51cto.com/linhuchong/5241886</a></p>
</blockquote>
<ol>
<li><strong>排查顺序</strong>：<ul>
<li>先检查系统整体负载（<code>uptime</code>、<code>top</code>）。</li>
<li>再分别检查 CPU、内存、磁盘 I&#x2F;O 和网络。</li>
</ul>
</li>
<li><strong>结合工具</strong>：<ul>
<li>使用 <code>iotop</code>、<code>htop</code> 等工具快速定位高资源占用的进程。</li>
<li>使用 <code>sar</code>、<code>vmstat</code> 等工具分析历史数据。</li>
</ul>
</li>
<li><strong>优化方向</strong>：<ul>
<li>CPU：优化高耗任务或增加核数。</li>
<li>内存：优化程序逻辑或扩展物理内存。</li>
<li>磁盘 I&#x2F;O：减少频繁读写或升级存储设备。</li>
<li>网络：优化流量分发或限制异常流量。</li>
</ul>
</li>
</ol>
<h2 id="参考图片"><a href="#参考图片" class="headerlink" title="参考图片"></a>参考图片</h2><p><img src="https://raw.githubusercontent.com/shispring/picgo/master/b16f34a197e1b9a6137f8ea263ea5063.png" alt="性能排查"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux配置oh-my-posh</title>
    <url>/2025/01/22/linux%E9%85%8D%E7%BD%AEoh-my-posh/</url>
    <content><![CDATA[<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#下载安装</span><br><span class="line">curl -s https://ohmyposh.dev/install.sh | bash -s</span><br><span class="line">oh-my-posh --version</span><br><span class="line">oh-my-posh get shell</span><br><span class="line"></span><br><span class="line">#下载主题</span><br><span class="line">mkdir -p ~/.poshthemes</span><br><span class="line">wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/themes.zip -O ~/.poshthemes/themes.zip</span><br><span class="line">unzip ~/.poshthemes/themes.zip -d ~/.poshthemes</span><br><span class="line">rm ~/.poshthemes/themes.zip</span><br><span class="line"></span><br><span class="line">#设置主题文件的权限</span><br><span class="line">chmod u+rw ~/.poshthemes/*.json</span><br><span class="line"></span><br><span class="line">#编辑~/.bashrc (在文件末尾添加以下内容):</span><br><span class="line">eval &quot;$(oh-my-posh init bash --config ~/.poshthemes/robbyrussell.omp.json)&quot;</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>mac tips</title>
    <url>/2024/12/16/mac-tips/</url>
    <content><![CDATA[<h2 id="合屏幕是否休眠电脑"><a href="#合屏幕是否休眠电脑" class="headerlink" title="合屏幕是否休眠电脑"></a>合屏幕是否休眠电脑</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#防止系统休眠</span><br><span class="line">pmset -a disablesleep 1</span><br><span class="line">#使系统休眠</span><br><span class="line">pmset -a disablesleep 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="终端配置"><a href="#终端配置" class="headerlink" title="终端配置"></a>终端配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Oh My Zsh 搭配主题、插件</span><br><span class="line">#参考：https://www.poloxue.com/</span><br><span class="line">powerlevel10k + zsh-autosuggestions + zsh-syntax-highlighting</span><br><span class="line"></span><br><span class="line">#github安装</span><br><span class="line">git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br><span class="line"></span><br><span class="line">#vim .zshrc</span><br><span class="line">plugins=(git zsh-autosuggestions z zsh-syntax-highlighting )</span><br><span class="line"></span><br><span class="line">ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&quot;fg=#6C737C,bg=cyan,bold,underline&quot;</span><br><span class="line">ZSH_AUTOSUGGEST_STRATEGY=(history completion)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="chrome-插件"><a href="#chrome-插件" class="headerlink" title="chrome : 插件"></a>chrome : 插件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vimum</span><br><span class="line">用法：https://juejin.cn/post/7208129482095067197</span><br><span class="line"></span><br><span class="line">沉浸式翻译</span><br><span class="line">https://immersivetranslate.com/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Medium Unlock</span><br><span class="line">备注：查看 https://medium.com/ 上的付费文章</span><br><span class="line">#也可以使用 https://freedium.cfd/ 地址粘贴URL查看</span><br></pre></td></tr></table></figure>

<h2 id="easydict-超级好用的OCR-翻译工具"><a href="#easydict-超级好用的OCR-翻译工具" class="headerlink" title="easydict : 超级好用的OCR 翻译工具"></a>easydict : 超级好用的OCR 翻译工具</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/tisfeng/Easydict</span><br></pre></td></tr></table></figure>

<h2 id="cmatrix-黑客帝国代码雨"><a href="#cmatrix-黑客帝国代码雨" class="headerlink" title="cmatrix : 黑客帝国代码雨"></a>cmatrix : 黑客帝国代码雨</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install cmatrix</span><br></pre></td></tr></table></figure>

<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 阿里云分享</span><br><span class="line">https://mp.weixin.qq.com/s/2qgs4JYOJFCmrxHMxtctyA</span><br></pre></td></tr></table></figure>

<h2 id="ping加时间戳"><a href="#ping加时间戳" class="headerlink" title="ping加时间戳"></a>ping加时间戳</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#安装moreutils</span><br><span class="line">brew install moreutils</span><br><span class="line"></span><br><span class="line">ping &quot;$@&quot; | ts &#x27;[%Y-%m-%d %H:%M:%S]&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="截长图工具"><a href="#截长图工具" class="headerlink" title="截长图工具"></a>截长图工具</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ishot</span><br><span class="line"></span><br><span class="line">#另外</span><br><span class="line">BetterAndBetter</span><br></pre></td></tr></table></figure>

<h2 id="相信任何源"><a href="#相信任何源" class="headerlink" title="相信任何源"></a>相信任何源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo spctl --master-disable</span><br></pre></td></tr></table></figure>
<h2 id="coreinject"><a href="#coreinject" class="headerlink" title="coreinject"></a>coreinject</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://qiuchenlyopensource.github.io/Documentaions/getting-started.html</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>magick工具使用</title>
    <url>/2024/11/01/magick%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><code>ImageMagick</code> 是一个强大的工具，用于图像操作和格式转换，支持各种操作如裁剪、旋转、调整大小、格式转换等。下面是一些常用的 <code>magick</code> 命令，以便你快速掌握图片处理及PDF操作技巧。以下命令基于 <code>magick</code> 7.1.1-39 版本：</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install imagemagick</span><br><span class="line"></span><br><span class="line">magick -version</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-图像格式转换"><a href="#1-图像格式转换" class="headerlink" title="1. 图像格式转换"></a>1. 图像格式转换</h3><p>将图像从一种格式转换为另一种格式，适用于支持的多种格式（如 PNG、JPEG、GIF、TIFF 等）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick input.jpg output.png</span><br></pre></td></tr></table></figure>

<h3 id="2-调整图像大小"><a href="#2-调整图像大小" class="headerlink" title="2. 调整图像大小"></a>2. 调整图像大小</h3><p>按指定比例或像素大小调整图像大小。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick input.jpg -resize 800x600 output.jpg</span><br></pre></td></tr></table></figure>

<h3 id="3-裁剪图像"><a href="#3-裁剪图像" class="headerlink" title="3. 裁剪图像"></a>3. 裁剪图像</h3><p>裁剪图像为指定大小的区域。例如，裁剪出左上角 200x200 的区域。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick input.jpg -crop 200x200+0+0 output.jpg</span><br></pre></td></tr></table></figure>

<h3 id="4-旋转图像"><a href="#4-旋转图像" class="headerlink" title="4. 旋转图像"></a>4. 旋转图像</h3><p>顺时针旋转图像 90 度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick input.jpg -rotate 90 output.jpg</span><br></pre></td></tr></table></figure>

<h3 id="5-添加水印"><a href="#5-添加水印" class="headerlink" title="5. 添加水印"></a>5. 添加水印</h3><p>在图像上添加水印文字（位置在右下角）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick input.jpg -gravity southeast -pointsize 24 -fill white -annotate +10+10 <span class="string">&#x27;Watermark&#x27;</span> output.jpg</span><br></pre></td></tr></table></figure>

<h3 id="6-调整图像质量"><a href="#6-调整图像质量" class="headerlink" title="6. 调整图像质量"></a>6. 调整图像质量</h3><p>设置图像质量，适用于 JPEG 格式的图片压缩。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick input.jpg -quality 85 output.jpg</span><br></pre></td></tr></table></figure>

<h3 id="7-合并图像（拼接）"><a href="#7-合并图像（拼接）" class="headerlink" title="7. 合并图像（拼接）"></a>7. 合并图像（拼接）</h3><p>水平或垂直拼接多张图像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick +append image1.jpg image2.jpg horizontal_output.jpg  <span class="comment"># 水平拼接</span></span><br><span class="line">magick -append image1.jpg image2.jpg vertical_output.jpg    <span class="comment"># 垂直拼接</span></span><br></pre></td></tr></table></figure>

<h3 id="8-添加边框"><a href="#8-添加边框" class="headerlink" title="8. 添加边框"></a>8. 添加边框</h3><p>为图像添加边框。例如，添加一个 5 像素的红色边框。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick input.jpg -bordercolor red -border 5x5 output.jpg</span><br></pre></td></tr></table></figure>

<h3 id="9-转换-PDF-为图像"><a href="#9-转换-PDF-为图像" class="headerlink" title="9. 转换 PDF 为图像"></a>9. 转换 PDF 为图像</h3><p>将 PDF 页面转换为 PNG 格式，指定分辨率（如 300 dpi）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ImageMagick 在处理 PDF 文件时依赖于 Ghostscript (gs) 来进行 PDF 的渲染和转换</span></span><br><span class="line"><span class="comment">#brew install ghostscript</span></span><br><span class="line"></span><br><span class="line">magick -density 300 -quality 100 original.pdf output_%03d.jpg</span><br><span class="line">参数说明：</span><br><span class="line">• -density 300：设定渲染 DPI（分辨率），300 是高清常用值；</span><br><span class="line">• -quality 100：设定 JPEG 编码质量，范围 1–100，100 为无压缩；</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果需要将 PDF 中的每一页保存为单独的 PNG 图像，可以使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick -density 300 input.pdf page_%03d.png</span><br></pre></td></tr></table></figure>

<h3 id="10-转换图像为-PDF"><a href="#10-转换图像为-PDF" class="headerlink" title="10. 转换图像为 PDF"></a>10. 转换图像为 PDF</h3><p>将多张图像合并成一个 PDF 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">magick image1.jpg image2.jpg output.pdf</span><br><span class="line"></span><br><span class="line"><span class="comment">#高质量合成pdf</span></span><br><span class="line">magick -density 300 output_*.jpg -quality 100 final.pdf</span><br><span class="line"></span><br><span class="line"><span class="comment">#多个图片转换</span></span><br><span class="line"><span class="built_in">ls</span> -l | awk <span class="string">&#x27;NR &gt; 1 &#123;print $NF&#125;&#x27;</span> | <span class="built_in">tr</span> <span class="string">&quot;\n&quot;</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line"></span><br><span class="line">magick `<span class="built_in">ls</span> -l | grep jpg | awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> | <span class="built_in">tr</span> <span class="string">&quot;\n&quot;</span> <span class="string">&#x27; &#x27;</span>`  -density 300 -quality 100 output.pdf</span><br><span class="line"></span><br><span class="line"><span class="comment">#按顺序处理组合pdf</span></span><br><span class="line">magick `<span class="built_in">ls</span> -l | grep png | awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> | <span class="built_in">sort</span> -V | <span class="built_in">tr</span> <span class="string">&quot;\n&quot;</span> <span class="string">&#x27; &#x27;</span>`  -density 300 -quality 100 output.pdf</span><br></pre></td></tr></table></figure>

<h3 id="11-批量处理文件"><a href="#11-批量处理文件" class="headerlink" title="11. 批量处理文件"></a>11. 批量处理文件</h3><p>一次性对多个文件进行操作，调整大小为 50%：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick mogrify -resize 50% *.jpg</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>mogrify</code> 会直接覆盖原始文件，建议先备份或在不同目录操作。</p>
</blockquote>
<h3 id="12-图像格式优化（减小文件大小）"><a href="#12-图像格式优化（减小文件大小）" class="headerlink" title="12. 图像格式优化（减小文件大小）"></a>12. 图像格式优化（减小文件大小）</h3><p>通过移除元数据和设置压缩等级优化图像大小。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick input.jpg -strip -quality 85 output.jpg</span><br></pre></td></tr></table></figure>

<h3 id="13-应用模糊效果"><a href="#13-应用模糊效果" class="headerlink" title="13. 应用模糊效果"></a>13. 应用模糊效果</h3><p>对图像应用模糊效果，可以控制模糊程度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick input.jpg -blur 0x8 output.jpg  <span class="comment"># 0x8 控制模糊半径和 sigma 值</span></span><br></pre></td></tr></table></figure>

<h3 id="14-翻转和镜像"><a href="#14-翻转和镜像" class="headerlink" title="14. 翻转和镜像"></a>14. 翻转和镜像</h3><p>上下翻转或左右镜像图像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick input.jpg -flip output_flip.jpg        <span class="comment"># 上下翻转</span></span><br><span class="line">magick input.jpg -flop output_flop.jpg        <span class="comment"># 左右镜像</span></span><br></pre></td></tr></table></figure>

<h3 id="15-提取图像信息"><a href="#15-提取图像信息" class="headerlink" title="15. 提取图像信息"></a>15. 提取图像信息</h3><p>查看图像的详细信息，包括尺寸、格式、色彩模式等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick identify -verbose input.jpg</span><br></pre></td></tr></table></figure>

<h3 id="16-图像转灰度"><a href="#16-图像转灰度" class="headerlink" title="16. 图像转灰度"></a>16. 图像转灰度</h3><p>将彩色图像转换为灰度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick input.jpg -colorspace Gray output.jpg</span><br></pre></td></tr></table></figure>

<h3 id="17-添加阴影"><a href="#17-添加阴影" class="headerlink" title="17. 添加阴影"></a>17. 添加阴影</h3><p>为图像添加阴影效果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick input.jpg -background black -shadow 80x3+5+5 output_with_shadow.png</span><br></pre></td></tr></table></figure>

<h3 id="18-动态GIF操作"><a href="#18-动态GIF操作" class="headerlink" title="18. 动态GIF操作"></a>18. 动态GIF操作</h3><p>创建或分解 GIF 动画。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick -delay 20 -loop 0 frame_*.jpg output.gif  <span class="comment"># 创建 GIF，20ms 间隔</span></span><br><span class="line">magick input.gif frame_%03d.png                   <span class="comment"># 将 GIF 分解成多帧 PNG 图像</span></span><br></pre></td></tr></table></figure>

<h3 id="19-将-PDF-分解成多张-PNG（每页一张）"><a href="#19-将-PDF-分解成多张-PNG（每页一张）" class="headerlink" title="19. 将 PDF 分解成多张 PNG（每页一张）"></a>19. 将 PDF 分解成多张 PNG（每页一张）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">magick -density 300 input.pdf output_page_%03d.png</span><br></pre></td></tr></table></figure>

<h3 id="20-从视频中提取帧并生成-GIF"><a href="#20-从视频中提取帧并生成-GIF" class="headerlink" title="20. 从视频中提取帧并生成 GIF"></a>20. 从视频中提取帧并生成 GIF</h3><p>将视频中的帧生成 GIF 动画。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -r 10 <span class="string">&#x27;frame_%03d.png&#x27;</span>  <span class="comment"># 使用 FFmpeg 提取帧</span></span><br><span class="line">magick -delay 10 frame_*.png output.gif      <span class="comment"># 使用提取帧生成 GIF</span></span><br></pre></td></tr></table></figure>

<p>这些 <code>magick</code> 用法可以满足大多数日常图片和PDF转换的需求。更多高级用法可以查阅 <a href="https://imagemagick.org/index.php">ImageMagick 官方文档</a> 或 <code>magick</code> 的帮助页面：<code>magick -help</code>。</p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>metrics的常用命令</title>
    <url>/2024/12/09/metrics%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="关于-Metrics-的常用命令"><a href="#关于-Metrics-的常用命令" class="headerlink" title="关于 Metrics 的常用命令"></a>关于 Metrics 的常用命令</h3><ol>
<li><p><strong>查看 Kubelet 的指标</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get --raw <span class="string">&quot;/metrics&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回 Kubelet 的本地监控指标，主要包括运行时性能和系统状态。</li>
</ul>
</li>
<li><p><strong>查看节点的 cAdvisor 指标</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get --raw <span class="string">&quot;/api/v1/nodes/&lt;nodeName&gt;/proxy/metrics/cadvisor&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取容器级别的详细性能指标。</li>
</ul>
</li>
<li><p><strong>查看 API Server 的指标</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get --raw <span class="string">&quot;/metrics&quot;</span> | grep apiserver</span><br></pre></td></tr></table></figure>
<ul>
<li>返回 API Server 的性能指标。</li>
</ul>
</li>
<li><p><strong>查看 Controller Manager 的指标</strong>：<br>在 Controller Manager 所在的节点运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:10252/metrics</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看 Scheduler 的指标</strong>：<br>在 Scheduler 所在的节点运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost:10251/metrics</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看 Metrics Server 的 API</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get --raw <span class="string">&quot;/apis/metrics.k8s.io/v1beta1/nodes&quot;</span></span><br></pre></td></tr></table></figure>
<p>或查看 Pod 的指标：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get --raw <span class="string">&quot;/apis/metrics.k8s.io/v1beta1/pods&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Prometheus 拉取指标</strong>：<br>如果集群中部署了 Prometheus，可以直接通过其 UI 或 API 获取指标，使用 PromQL 查询资源利用率。</p>
</li>
</ol>
<hr>
<h3 id="Kubernetes-Metrics-的整体知识架构"><a href="#Kubernetes-Metrics-的整体知识架构" class="headerlink" title="Kubernetes Metrics 的整体知识架构"></a>Kubernetes Metrics 的整体知识架构</h3><h4 id="1-数据来源"><a href="#1-数据来源" class="headerlink" title="1. 数据来源"></a><strong>1. 数据来源</strong></h4><ul>
<li><strong>Kubelet cAdvisor</strong>：提供节点和容器的资源使用数据。</li>
<li><strong>Metrics Server</strong>：聚合来自 Kubelet 的指标，用于 Horizontal Pod Autoscaler（HPA）等。</li>
<li><strong>Prometheus</strong>：一个全面的监控解决方案，用于存储和查询集群中所有相关的指标数据。</li>
<li><strong>API Server 和 Controller 指标</strong>：暴露组件性能。</li>
</ul>
<h4 id="2-相关工具"><a href="#2-相关工具" class="headerlink" title="2. 相关工具"></a><strong>2. 相关工具</strong></h4><ul>
<li><strong>kubectl top</strong>：快速查看节点和 Pod 的资源使用：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl top nodes</span><br><span class="line">kubectl top pods --namespace=&lt;namespace&gt;</span><br></pre></td></tr></table></figure></li>
<li><strong>Prometheus&#x2F;Grafana</strong>：用于可视化和分析。</li>
<li><strong>Custom Metrics Adapter</strong>：支持自定义指标。</li>
</ul>
<h4 id="3-最佳实践"><a href="#3-最佳实践" class="headerlink" title="3. 最佳实践"></a><strong>3. 最佳实践</strong></h4><ol>
<li><strong>启用 Metrics Server</strong>：用于 HPA 和基本资源监控。</li>
<li><strong>使用 Prometheus</strong>：集中化收集和存储指标。</li>
<li><strong>建立告警系统</strong>：通过 Alertmanager 或其他工具设置告警。</li>
<li><strong>分析指标覆盖范围</strong>：确保所有重要组件和工作负载都有相关指标暴露。</li>
<li><strong>优化监控开销</strong>：根据需要采样和聚合数据，避免监控开销过大。</li>
</ol>
<hr>
<h3 id="推荐文档与资源"><a href="#推荐文档与资源" class="headerlink" title="推荐文档与资源"></a>推荐文档与资源</h3><ol>
<li><p><strong>Kubernetes 官方文档</strong>：</p>
<ul>
<li><a href="https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-metrics/">Metrics for Kubernetes Components</a></li>
<li><a href="https://kubernetes.io/docs/concepts/cluster-administration/monitoring/">Monitoring Architecture</a></li>
</ul>
</li>
<li><p><strong>Prometheus 官方文档</strong>：</p>
<ul>
<li><a href="https://prometheus.io/docs/">Prometheus Documentation</a></li>
</ul>
</li>
<li><p><strong>社区工具</strong>：</p>
<ul>
<li><a href="https://github.com/prometheus-operator/kube-prometheus">Kube-prometheus-stack</a><br>一个推荐的 Prometheus Operator 部署方案。</li>
</ul>
</li>
<li><p><strong>博客与案例</strong>：</p>
<ul>
<li><a href="https://www.cncf.io/">CNCF Metrics Best Practices</a><br>关于监控和指标的实践指导。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>nfs部署及使用</title>
    <url>/2024/12/20/nfs%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1-NFS-服务端配置"><a href="#1-NFS-服务端配置" class="headerlink" title="1. NFS 服务端配置"></a><strong>1. NFS 服务端配置</strong></h3><h4 id="1-1-安装-NFS-服务"><a href="#1-1-安装-NFS-服务" class="headerlink" title="1.1 安装 NFS 服务"></a><strong>1.1 安装 NFS 服务</strong></h4><p>在 NFS 服务端安装必要的软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br></pre></td></tr></table></figure>

<h4 id="1-2-配置共享目录"><a href="#1-2-配置共享目录" class="headerlink" title="1.2 配置共享目录"></a><strong>1.2 配置共享目录</strong></h4><ol>
<li><p>创建共享目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /data/shell</span><br><span class="line"><span class="built_in">chmod</span> 755 /data/shell</span><br><span class="line"><span class="built_in">chown</span> nfsnobody:nfsnobody /data/shell</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 NFS 配置文件 <code>/etc/exports</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/exports</span><br></pre></td></tr></table></figure>
<p>添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/data/shell  *(rw,sync,no_root_squash)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>rw</code>：允许读写。</li>
<li><code>sync</code>：同步模式，确保数据写入磁盘后才返回客户端。</li>
<li><code>no_root_squash</code>：允许客户端以 root 身份访问。</li>
</ul>
</li>
<li><p>检查配置是否正确：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">exportfs -rv</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-3-启动和配置-NFS-服务"><a href="#1-3-启动和配置-NFS-服务" class="headerlink" title="1.3 启动和配置 NFS 服务"></a><strong>1.3 启动和配置 NFS 服务</strong></h4><ol>
<li><p>启动 NFS 服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> nfs-server</span><br><span class="line">systemctl start nfs-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 NFS 服务状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status nfs-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>确保防火墙允许 NFS 服务端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-service=nfs</span><br><span class="line">firewall-cmd --permanent --add-service=mountd</span><br><span class="line">firewall-cmd --permanent --add-service=rpc-bind</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认共享目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">showmount -e localhost</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="2-NFS-客户端配置"><a href="#2-NFS-客户端配置" class="headerlink" title="2. NFS 客户端配置"></a><strong>2. NFS 客户端配置</strong></h3><h4 id="2-1-安装-NFS-客户端工具"><a href="#2-1-安装-NFS-客户端工具" class="headerlink" title="2.1 安装 NFS 客户端工具"></a><strong>2.1 安装 NFS 客户端工具</strong></h4><p>在客户端机器上安装 NFS 工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br></pre></td></tr></table></figure>

<h4 id="2-2-查看-NFS-服务端的共享目录"><a href="#2-2-查看-NFS-服务端的共享目录" class="headerlink" title="2.2 查看 NFS 服务端的共享目录"></a><strong>2.2 查看 NFS 服务端的共享目录</strong></h4><p>使用 <code>showmount</code> 命令查看 NFS 服务端的共享目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">showmount -e 192.168.100.100</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Export list for 192.168.100.100:</span><br><span class="line">/data/shell *</span><br></pre></td></tr></table></figure>

<h4 id="2-3-挂载-NFS-共享目录"><a href="#2-3-挂载-NFS-共享目录" class="headerlink" title="2.3 挂载 NFS 共享目录"></a><strong>2.3 挂载 NFS 共享目录</strong></h4><p>将 NFS 服务端的共享目录挂载到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t nfs 192.168.100.100:/data/shell /data/shell</span><br></pre></td></tr></table></figure>

<h4 id="2-4-持久化挂载"><a href="#2-4-持久化挂载" class="headerlink" title="2.4 持久化挂载"></a><strong>2.4 持久化挂载</strong></h4><p>编辑 <code>/etc/fstab</code> 文件，确保重启后自动挂载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure>
<p>添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.100.100:/data/shell /data/shell nfs defaults 0 0</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-测试和管理"><a href="#3-测试和管理" class="headerlink" title="3. 测试和管理"></a><strong>3. 测试和管理</strong></h3><h4 id="3-1-测试挂载"><a href="#3-1-测试挂载" class="headerlink" title="3.1 测试挂载"></a><strong>3.1 测试挂载</strong></h4><ol>
<li><p>在客户端查看挂载目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /data/shell</span><br></pre></td></tr></table></figure>
</li>
<li><p>在服务端修改共享目录内容，验证客户端是否同步更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Test NFS&quot;</span> &gt; /data/shell/test.txt</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-2-卸载挂载目录"><a href="#3-2-卸载挂载目录" class="headerlink" title="3.2 卸载挂载目录"></a><strong>3.2 卸载挂载目录</strong></h4><p>如果需要卸载挂载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount /data/shell</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-维护与清理日志（脚本自动化）"><a href="#4-维护与清理日志（脚本自动化）" class="headerlink" title="4. 维护与清理日志（脚本自动化）"></a><strong>4. 维护与清理日志（脚本自动化）</strong></h3><p>以下脚本自动压缩和清理日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">GZDAY=`<span class="built_in">date</span> -d <span class="string">&quot;-1 day&quot;</span> <span class="string">&quot;+%Y%m%d&quot;</span>`</span><br><span class="line">RMDAY=`<span class="built_in">date</span> -d <span class="string">&quot;-14 day&quot;</span> <span class="string">&quot;+%Y%m%d&quot;</span>`</span><br><span class="line"></span><br><span class="line">LOGDIRS=`find /data/nginx/logs/ -<span class="built_in">type</span> d | grep -v archive`</span><br><span class="line">LOGDIRS=(<span class="variable">$LOGDIRS</span>)</span><br><span class="line"></span><br><span class="line">OTHERDIRS=(</span><br><span class="line"><span class="string">&quot;/home/q/system/hulk/logs&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">LOGDIRS=(</span><br><span class="line"><span class="variable">$&#123;LOGDIRS[@]&#125;</span></span><br><span class="line"><span class="variable">$&#123;OTHERDIRS[@]&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;LOGDIRS[@]&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">mkdir</span> -p <span class="variable">$dir</span>/archive</span><br><span class="line">    <span class="built_in">mv</span> <span class="variable">$dir</span>/*<span class="variable">$GZDAY</span>* <span class="variable">$dir</span>/archive/</span><br><span class="line">    gzip -1 <span class="variable">$dir</span>/archive/*<span class="variable">$GZDAY</span>*</span><br><span class="line">    <span class="built_in">rm</span> -rf <span class="variable">$dir</span>/archive/*<span class="variable">$RMDAY</span>*</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将脚本保存为 <code>log_cleaner.sh</code>。</li>
<li>添加可执行权限：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x log_cleaner.sh</span><br></pre></td></tr></table></figure></li>
<li>定时执行（例如，每天凌晨 2 点）：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
添加：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 2 * * * /path/to/log_cleaner.sh</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h3><ol>
<li><p><strong>安全配置</strong>：</p>
<ul>
<li>使用 <code>rw,sync</code> 但避免 <code>no_root_squash</code>，可替换为特定用户的 UID&#x2F;GID。</li>
<li>限制访问来源：<code>/data/shell 192.168.1.0/24(rw,sync)</code>。</li>
</ul>
</li>
<li><p><strong>性能优化</strong>：</p>
<ul>
<li>使用 <code>async</code> 模式提高性能（需根据场景权衡）。</li>
<li>调整挂载参数：<code>rsize</code> 和 <code>wsize</code>（如 1MB），以提高传输效率。</li>
</ul>
</li>
<li><p><strong>监控与报警</strong>：</p>
<ul>
<li>使用 <code>nfsstat</code> 查看性能统计。<a href="https://bashcommandnotfound.cn/article/linux-nfsstat-command">https://bashcommandnotfound.cn/article/linux-nfsstat-command</a></li>
<li>配合 Prometheus 或其他工具监控存储使用率。</li>
</ul>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>nginx demo service</title>
    <url>/2024/11/08/nginx-demo-service/</url>
    <content><![CDATA[<h2 id="配置nginx服务"><a href="#配置nginx服务" class="headerlink" title="配置nginx服务"></a>配置nginx服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOL &gt; /Users/xxx/share/nginx.conf</span><br><span class="line">events &#123;&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root /usr/share/nginx/html;</span><br><span class="line">            autoindex on; # 启用目录列表功能</span><br><span class="line">            autoindex_exact_size off; # 以KB或MB显示文件大小</span><br><span class="line">            autoindex_localtime on; # 以本地时间显示文件的修改时间</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOL</span><br></pre></td></tr></table></figure>

<h2 id="启动docker服务"><a href="#启动docker服务" class="headerlink" title="启动docker服务"></a>启动docker服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line">docker run --name nginx-share -d \</span><br><span class="line">    -p 8080:80 \</span><br><span class="line">    -v /Users/xxx/share:/usr/share/nginx/html \</span><br><span class="line">    -v /Users/xxx/share/nginx.conf:/etc/nginx/nginx.conf:ro \</span><br><span class="line">    nginx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
  </entry>
  <entry>
    <title>nginx 模块及配置</title>
    <url>/2024/10/31/nginx-%E6%A8%A1%E5%9D%97%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="统计连接数"><a href="#统计连接数" class="headerlink" title="统计连接数"></a>统计连接数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#netstat</span><br><span class="line">netstat -ant | awk &#x27;NR &gt; 2 &#123;print $NF&#125;&#x27; | sort | uniq -c | sort -nr</span><br><span class="line"></span><br><span class="line">#ss</span><br><span class="line">ss -tan | awk &#x27;NR &gt; 2 &#123;print $1&#125;&#x27; | sort | uniq -c | sort -nr</span><br><span class="line"></span><br><span class="line">#读取/proc/net/tcp文件</span><br><span class="line">cat /proc/net/tcp | awk &#x27;NR &gt; 1 &#123;print $4&#125;&#x27; | cut -d&#x27;:&#x27; -f2 | sort | uniq -c | sort -nr</span><br><span class="line"></span><br><span class="line">#含义介绍</span><br><span class="line">TCP_ESTABLISHED:1   TCP_SYN_SENT:2</span><br><span class="line">TCP_SYN_RECV:3      TCP_FIN_WAIT1:4</span><br><span class="line">TCP_FIN_WAIT2:5     TCP_TIME_WAIT:6</span><br><span class="line">TCP_CLOSE:7         TCP_CLOSE_WAIT:8</span><br><span class="line">TCP_LAST_ACL:9      TCP_LISTEN:10</span><br><span class="line">TCP_CLOSING:11</span><br><span class="line"></span><br><span class="line">#获取linux服务器上数据</span><br><span class="line">cat /proc/net/tcp | awk &#x27;NR &gt; 1 &#123;</span><br><span class="line">    status=sprintf(&quot;%02X&quot;, strtonum(&quot;0x&quot;$4));</span><br><span class="line">    tcp_states[&quot;01&quot;]=&quot;TCP_ESTABLISHED&quot;;</span><br><span class="line">    tcp_states[&quot;02&quot;]=&quot;TCP_SYN_SENT&quot;;</span><br><span class="line">    tcp_states[&quot;03&quot;]=&quot;TCP_SYN_RECV&quot;;</span><br><span class="line">    tcp_states[&quot;04&quot;]=&quot;TCP_FIN_WAIT1&quot;;</span><br><span class="line">    tcp_states[&quot;05&quot;]=&quot;TCP_FIN_WAIT2&quot;;</span><br><span class="line">    tcp_states[&quot;06&quot;]=&quot;TCP_TIME_WAIT&quot;;</span><br><span class="line">    tcp_states[&quot;07&quot;]=&quot;TCP_CLOSE&quot;;</span><br><span class="line">    tcp_states[&quot;08&quot;]=&quot;TCP_CLOSE_WAIT&quot;;</span><br><span class="line">    tcp_states[&quot;09&quot;]=&quot;TCP_LAST_ACK&quot;;</span><br><span class="line">    tcp_states[&quot;0A&quot;]=&quot;TCP_LISTEN&quot;;</span><br><span class="line">    tcp_states[&quot;0B&quot;]=&quot;TCP_CLOSING&quot;;</span><br><span class="line">    print tcp_states[status];</span><br><span class="line">&#125;&#x27; | sort | uniq -c | sort -nr</span><br><span class="line"></span><br><span class="line">#获取容器上的网络数据</span><br><span class="line">kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- sh -c &quot;</span><br><span class="line">cat /proc/net/tcp | awk &#x27;NR &gt; 1 &#123;</span><br><span class="line">    status=\$4;</span><br><span class="line">    tcp_states[\&quot;01\&quot;]=\&quot;TCP_ESTABLISHED\&quot;;</span><br><span class="line">    tcp_states[\&quot;02\&quot;]=\&quot;TCP_SYN_SENT\&quot;;</span><br><span class="line">    tcp_states[\&quot;03\&quot;]=\&quot;TCP_SYN_RECV\&quot;;</span><br><span class="line">    tcp_states[\&quot;04\&quot;]=\&quot;TCP_FIN_WAIT1\&quot;;</span><br><span class="line">    tcp_states[\&quot;05\&quot;]=\&quot;TCP_FIN_WAIT2\&quot;;</span><br><span class="line">    tcp_states[\&quot;06\&quot;]=\&quot;TCP_TIME_WAIT\&quot;;</span><br><span class="line">    tcp_states[\&quot;07\&quot;]=\&quot;TCP_CLOSE\&quot;;</span><br><span class="line">    tcp_states[\&quot;08\&quot;]=\&quot;TCP_CLOSE_WAIT\&quot;;</span><br><span class="line">    tcp_states[\&quot;09\&quot;]=\&quot;TCP_LAST_ACK\&quot;;</span><br><span class="line">    tcp_states[\&quot;0A\&quot;]=\&quot;TCP_LISTEN\&quot;;</span><br><span class="line">    tcp_states[\&quot;0B\&quot;]=\&quot;TCP_CLOSING\&quot;;</span><br><span class="line">    status=sprintf(\&quot;%02X\&quot;, \&quot;0x\&quot; substr(status, 1, 2));</span><br><span class="line">    print tcp_states[status];</span><br><span class="line">&#125;&#x27; | sort | uniq -c | sort -nr</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/shispring/picgo/master/20241031145102.png" alt="tcp" title="tcp1"></p>
<hr>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://raw.githubusercontent.com/shispring/picgo/master/20241031120653.png" alt="nginx架构" title="nginx2"></p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p><img src="https://raw.githubusercontent.com/shispring/picgo/master/20241031120448.png" alt="nginx模块" title="nginx1"></p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
  </entry>
  <entry>
    <title>优秀资源</title>
    <url>/2024/09/27/nice-blog/</url>
    <content><![CDATA[<h2 id="博客类"><a href="#博客类" class="headerlink" title="博客类"></a>博客类</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//docker.nsddd.top/</span></span><br><span class="line"></span><br><span class="line">#goroutine 一些技巧</span><br><span class="line"><span class="attr">https</span>:<span class="comment">//syaning.github.io/posts/2023-06-04-goroutine.html</span></span><br></pre></td></tr></table></figure>

<h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#程序员欣宸的github</span><br><span class="line">https://github.com/zq2599/blog_demos</span><br><span class="line"></span><br><span class="line">#kubebuilder实践</span><br><span class="line">https://github.com/chenzongshu/Kubernetes/blob/master/kubebuilder/kubebuilder%E4%BB%8B%E7%BB%8D.md</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#好的知识总结</span><br><span class="line">https://github.com/mykubernetes/kubernetes/blob/master/curl%E8%AE%BF%E9%97%AEapi.md</span><br><span class="line">https://kiosk007.top/categories/</span><br><span class="line"></span><br><span class="line">#client-go教程</span><br><span class="line">https://github.com/owenliang/k8s-client-go/tree/master</span><br><span class="line">https://github.com/kubernetes/client-go/tree/master/examples/create-update-delete-deployment</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#Kubernetes 官方的示例控制器项目，展示了如何使用 client-go 和 Informers。</span><br><span class="line">https://github.com/kubernetes/sample-controller</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#一个流行的 Kubernetes Controller，用于管理 TLS 证书，代码质量高，设计优秀。</span><br><span class="line">https://github.com/cert-manager/cert-manager</span><br><span class="line"></span><br><span class="line">#正则表达式（反选:负向先行断言）</span><br><span class="line">https://www.cnblogs.com/JourneyOfFlower/p/15039751.html</span><br><span class="line"></span><br><span class="line">#https双向验证</span><br><span class="line">https://help.aliyun.com/zh/api-gateway/traditional-api-gateway/user-guide/mutual-tls-authentication</span><br><span class="line"></span><br><span class="line">#阳明博客</span><br><span class="line">https://github.com/cnych/qikqiak.com/?tab=readme-ov-file</span><br><span class="line"></span><br><span class="line">#分析源码的仓库(峰云就她了)</span><br><span class="line">https://github.com/rfyiamcool/notes</span><br><span class="line">https://xiaorui.cc/</span><br><span class="line"></span><br><span class="line">#作者整理知识相当有条例</span><br><span class="line">https://www.aneasystone.com/archives.html</span><br><span class="line"></span><br><span class="line">#ppt分享</span><br><span class="line">https://github.com/rfyiamcool/share_ppt</span><br><span class="line"></span><br><span class="line">#性能调优</span><br><span class="line">https://github.com/Miller-Xie/Linux-kernel-notes/blob/master/Linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.md</span><br><span class="line"></span><br><span class="line">#bytebytego</span><br><span class="line">https://github.com/ByteByteGoHq/system-design-101</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2023年最新整理 c++后端开发，1000篇优秀博文，含内存，网络，架构设计，高性能，数据结构，基础组件，中间件，分布式相关</span><br><span class="line">https://github.com/0voice/cpp_backend_awsome_blog</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#k8s源码分析</span><br><span class="line">https://github.com/luozhiyun993/luozhiyun-SourceLearn/tree/master/%E6%B7%B1%E5%85%A5k8s</span><br><span class="line"></span><br><span class="line">https://www.luozhiyun.com/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#基于K8s(Kubernetes)部署成PaaS/DevOp</span><br><span class="line">https://github.com/ben1234560/k8s_PaaS</span><br></pre></td></tr></table></figure>

<h2 id="chrome插件"><a href="#chrome插件" class="headerlink" title="chrome插件"></a>chrome插件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/zhaoolee/ChromeAppHeroes</span><br><span class="line">https://www.crxsoso.com/</span><br></pre></td></tr></table></figure>

<h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pv / pvc</span><br><span class="line">https://boilingfrog.github.io/2021/07/01/k8s%E4%B8%AD%E7%9A%84PV%E5%92%8CPVC%E7%90%86%E8%A7%A3/#%E4%BB%80%E4%B9%88%E6%98%AFpv%E5%92%8Cpvc</span><br><span class="line"></span><br><span class="line">## 浓缩版</span><br><span class="line">https://www.youtube.com/watch?v=SL83f7Nzxr0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 网络</span><br><span class="line">https://github.com/chenzongshu/Kubernetes</span><br><span class="line"></span><br><span class="line">## k8s应用开发神奇：Skaffold</span><br><span class="line">https://github.com/chenzongshu/Kubernetes/blob/master/k8s%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%A5%9E%E5%99%A8.md</span><br><span class="line"></span><br><span class="line">## k8s安装</span><br><span class="line">https://github.com/cby-chen/Kubernetes</span><br><span class="line">https://www.oiox.cn/</span><br><span class="line"></span><br><span class="line">https://github.com/easzlab/kubeasz</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## k8s教程</span><br><span class="line">https://github.com/kelseyhightower/kubernetes-the-hard-way</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 404频道</span><br><span class="line">http://kuring.me/</span><br><span class="line"></span><br><span class="line"># 好好学习的郝 </span><br><span class="line">https://www.voidking.com/</span><br></pre></td></tr></table></figure>

<h2 id="格言"><a href="#格言" class="headerlink" title="格言"></a>格言</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.brainyquote.com/</span><br></pre></td></tr></table></figure>

<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://segmentfault.com/a/1190000037596024</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nice-resources</category>
      </categories>
  </entry>
  <entry>
    <title>nmap常用命令解析</title>
    <url>/2024/10/21/nmap%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、常见用法及命令"><a href="#一、常见用法及命令" class="headerlink" title="一、常见用法及命令"></a><strong>一、常见用法及命令</strong></h2><ol>
<li>   <strong>扫描主机是否在线</strong>（Ping 扫描）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.1.0/24</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：检查 192.168.1.0&#x2F;24 网段内哪些主机在线。</li>
<li><strong>解释</strong>：-sn 参数禁用端口扫描，只进行主机发现。</li>
</ul>
<ol start="2">
<li>   <strong>端口扫描</strong>（默认 TCP 扫描）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap 192.168.1.1</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：扫描主机常用端口（1-1024），检查哪些端口开放。</li>
<li><strong>默认行为</strong>：使用 TCP 连接进行扫描。</li>
</ul>
<ol start="3">
<li>   <strong>扫描指定端口范围</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -p 22-80 192.168.1.1</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：扫描 192.168.1.1 上 22 到 80 端口的状态。</li>
</ul>
<ol start="4">
<li>   <strong>服务与版本检测</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sV 192.168.1.1</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：检测开放端口上运行的服务及版本信息。</li>
<li><strong>解释</strong>：-sV 参数用于版本探测。</li>
</ul>
<ol start="5">
<li>   <strong>操作系统识别</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -O 192.168.1.1</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：分析目标主机的操作系统类型及版本。</li>
<li><strong>解释</strong>：-O 参数用于启用操作系统检测。</li>
</ul>
<ol start="6">
<li>   <strong>检测网络中的所有设备</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.1.0/24 -oG - | grep Up</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：列出 192.168.1.0&#x2F;24 网段内在线的设备。</li>
</ul>
<ol start="7">
<li>   <strong>UDP 扫描</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sU -p 53,123 192.168.1.1</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong>：检测目标主机上的 UDP 端口，如 DNS（53）和 NTP（123）。</li>
<li><strong>解释</strong>：-sU 启用 UDP 扫描。</li>
</ul>
<p><strong>Nmap 脚本：针对 IP 进行一系列扫描</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方法：./nmap_scan.sh &lt;IP地址&gt;</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;请提供目标 IP 地址作为参数。&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;示例： ./nmap_scan.sh 192.168.1.1&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">TARGET_IP=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;正在探测目标主机是否在线...&quot;</span></span><br><span class="line">nmap -sn <span class="variable">$TARGET_IP</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;执行端口扫描...&quot;</span></span><br><span class="line">nmap -p 1-1000 <span class="variable">$TARGET_IP</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;检测服务版本...&quot;</span></span><br><span class="line">nmap -sV <span class="variable">$TARGET_IP</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;检测操作系统类型...&quot;</span></span><br><span class="line">nmap -O <span class="variable">$TARGET_IP</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;扫描完成！&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="二、Nmap-的-NSE-脚本功能及-SSL-TLS-扫描用法"><a href="#二、Nmap-的-NSE-脚本功能及-SSL-TLS-扫描用法" class="headerlink" title="二、Nmap 的 NSE 脚本功能及 SSL&#x2F;TLS 扫描用法"></a><strong>二、Nmap 的 NSE 脚本功能及 SSL&#x2F;TLS 扫描用法</strong></h2><p>Nmap 支持通过 <strong>NSE（Nmap Scripting Engine）脚本</strong> 执行更复杂的扫描任务，例如检测 <strong>TLS&#x2F;SSL 版本、加密算法的强度</strong>、服务漏洞扫描等。这些脚本可以帮助用户深入分析网络安全情况，尤其是检测服务的 SSL&#x2F;TLS 配置是否符合最佳实践。</p>
<p><strong>TLS&#x2F;SSL 检测的常见命令</strong></p>
<p><strong>1. 使用 ssl-enum-ciphers 检测支持的 TLS 版本及加密算法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap --script ssl-enum-ciphers -p 443 example.com</span><br></pre></td></tr></table></figure>

<p>•	<strong>作用</strong>：列出目标主机（example.com）在 443 端口上启用的 TLS 版本（如 TLS 1.0&#x2F;1.2&#x2F;1.3），以及支持的加密套件和密钥交换算法。</p>
<p>•	<strong>使用场景</strong>：验证服务器是否启用了弱 TLS 版本（如 TLS 1.0&#x2F;1.1）或不安全的加密算法。</p>
<p><strong>输出示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PORT    STATE SERVICE</span><br><span class="line">443/tcp open  https</span><br><span class="line">| ssl-enum-ciphers:</span><br><span class="line">|   TLSv1.2:</span><br><span class="line">|     ciphers:</span><br><span class="line">|       TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 - strong</span><br><span class="line">|     compressors: NONE</span><br><span class="line">|_  least strength: strong</span><br></pre></td></tr></table></figure>

<p><strong>2. 检测证书信息（ssl-cert 脚本）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap --script ssl-cert -p 443 example.com</span><br></pre></td></tr></table></figure>

<p>•	<strong>作用</strong>：显示目标服务器 SSL 证书的详细信息，包括：</p>
<p>•	证书的有效期、颁发机构（CA）。</p>
<p>•	证书链中是否有不信任的证书。</p>
<p>•	<strong>使用场景</strong>：检查证书是否即将到期，或是否使用了自签名证书。</p>
<p><strong>输出示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PORT    STATE SERVICE</span><br><span class="line">443/tcp open  https</span><br><span class="line">| ssl-cert: Subject: commonName=example.com</span><br><span class="line">| Issuer: commonName=Let<span class="string">&#x27;s Encrypt Authority</span></span><br><span class="line"><span class="string">| Public Key type: RSA</span></span><br><span class="line"><span class="string">| Public Key bits: 2048</span></span><br><span class="line"><span class="string">| Signature Algorithm: sha256WithRSAEncryption</span></span><br><span class="line"><span class="string">| Not valid before: 2024-01-01T00:00:00</span></span><br><span class="line"><span class="string">|_Not valid after: 2024-04-01T00:00:00</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 检查是否支持心脏滴血漏洞（Heartbleed - ssl-heartbleed）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap --script ssl-heartbleed -p 443 example.com</span><br></pre></td></tr></table></figure>

<p>•	<strong>作用</strong>：检测目标服务器是否存在 <strong>Heartbleed 漏洞</strong>（CVE-2014-0160）。</p>
<p>•	<strong>使用场景</strong>：验证服务器是否使用了存在此漏洞的 OpenSSL 版本。</p>
<p><strong>输出示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PORT    STATE SERVICE</span><br><span class="line">443/tcp open  https</span><br><span class="line">| ssl-heartbleed:</span><br><span class="line">|   VULNERABLE:</span><br><span class="line">|   The Heartbleed Bug is a serious vulnerability <span class="keyword">in</span> the popular OpenSSL cryptographic software library.</span><br><span class="line">|_  See: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160</span><br></pre></td></tr></table></figure>

<p><strong>其他常用 SSL&#x2F;TLS 相关 NSE 脚本</strong></p>
<table>
<thead>
<tr>
<th><strong>脚本名</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ssl-cert</td>
<td>获取并显示服务器的 SSL 证书详细信息。</td>
</tr>
<tr>
<td>ssl-enum-ciphers</td>
<td>列出所有启用的 TLS 版本及加密套件。</td>
</tr>
<tr>
<td>ssl-heartbleed</td>
<td>检查服务器是否存在 Heartbleed 漏洞。</td>
</tr>
<tr>
<td>ssl-poodle</td>
<td>检查是否存在 POODLE 漏洞（针对 SSL 3.0）。</td>
</tr>
<tr>
<td>ssl-dh-params</td>
<td>检测 Diffie-Hellman 参数的强度，检查是否易受 Logjam 攻击。</td>
</tr>
</tbody></table>
<p><strong>NSE 脚本的其他用法</strong></p>
<ol>
<li>   <strong>扫描所有常见 SSL&#x2F;TLS 相关漏洞：</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap --script ssl-* -p 443 example.com</span><br></pre></td></tr></table></figure>

<p>•	<strong>作用</strong>：一次性运行所有与 SSL 相关的脚本，检测各种安全问题。</p>
<ol start="2">
<li>   <strong>组合多个脚本扫描：</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap --script <span class="string">&quot;ssl-cert,ssl-enum-ciphers&quot;</span> -p 443 example.com</span><br></pre></td></tr></table></figure>

<p>•	<strong>作用</strong>：同时执行多个特定脚本，节省时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -p 22 --script ssh2-enum-algos &lt;ip_addr&gt;</span><br></pre></td></tr></table></figure>

<p>• <strong>作用</strong> ：检查机器ssh版本</p>
<p><strong>总结与学习建议</strong></p>
<ol>
<li><p>   ssl-enum-ciphers <strong>和</strong> ssl-cert 是日常检测 SSL&#x2F;TLS 配置的必备工具，可帮助管理员发现不安全的协议或证书问题。</p>
</li>
<li><p>   使用 NSE 脚本时，需要了解网络环境的具体需求，选择适合的脚本组合。</p>
</li>
<li><p>   <strong>学习路径</strong>：</p>
</li>
</ol>
<p>•	先熟悉基础的 Nmap 端口扫描命令。</p>
<p>•	探索 NSE 脚本的使用，逐步了解 TLS&#x2F;SSL 配置。</p>
<p>•	定期检查官方文档和社区，了解最新的安全漏洞和 Nmap 新增脚本。</p>
<p>通过以上命令与脚本，Nmap 能够帮助你快速分析 TLS&#x2F;SSL 配置是否存在问题，为网络安全提供重要保障。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>openstack一些命令</title>
    <url>/2024/12/27/openstack%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="常规操作命令"><a href="#常规操作命令" class="headerlink" title="常规操作命令"></a>常规操作命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#计算</span><br><span class="line">openstack compute service list</span><br><span class="line"></span><br><span class="line">#网络</span><br><span class="line">openstack network agent list</span><br><span class="line">openstack network list</span><br><span class="line">openstack subnet list</span><br><span class="line">openstack router list</span><br><span class="line"></span><br><span class="line">#存储</span><br><span class="line">openstack volume list</span><br><span class="line">openstack volume snapshot list</span><br><span class="line"></span><br><span class="line">#安全组</span><br><span class="line">openstack security group list</span><br><span class="line"></span><br><span class="line">#配额</span><br><span class="line">openstack quota show --all-projects</span><br><span class="line"></span><br><span class="line">#项目</span><br><span class="line">openstack project list</span><br><span class="line"></span><br><span class="line">#镜像</span><br><span class="line">openstack image list</span><br><span class="line"></span><br><span class="line">#主机</span><br><span class="line">openstack host list</span><br><span class="line"></span><br><span class="line">#主机操作</span><br><span class="line">openstack server list</span><br><span class="line">openstack server create</span><br><span class="line">openstack server show</span><br><span class="line"></span><br><span class="line">#主机规格</span><br><span class="line">openstack flavor</span><br><span class="line"></span><br><span class="line">#端口</span><br><span class="line">openstack port list</span><br><span class="line"></span><br><span class="line">#路由</span><br><span class="line">openstack router</span><br><span class="line"></span><br><span class="line">#登录地址</span><br><span class="line">openstack console url show INSTANCE_UUID</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="metadata数据查询"><a href="#metadata数据查询" class="headerlink" title="metadata数据查询"></a>metadata数据查询</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在OpenStack云主机上通过请求Metadata元数据API，来获取云主机上的主机名、IP地址、SSH公钥等信息。</span><br><span class="line">#通过这些信息可以通过编写脚本来对云主机的标准化进行定制。</span><br><span class="line"></span><br><span class="line">curl http://169.254.169.254/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>openstack</category>
      </categories>
  </entry>
  <entry>
    <title>pod重建|重启行为</title>
    <url>/2024/11/01/pod%E9%87%8D%E5%BB%BA-%E9%87%8D%E5%90%AF%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<p>在Kubernetes中，<code>Deployment</code>的更新行为是有规律的。变更<code>Deployment</code>的某些字段会触发Pod重建或重启，而某些字段的变更则不会影响Pod的运行。以下是详细的总结：</p>
<h3 id="触发Pod重建的行为"><a href="#触发Pod重建的行为" class="headerlink" title="触发Pod重建的行为"></a>触发Pod重建的行为</h3><p>以下更改会导致<code>Deployment</code>重新创建Pod，即：删除旧Pod并创建新Pod。</p>
<ol>
<li><strong>更新容器镜像</strong>：变更镜像的名称或标签（如从<code>v1</code>到<code>v2</code>）。</li>
<li><strong>资源限制和请求</strong>：变更<code>resources.requests</code>或<code>resources.limits</code>。</li>
<li><strong>环境变量</strong>：更改容器的环境变量（<code>env</code>字段）。</li>
<li><strong>亲和性和反亲和性规则</strong>：修改或添加<code>affinity</code>和<code>antiAffinity</code>。</li>
<li><strong>探针配置</strong>：更新<code>livenessProbe</code>或<code>readinessProbe</code>的配置。</li>
<li><strong>卷挂载</strong>：改变<code>volumeMounts</code>或<code>volumes</code>字段。</li>
<li><strong>initContainers</strong>或<strong>sidecar容器</strong>：添加、删除或更新init容器或sidecar容器。</li>
<li><strong>Pod标签和注解</strong>：修改影响<code>PodSpec</code>中的<code>metadata.labels</code>或<code>metadata.annotations</code>会引发Pod重建。</li>
<li><strong>端口配置</strong>：修改容器端口的配置。</li>
</ol>
<h3 id="触发Pod滚动更新但不完全重建的行为"><a href="#触发Pod滚动更新但不完全重建的行为" class="headerlink" title="触发Pod滚动更新但不完全重建的行为"></a>触发Pod滚动更新但不完全重建的行为</h3><p>一些行为会触发滚动更新，但不会删除所有Pod或引起中断：</p>
<ol>
<li><strong>RollingUpdate字段</strong>：变更<code>rollingUpdate</code>策略（如<code>maxUnavailable</code>或<code>maxSurge</code>），不会直接重建Pod，而是影响Pod的更新速率和方式。</li>
<li>**Horizontal Pod Autoscaler (HPA)**：HPA的更新不会直接导致Pod重建，但可能会根据负载情况动态调整Pod数量。</li>
</ol>
<h3 id="不会导致Pod重建或重启的行为"><a href="#不会导致Pod重建或重启的行为" class="headerlink" title="不会导致Pod重建或重启的行为"></a>不会导致Pod重建或重启的行为</h3><p>以下行为仅影响控制层，不会直接对Pod产生重启或重建的影响：</p>
<ol>
<li><strong>Deployment注解和标签</strong>：在<code>Deployment</code>级别添加或修改注解和标签，不会影响Pod。</li>
<li><strong>HPA</strong>的目标值调整（如<code>minReplicas</code>和<code>maxReplicas</code>）：更改不会重建现有Pod，而是动态扩展或缩减。</li>
<li><strong>服务配置</strong>：更新Service或Ingress的配置不会影响已存在的Pod。</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>可以使用以下命令验证某些更改是否触发了Pod重建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout status deployment &lt;deployment-name&gt;  <span class="comment"># 检查Deployment是否正在进行滚动更新</span></span><br><span class="line">kubectl get replicaset -l &lt;app-label&gt;                <span class="comment"># 查看ReplicaSet状态，观察新旧ReplicaSet</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment &lt;deployment-name&gt;  <span class="comment"># 查看变更历史</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>会重建Pod</strong>：更新镜像、资源限制、环境变量、亲和性规则、探针、卷挂载、initContainers、Pod标签、端口。</li>
<li><strong>不会重建Pod</strong>：变更HPA目标值、<code>rollingUpdate</code>策略、<code>Deployment</code>注解和标签、Service或Ingress配置。</li>
</ul>
<p>掌握这些更新行为有助于更灵活地管理Pod的生命周期。</p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>pod优雅关闭与问题排查</title>
    <url>/2024/12/24/pod%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E7%A7%AF%E7%B4%AF/</url>
    <content><![CDATA[<h2 id="1-Linux-信号与服务优雅停止"><a href="#1-Linux-信号与服务优雅停止" class="headerlink" title="1. Linux 信号与服务优雅停止"></a><strong>1. Linux 信号与服务优雅停止</strong></h2><p>服务在停止前需要收到信号通知以进行资源释放、关闭连接等清理操作。以下是常见信号及其特性：</p>
<h3 id="常见信号"><a href="#常见信号" class="headerlink" title="常见信号"></a><strong>常见信号</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line">HUP INT QUIT ILL TRAP ABRT EMT FPE KILL BUS SEGV SYS PIPE ALRM TERM ...</span><br></pre></td></tr></table></figure>

<ul>
<li>**SIGKILL (9)**：<ul>
<li>强制结束程序，无法捕获、阻塞或忽略。</li>
<li><strong>退出状态码</strong>：<code>128 + 9 = 137</code>。</li>
</ul>
</li>
<li>**SIGTERM (15)**：<ul>
<li>可被程序捕获，用于优雅停止。</li>
<li><strong>退出状态码</strong>：<code>128 + 15 = 143</code>。</li>
</ul>
</li>
</ul>
<h3 id="退出状态码范围"><a href="#退出状态码范围" class="headerlink" title="退出状态码范围"></a><strong>退出状态码范围</strong></h3><ul>
<li><strong>0</strong>：正常退出。</li>
<li><strong>1-128</strong>：程序自身异常退出。</li>
<li><strong>129-255</strong>：外部信号导致退出。</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><ul>
<li><code>systemctl reload docker</code>：重新加载 Docker 配置文件，不中断运行中的容器。</li>
<li><code>systemctl restart docker</code>：重启 Docker 服务，会停止并重新启动所有容器。</li>
</ul>
<hr>
<h2 id="2-Pod-优雅关闭"><a href="#2-Pod-优雅关闭" class="headerlink" title="2. Pod 优雅关闭"></a><strong>2. Pod 优雅关闭</strong></h2><p>优雅关闭确保 Pod 在终止时不会中断服务、影响数据一致性或浪费资源。</p>
<h3 id="优雅关闭的作用"><a href="#优雅关闭的作用" class="headerlink" title="优雅关闭的作用"></a><strong>优雅关闭的作用</strong></h3><ol>
<li><strong>避免服务中断</strong>：完成当前请求后再终止。</li>
<li><strong>确保数据一致性</strong>：允许数据持久化或事务处理。</li>
<li><strong>最小化用户影响</strong>：避免流量路由到已删除的 Pod。</li>
<li><strong>提高资源利用率</strong>：释放资源，避免泄露。</li>
</ol>
<h3 id="优雅关闭时间线"><a href="#优雅关闭时间线" class="headerlink" title="优雅关闭时间线"></a><strong>优雅关闭时间线</strong></h3><h3 id="时间线-1：网络层面的优雅关闭"><a href="#时间线-1：网络层面的优雅关闭" class="headerlink" title="时间线 1：网络层面的优雅关闭"></a><strong>时间线 1：网络层面的优雅关闭</strong></h3><ol>
<li><p><strong>Service Endpoint 移除</strong>：</p>
<ul>
<li><p>Pod 进入 <code>Terminating</code> 状态后，从 Service 的 Endpoint 列表中移除。</p>
</li>
<li><p><strong>检查点</strong>：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get endpoints &lt;service-name&gt; -o yaml</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>NetworkPolicy 规则清理</strong>：</p>
<ul>
<li>清理与 Pod 相关的网络规则。</li>
<li><strong>检查点</strong>：CNI 插件日志（如 Calico、Cilium）。</li>
</ul>
</li>
<li><p><strong>负载均衡器更新</strong>：</p>
<ul>
<li><p>从后端池中移除 Pod 地址。</p>
</li>
<li><p><strong>检查点</strong>：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe ingress &lt;ingress-name&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="时间线-2：Pod-的关闭步骤"><a href="#时间线-2：Pod-的关闭步骤" class="headerlink" title="时间线 2：Pod 的关闭步骤"></a><strong>时间线 2：Pod 的关闭步骤</strong></h3><ol>
<li><p><strong>SIGTERM 信号发送</strong>：</p>
<ul>
<li><p>通知容器内应用进行清理。</p>
</li>
<li><p><strong>检查点</strong>：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>PreStop Hook 执行</strong>：</p>
<ul>
<li>执行清理脚本。</li>
<li><strong>检查点</strong>：查看容器日志。</li>
</ul>
</li>
<li><p><strong>容器优雅退出</strong>：</p>
<ul>
<li>处理 SIGTERM 信号。</li>
<li><strong>检查点</strong>：确认长连接或挂起任务是否处理。</li>
</ul>
</li>
<li><p>**强制终止 (SIGKILL)**：</p>
<ul>
<li>超过 <code>terminationGracePeriodSeconds</code> 后，发送 SIGKILL。</li>
<li><strong>检查点</strong>：查看 kubelet 日志。</li>
</ul>
</li>
<li><p><strong>资源清理</strong>：</p>
<ul>
<li><p>卸载存储卷，释放网络资源。</p>
</li>
<li><p><strong>检查点</strong>：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pv,pvc</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-Pod-删除原理"><a href="#3-Pod-删除原理" class="headerlink" title="3. Pod 删除原理"></a><strong>3. Pod 删除原理</strong></h2><h3 id="触发-Pod-删除的场景"><a href="#触发-Pod-删除的场景" class="headerlink" title="触发 Pod 删除的场景"></a><strong>触发 Pod 删除的场景</strong></h3><ol>
<li><strong>手动删除</strong>：<code>kubectl delete pod</code>。</li>
<li><strong>控制器策略</strong>：如 Deployment 缩减副本数。</li>
<li><strong>节点故障</strong>：节点失效后重新调度。</li>
<li><strong>资源限制</strong>：节点资源不足时删除低优先级 Pod。</li>
<li><strong>健康检查失败</strong>：探针连续失败。</li>
<li><strong>优先级抢占</strong>：释放资源给高优先级 Pod。</li>
<li><strong>更新策略</strong>：滚动更新替换旧 Pod。</li>
<li><strong>自动缩放</strong>：集群缩小时删除 Pod。</li>
</ol>
<hr>
<h2 id="4-Pod-长时间处于-Terminating-状态的原因"><a href="#4-Pod-长时间处于-Terminating-状态的原因" class="headerlink" title="4. Pod 长时间处于 Terminating 状态的原因"></a><strong>4. Pod 长时间处于 Terminating 状态的原因</strong></h2><ol>
<li><strong>存储未卸载</strong>：持久卷未成功释放。</li>
<li><strong>容器未终止</strong>：未正确响应 SIGTERM。</li>
<li><strong>Finalizer 阻塞</strong>：清理任务未完成。</li>
<li><strong>网络或 API Server 问题</strong>：通信异常。</li>
<li><strong>节点异常</strong>：节点不可用。</li>
</ol>
<h3 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a><strong>排查思路</strong></h3><ol>
<li><p><strong>查看 Pod 信息</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查 Pod 的 Finalizer</span></span><br><span class="line">kubectl get pod &lt;pod-name&gt; -n &lt;namespace&gt; -o jsonpath=<span class="string">&#x27;&#123;.metadata.finalizers&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查容器状态</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod &lt;pod-name&gt; -o jsonpath=<span class="string">&#x27;&#123;.status.containerStatuses[*].state&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查节点状态</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>检查存储状态</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pvc</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>强制删除 Pod</strong>：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete pod &lt;pod-name&gt; --force --grace-period=0</span><br><span class="line"></span><br><span class="line"><span class="comment">#发送 SIGTERM 信号的几种方式</span></span><br><span class="line"><span class="built_in">kill</span> -15 &lt;container-id&gt;</span><br><span class="line">docker <span class="built_in">kill</span> --signal=SIGTERM &lt;container-id&gt;</span><br><span class="line"><span class="comment">#如果使用 crictl： crictl stop &lt;container-id&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#强制重新触发优雅终止,例如，将宽限期设置为 10 秒：</span></span><br><span class="line">kubectl delete pod &lt;pod-name&gt; -n &lt;namespace&gt; --grace-period=10</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="5-Docker-与-Containerd-的日志排查"><a href="#5-Docker-与-Containerd-的日志排查" class="headerlink" title="5. Docker 与 Containerd 的日志排查"></a><strong>5. Docker 与 Containerd 的日志排查</strong></h2><h3 id="检查-Docker-日志"><a href="#检查-Docker-日志" class="headerlink" title="检查 Docker 日志"></a><strong>检查 Docker 日志</strong></h3><ol>
<li><p>查看 Docker 守护进程日志：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">journalctl -u docker | grep &lt;docker_id&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查 kubelet 清理失败记录：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">journalctl -u kubelet | grep <span class="string">&quot;cleanup&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="清理-Docker-残留资源"><a href="#清理-Docker-残留资源" class="headerlink" title="清理 Docker 残留资源"></a><strong>清理 Docker 残留资源</strong></h3><ol>
<li><p>删除退出的容器：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container prune -f</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除未使用的镜像：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image prune -a</span><br></pre></td></tr></table></figure>
</li>
<li><p>清理未使用的网络和卷：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network prune -f</span><br><span class="line">docker volume prune -f</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="清理-Containerd-残留资源"><a href="#清理-Containerd-残留资源" class="headerlink" title="清理 Containerd 残留资源"></a><strong>清理 Containerd 残留资源</strong></h3><ol>
<li><p>删除残留容器：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crictl <span class="built_in">rm</span> $(crictl ps -a -q)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除未使用的镜像：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crictl rmi &lt;image-id&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="6-最佳实践"><a href="#6-最佳实践" class="headerlink" title="6. 最佳实践"></a><strong>6. 最佳实践</strong></h2><ol>
<li><strong>配置优雅终止</strong>：<ul>
<li>设置 <code>terminationGracePeriodSeconds</code>。</li>
<li>配置 PreStop Hook。</li>
</ul>
</li>
<li><strong>监控和告警</strong>：<ul>
<li>使用 Prometheus 检测 <code>Terminating</code> 状态 Pod。</li>
</ul>
</li>
<li><strong>避免 Finalizer 阻塞</strong>：<ul>
<li>确保 Finalizer 正常完成任务。</li>
</ul>
</li>
<li><strong>定期清理残留资源</strong>：<ul>
<li>检查并清理未使用的容器、镜像和存储。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>promQL整理</title>
    <url>/2024/12/23/promQL%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="CPU维度统计集群资源碎片"><a href="#CPU维度统计集群资源碎片" class="headerlink" title="CPU维度统计集群资源碎片"></a>CPU维度统计集群资源碎片</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 根据需求定义变量：cluster、cores</span><br><span class="line">sum(</span><br><span class="line">  floor(</span><br><span class="line">    (</span><br><span class="line">      sum(</span><br><span class="line">        kube_node_status_allocatable&#123;cluster=~&quot;$cluster&quot;, resource=&quot;cpu&quot;, node=~&quot;^docker.*&quot;&#125; </span><br><span class="line">        * on(node) group_left() kube_node_labels&#123;cluster=~&quot;$cluster&quot;,label_node_role_kubernetes_io_worker=&quot;true&quot;&#125;</span><br><span class="line">      ) by (cluster, node)</span><br><span class="line">      -</span><br><span class="line">      sum(</span><br><span class="line">        kube_pod_container_resource_requests&#123;cluster=~&quot;$cluster&quot;, resource=&quot;cpu&quot;, node=~&quot;^docker.*&quot;&#125; </span><br><span class="line">        * on(node) group_left() kube_node_labels&#123;cluster=~&quot;$cluster&quot;,label_node_role_kubernetes_io_worker=&quot;true&quot;&#125;</span><br><span class="line">      ) by (cluster, node)</span><br><span class="line">    ) / $cores</span><br><span class="line">  ) &gt; 0</span><br><span class="line">) by (cluster)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>rsync用法小记</title>
    <url>/2024/12/25/rsync%E7%94%A8%E6%B3%95%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="rsync-命令的参数含义"><a href="#rsync-命令的参数含义" class="headerlink" title="rsync 命令的参数含义"></a><strong>rsync 命令的参数含义</strong></h3><p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -avzP -e <span class="string">&#x27;ssh -p2222&#x27;</span> test.tar.gz root@192.168.1.100:/data</span><br></pre></td></tr></table></figure>

<h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a><strong>参数解释</strong></h4><ol>
<li><p><strong><code>-a</code> (archive mode)</strong>  </p>
<ul>
<li>归档模式，表示递归同步目录并保留文件属性（如权限、时间戳、符号链接等）。  </li>
<li>常用于完整备份。</li>
</ul>
</li>
<li><p><strong><code>-v</code> (verbose)</strong>  </p>
<ul>
<li>显示详细信息，输出同步过程中的文件名和进度。</li>
</ul>
</li>
<li><p><strong><code>-z</code> (compress)</strong>  </p>
<ul>
<li>启用压缩，在传输过程中压缩数据以减少带宽使用。</li>
</ul>
</li>
<li><p><strong><code>-P</code> (progress + partial)</strong>  </p>
<ul>
<li>显示传输进度条（<code>--progress</code>）。</li>
<li>保留部分传输的文件（<code>--partial</code>），如果传输中断，可以继续。</li>
</ul>
</li>
<li><p><strong><code>-e &#39;ssh -p2222&#39;</code></strong>  </p>
<ul>
<li>指定使用 <code>ssh</code> 作为远程传输协议，并通过 <code>-p2222</code> 指定 SSH 使用的端口号为 <code>2222</code>。</li>
</ul>
</li>
<li><p><strong><code>test.tar.gz</code></strong>  </p>
<ul>
<li>要同步的源文件。</li>
</ul>
</li>
<li><p><strong><code>root@192.169.1.100:/data</code></strong>  </p>
<ul>
<li>目标地址：<ul>
<li><code>root</code> 是远程服务器的用户名。</li>
<li><code>1.95.89.84</code> 是远程服务器的 IP 地址。</li>
<li><code>/data</code> 是目标路径，表示文件将被传输到该目录。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="常用-rsync-命令参数总结"><a href="#常用-rsync-命令参数总结" class="headerlink" title="常用 rsync 命令参数总结"></a><strong>常用 rsync 命令参数总结</strong></h3><h4 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a><strong>基础功能</strong></h4><ul>
<li><strong><code>-a</code></strong>: 归档模式（保留权限、时间戳、符号链接等）。</li>
<li><strong><code>-r</code></strong>: 递归复制子目录（仅递归，不保留属性）。</li>
<li><strong><code>-v</code></strong>: 显示详细信息。</li>
<li><strong><code>-z</code></strong>: 压缩传输。</li>
<li><strong><code>-P</code></strong>: 显示进度条并支持断点续传。</li>
</ul>
<h4 id="进阶选项"><a href="#进阶选项" class="headerlink" title="进阶选项"></a><strong>进阶选项</strong></h4><ul>
<li><strong><code>--delete</code></strong>: 在目标中删除源中不存在的文件，保持两端一致。</li>
<li><strong><code>--exclude=PATTERN</code></strong>: 排除匹配指定模式的文件或目录。</li>
<li><strong><code>--include=PATTERN</code></strong>: 包括匹配指定模式的文件或目录。</li>
<li><strong><code>--progress</code></strong>: 显示详细的传输进度信息。</li>
<li><strong><code>--partial</code></strong>: 断点续传，保留部分传输的文件。</li>
<li><strong><code>--bwlimit=RATE</code></strong>: 限制带宽（以 KB&#x2F;s 为单位）。</li>
</ul>
<h4 id="远程传输"><a href="#远程传输" class="headerlink" title="远程传输"></a><strong>远程传输</strong></h4><ul>
<li><strong><code>-e ssh</code></strong>: 指定使用 SSH 作为传输协议。</li>
<li><strong><code>-e &#39;ssh -pPORT&#39;</code></strong>: 使用特定的 SSH 端口。</li>
<li><strong><code>--rsync-path=PATH</code></strong>: 指定远程服务器上的 rsync 路径。</li>
</ul>
<h4 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a><strong>同步模式</strong></h4><ul>
<li><strong>本地到本地</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -av /src/dir /dest/dir</span><br></pre></td></tr></table></figure></li>
<li><strong>本地到远程</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -av /src/dir user@remote:/dest/dir</span><br></pre></td></tr></table></figure></li>
<li><strong>远程到本地</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -av user@remote:/src/dir /dest/dir</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h4><ol>
<li><p><strong>同步文件并显示进度</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -avzP file.txt user@remote:/path/to/destination</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>排除某些文件或目录</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;*.log&#x27;</span> /src/dir user@remote:/dest/dir</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同步并删除目标多余文件</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -av --delete /src/dir user@remote:/dest/dir</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>限制带宽</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -avz --bwlimit=1000 /src/dir user@remote:/dest/dir</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用特定 SSH 端口</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -avz -e <span class="string">&#x27;ssh -p2222&#x27;</span> /src/dir user@remote:/dest/dir</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过这些参数和命令，可以高效地实现文件同步和备份。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>shell根据输入月份，遍历当月日期</title>
    <url>/2022/10/31/shell-date-%E6%89%93%E5%8D%B0%E6%9C%88%E6%97%A5%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="shell脚本详情"><a href="#shell脚本详情" class="headerlink" title="shell脚本详情"></a>shell脚本详情</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;年月格式：2022年5月，则输入2022-05&quot;</span><br><span class="line">read -p &quot;请输入年月份：&quot; VAR</span><br><span class="line"></span><br><span class="line">#VAR=&quot;2022-06&quot;</span><br><span class="line"></span><br><span class="line">#当月第一天</span><br><span class="line">firstDay=`date  -d &quot;$&#123;VAR&#125;-01&quot; +%Y-%m-%d`</span><br><span class="line">#当月最后一天</span><br><span class="line">lastDay=`date  -d &quot;+1month -1day $&#123;VAR&#125;-01&quot;  +%Y-%m-%d`</span><br><span class="line"></span><br><span class="line">#使用数组存储每一天</span><br><span class="line">array_date=()</span><br><span class="line"></span><br><span class="line">#遍历月分的每一天</span><br><span class="line">firstDayTimestamp=`date -d &quot;$firstDay&quot; +%s`</span><br><span class="line">lastDayTimestamp=`date -d &quot;$lastDay&quot; +%s`</span><br><span class="line"></span><br><span class="line">for((currentTimestamp=$firstDayTimestamp; currentTimestamp &lt;= lastDayTimestamp; ));</span><br><span class="line">do</span><br><span class="line">    currentDay=`date -d@$currentTimestamp +%Y-%m-%d`</span><br><span class="line">    array_date[$&#123;#array_date[@]&#125;]=$currentDay</span><br><span class="line">    currentTimestamp=`expr $currentTimestamp + 86400`</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $&#123;#array_date[*]&#125;</span><br><span class="line">echo $&#123;array_date[*]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>swagger部署open api</title>
    <url>/2024/09/27/swagger%E9%83%A8%E7%BD%B2k8s-open-api/</url>
    <content><![CDATA[<h3 id="一、导出k8s-API配置"><a href="#一、导出k8s-API配置" class="headerlink" title="一、导出k8s API配置"></a>一、导出k8s API配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#临时启动服务</span></span><br><span class="line">kubectl proxy --port=8082</span><br><span class="line"><span class="comment">#导出配置</span></span><br><span class="line">curl http://localhost:8082/openapi/v2 &gt; k8s-swagger.json</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二、启动服务"><a href="#二、启动服务" class="headerlink" title="二、启动服务"></a>二、启动服务</h3><ul>
<li>docker启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8999:8080 \</span><br><span class="line">    -e SWAGGER_JSON=/k8s-swagger.json \</span><br><span class="line">    -v $(<span class="built_in">pwd</span>)/k8s-swagger.json:/k8s-swagger.json \</span><br><span class="line">    swaggerapi/swagger-ui</span><br></pre></td></tr></table></figure>

<ul>
<li>docker-compose启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#vim docker-compose.yaml</span></span><br><span class="line"></span><br><span class="line">version: <span class="string">&quot;3&quot;</span></span><br><span class="line">services:</span><br><span class="line">  document:</span><br><span class="line">    environment:</span><br><span class="line">      - SWAGGER_JSON=/k8s-swagger.json</span><br><span class="line">    image: swaggerapi/swagger-ui</span><br><span class="line">    volumes:</span><br><span class="line">      - ./k8s-swagger.json:/k8s-swagger.json</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8899:8080&quot;</span></span><br><span class="line">  editor:</span><br><span class="line">    image: swaggerapi/swagger-editor</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;9988:8080&quot;</span></span><br><span class="line">      </span><br><span class="line"> </span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">docker-compose -f ./docker-compose.yaml up -d </span><br><span class="line"><span class="comment">#查看服务    </span></span><br><span class="line">docker-compose -f ./docker-compose.yaml ps</span><br><span class="line"><span class="comment">#停止服务</span></span><br><span class="line">docker-compose -f ./docker-compose.yaml down</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="harbor-openAPI-使用官方-Swagger-YAML-文件"><a href="#harbor-openAPI-使用官方-Swagger-YAML-文件" class="headerlink" title="harbor openAPI 使用官方 Swagger YAML 文件"></a>harbor openAPI 使用官方 Swagger YAML 文件</h2><p>访问 Harbor GitHub 仓库，下载最新的 <code>swagger.yaml</code>，然后本地加载：</p>
<ul>
<li><p>Harbor Swagger 定义文件：</p>
<ul>
<li>GitHub 地址（最新）：<br><a href="https://github.com/goharbor/harbor/blob/main/api/v2.0/swagger.yaml">https://github.com/goharbor/harbor/blob/main/api/v2.0/swagger.yaml</a></li>
</ul>
</li>
<li><p>使用方式：</p>
<ol>
<li>下载 <code>swagger.yaml</code> 文件；</li>
<li>打开 <a href="https://editor.swagger.io/">Swagger Editor 在线工具</a>；</li>
<li>File → Import File → 加载该文件，即可获得可视化 API 文档。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>tcpdump抓包的几个命令</title>
    <url>/2025/01/07/tcpdump%E6%8A%93%E5%8C%85%E7%9A%84%E5%87%A0%E4%B8%AA%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul>
<li>-i any 监听所有的网卡接口，用来查看是否有网络流量</li>
<li>-i eth0 只监听eth0网卡接口</li>
<li>-D 显示可用的接口列表</li>
<li>-n 不要解析主机名</li>
<li>-nn 不要解析主机名或者端口名</li>
<li>-q 显示更少的输出(更加quiet)</li>
<li>-t 输出可读的时间戳</li>
<li>-tttt 输出最大程度可读的时间戳</li>
<li>-X 以hex和ASCII两种形式显示包的内容</li>
<li>-XX 与**-X**类似，增加以太网header的显示</li>
<li>-v, -vv, -vvv 显示更加多的包信息</li>
<li>-c 只读取x个包，然后停止</li>
<li>-s 指定每一个包捕获的长度，单位是byte，使用 -s 0 可以捕获整个包的内容</li>
<li>-S 输出绝对的序列号</li>
<li>-e 获取以太网header</li>
<li>-E 使用提供的秘钥解密IPSEC流量</li>
</ul>
<hr>
<h2 id="tcpdump-一些命令"><a href="#tcpdump-一些命令" class="headerlink" title="tcpdump 一些命令"></a>tcpdump 一些命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看网络接口列表:</span><br><span class="line">tcpdump -D</span><br><span class="line"></span><br><span class="line">简单抓包：</span><br><span class="line">抓取某接口的所有流量：</span><br><span class="line">tcpdump -i eth0</span><br><span class="line"></span><br><span class="line">保存抓包文件:</span><br><span class="line">sudo tcpdump -i eth0 -w capture.pcap</span><br><span class="line"></span><br><span class="line">抓取指定IP地址的数据包:</span><br><span class="line">只抓取源地址或目标地址为 `192.168.3.110` 的流量</span><br><span class="line">sudo tcpdump -i eth0 host 192.168.3.110</span><br><span class="line"></span><br><span class="line">抓取HTTP流量（端口8080）：</span><br><span class="line">sudo tcpdump -i eth0 port 8080</span><br><span class="line"></span><br><span class="line">抓取多个端口：</span><br><span class="line">sudo tcpdump -i eth0 portrange 8000-9000</span><br><span class="line"></span><br><span class="line">抓取TCP流量</span><br><span class="line">sudo tcpdump -i eth0 tcp</span><br><span class="line">抓取UDP流量</span><br><span class="line">sudo tcpdump -i eth0 udp</span><br><span class="line"></span><br><span class="line">抓取ICMP流量（如ping）：</span><br><span class="line">sudo tcpdump -i eth0 icmp</span><br><span class="line"></span><br><span class="line">抓取指定源地址和目标端口的数据包：</span><br><span class="line">sudo tcpdump -i eth0 src 192.168.3.110 and port 22</span><br><span class="line">逻辑运算符： and：与 or ：或  not：非</span><br><span class="line"></span><br><span class="line">显示数据包的详细信息:</span><br><span class="line">sudo tcpdump -i eth0 -v</span><br><span class="line"></span><br><span class="line">如果流量异常密集，可以通过 `-c` 限制抓包数量</span><br><span class="line">sudo tcpdump -i eth0 port 22 -c 100</span><br><span class="line"></span><br><span class="line">抓包文件过大,每10MB保存一个文件</span><br><span class="line">sudo tcpdump -i eth0 -w capture.pcap -C 10</span><br><span class="line"></span><br><span class="line">读取包内容</span><br><span class="line">sudo tcpdump -r capture.pcap</span><br><span class="line"></span><br><span class="line">抓取指定时间范围的包，抓包10秒后自动停止</span><br><span class="line">timeout 10s tcpdump -i eth0</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table>
<thead>
<tr>
<th><strong>需求</strong></th>
<th><strong>命令</strong></th>
</tr>
</thead>
<tbody><tr>
<td>捕获指定接口流量</td>
<td><code>sudo tcpdump -i eth0</code></td>
</tr>
<tr>
<td>捕获指定端口流量</td>
<td><code>sudo tcpdump -i eth0 port 80</code></td>
</tr>
<tr>
<td>保存抓包到文件</td>
<td><code>sudo tcpdump -i eth0 -w capture.pcap</code></td>
</tr>
<tr>
<td>限制抓包数量</td>
<td><code>sudo tcpdump -i eth0 -c 100</code></td>
</tr>
<tr>
<td>过滤特定源 IP 或目标 IP</td>
<td><code>sudo tcpdump -i eth0 src host 192.168.1.10</code></td>
</tr>
<tr>
<td>过滤特定协议</td>
<td><code>sudo tcpdump -i eth0 tcp</code></td>
</tr>
<tr>
<td>输出包详细内容</td>
<td><code>sudo tcpdump -i eth0 -X</code></td>
</tr>
<tr>
<td>限制包的大小</td>
<td><code>sudo tcpdump -i eth0 -s 128</code></td>
</tr>
<tr>
<td>捕获 DNS 流量</td>
<td><code>sudo tcpdump -i eth0 port 53 -vvv</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="抓包ingress请求case"><a href="#抓包ingress请求case" class="headerlink" title="抓包ingress请求case"></a>抓包ingress请求case</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#抓包请求</span><br><span class="line">curl -H &quot;host:test.xxx.com&quot; http://10.221.100.200/api/v1/xxx</span><br><span class="line">#查看日志输出</span><br><span class="line">crictl logs  -f &lt;container-id&gt; 2&gt;&amp;1 | grep &quot;/api/v1/xxx&quot;</span><br><span class="line">#抓包过滤</span><br><span class="line">tcpdump -i eth0  -ttt -nnn -v dst host 10.221.100.200 and port 80 and src host 10.100.100.100</span><br></pre></td></tr></table></figure>

<h2 id="抓包脚本及注意事项"><a href="#抓包脚本及注意事项" class="headerlink" title="抓包脚本及注意事项"></a>抓包脚本及注意事项</h2><ul>
<li>使用ifconfig查看要抓的源ip的网卡(要知道请求ip地址所在网卡)</li>
<li>或者使用bmon 或者 iptraf-ng 查看网卡的流量</li>
<li>或者设定要抓取的网卡（也可以指定为：any）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 输出以时间戳命名的 pcap 文件，便于后续 Wireshark 分析</span><br><span class="line"></span><br><span class="line">VIP=&quot;10.xxx.xxx.xxx&quot;</span><br><span class="line">PORT=&quot;443&quot;</span><br><span class="line">DURATION=60  # 抓包时长，单位为秒，可根据需要修改</span><br><span class="line">OUT_FILE=&quot;./tcpdump_k8s_$(date +%Y%m%d_%H%M%S).pcap&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;[*] Starting tcpdump for $DURATION seconds on host $VIP:$PORT...&quot;</span><br><span class="line">sudo timeout $DURATION tcpdump -i any host $VIP and port $PORT -ttt -nn -vv -s 0 -w $OUT_FILE</span><br><span class="line"></span><br><span class="line">echo &quot;[+] Capture complete: $OUT_FILE&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p><a href="https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B.md">github参考</a></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
  </entry>
  <entry>
    <title>terminating的pod排查思路</title>
    <url>/2024/12/23/terminating%E7%9A%84pod%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="Pod-处于-Terminating-状态的原因"><a href="#Pod-处于-Terminating-状态的原因" class="headerlink" title="Pod 处于 Terminating 状态的原因"></a><strong>Pod 处于 <code>Terminating</code> 状态的原因</strong></h3><p>Pod 长时间处于 <code>Terminating</code> 状态，通常是因为 Kubernetes 在删除 Pod 时未能正常完成某些清理操作。以下是可能的原因：</p>
<ol>
<li><strong>挂载的存储未能正常卸载</strong>：<ul>
<li>Pod 使用了持久卷（PV），但存储卸载失败，导致 Pod 资源无法释放。</li>
</ul>
</li>
<li><strong>容器未能正常终止</strong>：<ul>
<li>Pod 中的容器未能按预期响应 <code>SIGTERM</code> 信号。</li>
<li>容器运行时（如 containerd、CRI-O）可能出现问题，导致容器未能被删除。</li>
</ul>
</li>
<li><strong>Finalizer 阻塞</strong>：<ul>
<li>Pod 定义中包含了 <code>finalizer</code>，但未能按预期完成清理操作。</li>
</ul>
</li>
<li><strong>网络或 API Server 问题</strong>：<ul>
<li>Kubernetes API Server 无法与节点通信，导致删除指令未能执行。</li>
</ul>
</li>
<li><strong>节点异常</strong>：<ul>
<li>Pod 所在的节点已不可用，但 Kubernetes 仍尝试与该节点交互。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="Kubernetes-垃圾回收机制"><a href="#Kubernetes-垃圾回收机制" class="headerlink" title="Kubernetes 垃圾回收机制"></a><strong>Kubernetes 垃圾回收机制</strong></h3><ol>
<li><strong>默认行为</strong>：<ul>
<li>Kubernetes 的垃圾回收机制会尝试清理处于 <code>Terminating</code> 状态的 Pod，但这依赖于集群的健康状态和 Pod 的配置。</li>
</ul>
</li>
<li><strong>Finalizer 的影响</strong>：<ul>
<li>如果 Pod 含有未完成的 <code>finalizer</code>，垃圾回收机制不会自动删除 Pod。</li>
</ul>
</li>
<li><strong>节点不可用的情况</strong>：<ul>
<li>如果节点长时间不可用，Kubernetes 会将节点标记为 <code>NotReady</code>，并最终删除相关 Pod，但需要依赖 <code>node-ttl</code> 等配置。</li>
</ul>
</li>
</ol>
<p>因此，如果 Pod 长时间处于 <code>Terminating</code> 状态且无人干预，它可能会一直保留在集群中，特别是当某些资源清理失败时。</p>
<hr>
<h3 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a><strong>排查思路</strong></h3><ol>
<li><p><strong>查看 Pod 的详细信息</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>检查 Events</strong>：<ul>
<li>查看是否有与存储、容器终止或 Finalizer 相关的错误。</li>
</ul>
</li>
<li><strong>检查 Finalizer</strong>：<ul>
<li>Pod 的 <code>metadata.finalizers</code> 是否未被清理。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>检查 Pod 的容器状态</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod &lt;pod-name&gt; -n &lt;namespace&gt; -o jsonpath=<span class="string">&#x27;&#123;.status.containerStatuses[*].state&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>确认容器是否已经终止。</li>
<li>如果容器未能正常终止，可能需要进一步排查容器运行时。</li>
</ul>
</li>
<li><p><strong>检查节点状态</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<ul>
<li>Pod 所在节点是否处于 <code>Ready</code> 状态。</li>
<li>如果节点不可用，Pod 的删除可能被阻塞。</li>
</ul>
</li>
<li><p><strong>检查存储状态</strong>：</p>
<ul>
<li>如果 Pod 使用了存储卷，检查卷是否被成功卸载：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pvc -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure></li>
<li>查看相关 PV 和存储系统的状态。</li>
</ul>
</li>
<li><p><strong>检查网络和 API Server</strong>：</p>
<ul>
<li>查看 API Server 和 kubelet 的日志，确认是否存在通信问题：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">journalctl -u kubelet</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>强制删除 Pod</strong>：<br>如果问题无法解决，可以强制删除 Pod，但要谨慎：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete pod &lt;pod-name&gt; -n &lt;namespace&gt; --force --grace-period=0</span><br></pre></td></tr></table></figure>
<ul>
<li>此操作会跳过 Finalizer 和清理过程。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h3><ol>
<li><strong>设置合理的终止行为</strong>：<ul>
<li>在 Pod 的 <code>spec</code> 中设置 <code>terminationGracePeriodSeconds</code>，确保容器有足够时间完成清理。</li>
</ul>
</li>
<li><strong>监控和告警</strong>：<ul>
<li>配置监控工具（如 Prometheus 和 Grafana）以检测长时间处于 <code>Terminating</code> 状态的 Pod。</li>
</ul>
</li>
<li><strong>避免 Finalizer 阻塞</strong>：<ul>
<li>确保使用的 Finalizer 能正常完成清理任务。</li>
</ul>
</li>
<li><strong>定期检查节点状态</strong>：<ul>
<li>确保节点健康，及时清理不可用的节点。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>k8s</category>
        <category>pod</category>
      </categories>
  </entry>
  <entry>
    <title>tools</title>
    <url>/2024/12/26/useful-tools/</url>
    <content><![CDATA[<h2 id="termtosvg-录制终端会话"><a href="#termtosvg-录制终端会话" class="headerlink" title="termtosvg : 录制终端会话"></a>termtosvg : 录制终端会话</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用pyenv安装多版本python</span><br><span class="line">which python</span><br><span class="line"></span><br><span class="line">pip3 install termtosvg</span><br><span class="line"></span><br><span class="line">#使用</span><br><span class="line">termtosvg</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">#可以使用浏览器打开生成的svg</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="asciinema-录制终端会话"><a href="#asciinema-录制终端会话" class="headerlink" title="asciinema : 录制终端会话"></a>asciinema : 录制终端会话</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install asciinema </span><br><span class="line"></span><br><span class="line">asciinema rec session.cast</span><br><span class="line">asciinema play session.cast</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#brew install agg</span><br><span class="line">agg session.cast first.gif</span><br></pre></td></tr></table></figure>

<h2 id="lolcat-彩虹🌈输出"><a href="#lolcat-彩虹🌈输出" class="headerlink" title="lolcat (彩虹🌈输出)"></a>lolcat (彩虹🌈输出)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install lolcat</span><br><span class="line"></span><br><span class="line">#lolcat --help</span><br></pre></td></tr></table></figure>

<h2 id="inkscape-：-svg转png"><a href="#inkscape-：-svg转png" class="headerlink" title="inkscape ： svg转png"></a>inkscape ： svg转png</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install --cask inkscape</span><br><span class="line">#或者</span><br><span class="line">#brew install librsvg</span><br><span class="line"></span><br><span class="line">inkscape 1.svg --export-type=png --export-filename=1.png</span><br><span class="line">inkscape 2.svg --export-type=png --export-filename=2.png</span><br><span class="line">inkscape 3.svg --export-type=png --export-filename=3.png</span><br><span class="line"></span><br><span class="line">#rsvg-convert 1.svg -o 1.png</span><br><span class="line">#rsvg-convert 2.svg -o 2.png</span><br><span class="line">#rsvg-convert 3.svg -o 3.png</span><br><span class="line"></span><br><span class="line">#svg转gif</span><br><span class="line">magick -delay 100 1.png 2.png 3.png output.gif</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="cloc-统计代码"><a href="#cloc-统计代码" class="headerlink" title="cloc 统计代码"></a>cloc 统计代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#github地址</span><br><span class="line">https://github.com/AlDanial/cloc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="kyanos"><a href="#kyanos" class="headerlink" title="kyanos"></a>kyanos</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kyanos 是一个网络流量采集和分析工具</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="远程桌面rustdesk"><a href="#远程桌面rustdesk" class="headerlink" title="远程桌面rustdesk"></a>远程桌面rustdesk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/rustdesk/rustdesk</span><br></pre></td></tr></table></figure>

<h2 id="mac-拆分及合成pdf"><a href="#mac-拆分及合成pdf" class="headerlink" title="mac 拆分及合成pdf"></a>mac 拆分及合成pdf</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、安装pdf拆分工具</span><br><span class="line">brew install qpdf</span><br><span class="line">2、拆分成单个pdf</span><br><span class="line">qpdf --split-pages original.pdf page_.pdf</span><br><span class="line">3、删除不要的pdf文件，合成最终pdf</span><br><span class="line">qpdf --empty --pages page_*.pdf -- final.pdf</span><br><span class="line"></span><br><span class="line">#可以剔除前6页页，保留后续页面</span><br><span class="line">qpdf original.pdf --compress-streams=y --pages . 7-z -- final.pdf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># github开源工具</span><br><span class="line">https://github.com/Stirling-Tools/Stirling-PDF</span><br></pre></td></tr></table></figure>


<h2 id="白噪音"><a href="#白噪音" class="headerlink" title="白噪音"></a>白噪音</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/remvze/moodist</span><br></pre></td></tr></table></figure>

<h2 id="convfmt-yaml-toml-json互换"><a href="#convfmt-yaml-toml-json互换" class="headerlink" title="convfmt(yaml&#x2F;toml&#x2F;json互换)"></a>convfmt(yaml&#x2F;toml&#x2F;json互换)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#toml转json</span><br><span class="line">wget https://github.com/oriontvv/convfmt/releases/download/1.1.1/convfmt-linux-musl.tar.gz</span><br><span class="line">tar zxvf convfmt-linux-musl.tar.gz -C /bin</span><br><span class="line">#解压后</span><br><span class="line"></span><br><span class="line">cat /etc/containerd/config.toml | convfmt -f toml -t json &gt; cfg.json</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tools</category>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>vim基础配置</title>
    <url>/2024/12/10/vim%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="编辑-vimrc"><a href="#编辑-vimrc" class="headerlink" title="编辑.vimrc"></a>编辑.vimrc</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#全局的配置一般在/etc/vimrc</span><br><span class="line"></span><br><span class="line">cat &gt; .vimrc  &lt;&lt; EOF</span><br><span class="line"></span><br><span class="line">set nocompatible          &quot; 禁用与 Vi 的兼容模式</span><br><span class="line">set encoding=utf-8        &quot; 设置编码为 UTF-8</span><br><span class="line">set fileencodings=utf-8,gbk,iso-2022-jp,euc-jp,latin1 &quot; 文件编码自动检测</span><br><span class="line">set ruler                 &quot; 显示光标位置</span><br><span class="line"></span><br><span class="line">&quot; 自适应窗口大小</span><br><span class="line">autocmd VimEnter * let &amp;columns=system(&#x27;tput cols&#x27;) | let &amp;lines=system(&#x27;tput lines&#x27;)</span><br><span class="line">set display=lastline</span><br><span class="line"></span><br><span class="line">&quot; 代码编辑</span><br><span class="line">syntax on                 &quot; 启用语法高亮</span><br><span class="line">set autochdir             &quot; 自动切换到当前文件的目录</span><br><span class="line">set wildmenu              &quot; 增强命令补全菜单</span><br><span class="line">set wildmode=list:longest &quot; 补全时显示所有匹配项</span><br><span class="line">set foldmethod=indent     &quot; 根据缩进自动折叠代码</span><br><span class="line">set foldlevel=99          &quot; 默认展开所有代码</span><br><span class="line">set completeopt=menu,menuone,noselect &quot; 优化补全菜单</span><br><span class="line"></span><br><span class="line">&quot; 文本缩进</span><br><span class="line">set tabstop=4             &quot; 设置 Tab 长度为 4 个空格</span><br><span class="line">set shiftwidth=4          &quot; 自动缩进宽度为 4</span><br><span class="line">set expandtab             &quot; 用空格代替 Tab</span><br><span class="line">set smartindent           &quot; 智能缩进</span><br><span class="line">set autoindent            &quot; 自动继承上一行的缩进</span><br><span class="line"></span><br><span class="line">&quot; 显示相关</span><br><span class="line">set wrap                  &quot; 自动换行</span><br><span class="line">set linebreak             &quot; 单词边界处换行</span><br><span class="line">set showbreak=⮡          &quot; 换行提示符</span><br><span class="line"></span><br><span class="line">&quot; 搜索相关</span><br><span class="line">set hlsearch              &quot; 搜索高亮</span><br><span class="line">set incsearch             &quot; 边输入边搜索</span><br><span class="line">set ignorecase            &quot; 搜索忽略大小写</span><br><span class="line">set smartcase             &quot; 如果搜索中包含大写字母，则区分大小写</span><br><span class="line">set wrapscan              &quot; 搜索到文件结尾后从头继续</span><br><span class="line"></span><br><span class="line">&quot; 快捷键映射</span><br><span class="line">nnoremap &lt;Space&gt; :nohlsearch&lt;CR&gt; &quot; 空格键清除搜索高亮</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h2 id="粘贴乱码"><a href="#粘贴乱码" class="headerlink" title="粘贴乱码"></a>粘贴乱码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set paste </span><br><span class="line">进入paste模式以后，可以在插入模式下粘贴内容，不会有任何变形</span><br></pre></td></tr></table></figure>
<h2 id="临时解决乱码"><a href="#临时解决乱码" class="headerlink" title="临时解决乱码"></a>临时解决乱码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在vim的退出模式下  :set encoding=utf8</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>vscode调试配置</title>
    <url>/2024/11/20/vscode%E8%B0%83%E8%AF%95%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://vscode.js.cn/docs/remote/ssh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="远程主机配置go版本"><a href="#远程主机配置go版本" class="headerlink" title="远程主机配置go版本"></a>远程主机配置go版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#安装gvm</span><br><span class="line">bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</span><br><span class="line"></span><br><span class="line">#安装go1.23,设置默认</span><br><span class="line">gvm install go1.23</span><br><span class="line">gvm use go1.23 --default</span><br><span class="line"></span><br><span class="line">#配置GOROOT、GOPATH变量，vscode配置需要，go env 查看</span><br><span class="line">.....</span><br><span class="line">GO111MODULE=&quot;auto&quot;</span><br><span class="line">GOPROXY=&quot;https://proxy.golang.org,direct&quot;</span><br><span class="line">GOROOT=&quot;/home/xxx/.gvm/gos/go1.23&quot;</span><br><span class="line">GOPATH=&quot;/home/xxx/.gvm/pkgsets/go1.23/global&quot;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<h2 id="扩展及工具"><a href="#扩展及工具" class="headerlink" title="扩展及工具"></a>扩展及工具</h2><ul>
<li>Remote - SSH</li>
<li>Go</li>
<li>go tools</li>
</ul>
<h2 id="根路径下配置文件"><a href="#根路径下配置文件" class="headerlink" title="根路径下配置文件"></a>根路径下配置文件</h2><ul>
<li>新建.vscode文件夹</li>
<li>文件 extension.json 、launch.json 、 settings.json</li>
</ul>
<h3 id="extension-jon"><a href="#extension-jon" class="headerlink" title="extension.jon"></a>extension.jon</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;recommendations&quot;: [</span><br><span class="line">        &quot;vivaldy22.go-auto-struct-tag&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;informer&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;go&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            // &quot;mode&quot;: &quot;debug&quot;, </span><br><span class="line">            // &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/xxx/main.go&quot;,</span><br><span class="line">            &quot;mode&quot;: &quot;test&quot;, //test 或者 debug</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/xxx/xxx_test.go&quot;,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;/xxx&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-test.v&quot; // 所有t.Log/t.Logf 的内容都会被输出，无论测试是否通过</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="settings-json文件内容"><a href="#settings-json文件内容" class="headerlink" title="settings.json文件内容"></a>settings.json文件内容</h3><ul>
<li>注意GOROOT 、GOPATH与远程主机设置一致<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 界面主题选择、图标选择（需要安装插件： Material Icon Theme ）</span><br><span class="line">    &quot;workbench.colorTheme&quot;: &quot;GitHub Dark&quot;,</span><br><span class="line">    &quot;workbench.iconTheme&quot;: &quot;material-icon-theme&quot;,</span><br><span class="line">    // ---编辑面板字体大小</span><br><span class="line">    &quot;editor.fontSize&quot;: 14,</span><br><span class="line">    // ---丝滑打字配置</span><br><span class="line">    &quot;editor.smoothScrolling&quot;: true,</span><br><span class="line">    &quot;editor.cursorBlinking&quot;: &quot;expand&quot;,</span><br><span class="line">    &quot;editor.cursorSmoothCaretAnimation&quot;: &quot;on&quot;,</span><br><span class="line">    &quot;workbench.list.smoothScrolling&quot;: true,</span><br><span class="line">    // ---鼠标控制大小,使用鼠标的可以尝试</span><br><span class="line">    // &quot;editor.mouseWheelZoom&quot;: true,</span><br><span class="line">    // ---彩虹括号与作用域块线条提示</span><br><span class="line">    &quot;editor.guides.bracketPairs&quot;: true,</span><br><span class="line">    &quot;editor.bracketPairColorization.enabled&quot;: true,</span><br><span class="line">    // ---更加智能的代码提示</span><br><span class="line">    // 控制活动代码段是否阻止快速建议</span><br><span class="line">    &quot;editor.suggest.snippetsPreventQuickSuggestions&quot;: false,</span><br><span class="line">    // 除了 `Tab` 键以外， `Enter` 键是否同样可以接受建议</span><br><span class="line">    // 这能减少“插入新行”和“接受建议”命令之间的歧义</span><br><span class="line">    &quot;editor.acceptSuggestionOnEnter&quot;: &quot;smart&quot;,</span><br><span class="line">    // 代码补全列表中，优先选择最近的建议</span><br><span class="line">    &quot;editor.suggestSelection&quot;: &quot;recentlyUsedByPrefix&quot;,</span><br><span class="line">    // ---自动补全括号、引号</span><br><span class="line">    &quot;editor.autoClosingBrackets&quot;: &quot;beforeWhitespace&quot;,</span><br><span class="line">    &quot;editor.autoClosingDelete&quot;: &quot;always&quot;,</span><br><span class="line">    &quot;editor.autoClosingOvertype&quot;: &quot;always&quot;,</span><br><span class="line">    &quot;editor.autoClosingQuotes&quot;: &quot;beforeWhitespace&quot;,</span><br><span class="line">    // ---自动换行和行高</span><br><span class="line">    &quot;editor.wordWrap&quot;: &quot;on&quot;,</span><br><span class="line">    &quot;editor.lineHeight&quot;: 1.5,</span><br><span class="line">    // ---保存自动删除末尾空格</span><br><span class="line">    &quot;files.trimTrailingWhitespace&quot;: false,</span><br><span class="line">    // ---保存自动格式化代码</span><br><span class="line">    &quot;editor.formatOnSave&quot;: true,</span><br><span class="line">    // ---双击选中被截断的字符</span><br><span class="line">    &quot;editor.wordSeparators&quot;: &quot;`~!@%^&amp;*()=+[&#123;]&#125;\\|;:&#x27;\&quot;,.&lt;&gt;/?（），。；：&quot;,</span><br><span class="line">    // ---折行缩进策略和关闭右侧代码地图</span><br><span class="line">    &quot;editor.minimap.enabled&quot;: false,</span><br><span class="line">    &quot;editor.foldingStrategy&quot;: &quot;indentation&quot;,</span><br><span class="line">    &quot;go.toolsEnvVars&quot;: &#123;</span><br><span class="line">        &quot;GOFLAGS&quot;: &quot;-mod=mod&quot;, // -mod=vendor</span><br><span class="line">        &quot;GO111MODULE&quot;: &quot;on&quot;,</span><br><span class="line">        &quot;GOPATH&quot;: &quot;/home/xxx/.gvm/pkgsets/go1.23.0/global&quot;,</span><br><span class="line">        &quot;GOROOT&quot;: &quot;/home/xxx/.gvm/gos/go1.23.0&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;go.gopath&quot;: &quot;/home/xxx/.gvm/pkgsets/go1.23.0/global&quot;,</span><br><span class="line">    &quot;go.goroot&quot;: &quot;/home/xxx/.gvm/gos/go1.23.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 指定模块根目录(kubernetes/sample-controller项目引出)</span><br><span class="line">将 &quot;program&quot; 设置为项目的根目录（&quot;$&#123;workspaceFolder&#125;&quot;），确保调试器加载完整的模块。</span><br><span class="line">•当 launch.json 中指定 &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&quot; 时，调试器会将整个工作目录（即包含 go.mod 文件的项目根目录）作为编译和调试的上下文。</span><br><span class="line">•如果指定为某个文件（如 main.go），调试器会将范围限制在该文件中，而可能忽略与该文件同目录下的其他文件。</span><br><span class="line"></span><br><span class="line">2. 检查 go.mod 和模块配置</span><br><span class="line">确保 go.mod 中的依赖和模块路径正确，避免调试时出错。</span><br><span class="line"></span><br><span class="line">3. 保持文件组织一致性</span><br><span class="line">将同一逻辑单元的 .go 文件保存在同一目录，并声明相同的包名。</span><br><span class="line"></span><br><span class="line">tips:</span><br><span class="line">1、如果本地升级了vscode版本</span><br><span class="line">① 需要清理远程 .vscode-server 文件夹</span><br><span class="line">② 本地清理vscode扩展 ：rm -fr ~/.vscode/extensions</span><br><span class="line"></span><br><span class="line">2、如果重新配置了.vscode/settings.json里go版本：可删除go扩展重新安装</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>vscode配置tips</title>
    <url>/2024/09/27/vscode%E9%85%8D%E7%BD%AEtips/</url>
    <content><![CDATA[<h3 id="配置文件差异"><a href="#配置文件差异" class="headerlink" title="配置文件差异"></a>配置文件差异</h3><p>远程开发时切换go版本，影响go tools安装。注意配置settings.json里的go root、path路径</p>
<ol>
<li>.vscode-server&#x2F;data&#x2F;Machine&#x2F;settings.json</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">这个配置文件包含了 <span class="title class_">VSCode</span> 服务器的全局设置，这些设置会影响所有打开的工作区。</span><br><span class="line">它通常不由用户直接编辑，而是由 <span class="title class_">VSCode</span> 根据用户在 <span class="variable constant_">UI</span> 中的操作自动管理。</span><br><span class="line">这些设置包括了对所有工作区都有效的配置，比如插件的启用、禁用状态等。</span><br><span class="line"></span><br><span class="line">#远程开发机路径：~<span class="regexp">/.vscode-server/</span>data/<span class="title class_">Machine</span>/settings.<span class="property">json</span></span><br><span class="line"><span class="string">&quot;go.goroot&quot;</span>: <span class="string">&quot;~/.gvm/gos/go1.23.0&quot;</span>,</span><br><span class="line"><span class="string">&quot;go.gopath&quot;</span>: <span class="string">&quot;~/.gvm/pkgsets/go1.23.0/global&quot;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>.vscode&#x2F;settings.json</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">这个文件是特定于项目的，只影响当前项目的配置。</span><br><span class="line">用户可以在这个文件中自定义设置，比如自定义任务、调试配置、文件关联等。</span><br><span class="line">这些设置在工作区打开时会被应用，并且会覆盖 .<span class="property">vscode</span>-server/data/<span class="title class_">Machine</span>/settings.<span class="property">json</span> 中的同名设置。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="mac下快捷命令"><a href="#mac下快捷命令" class="headerlink" title="mac下快捷命令"></a>mac下快捷命令</h3><ul>
<li>打开终端：ctrl + &#96;</li>
<li>跳到具体行：ctrl + g</li>
<li>打开所有配置面板：cmd + ,</li>
<li>显示命令行面板：cmd + shift + p</li>
</ul>
<h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Remote - SSH</span><br><span class="line">Go</span><br><span class="line"></span><br><span class="line">vscode-icons</span><br><span class="line">GitHub Theme</span><br><span class="line">Dracula Theme Officia</span><br><span class="line"></span><br><span class="line">Better Comments</span><br><span class="line">Comment Translate : 1、配置翻译源 2、配置翻译目标语言 （cmd + shift + p : 输入translate）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
  </entry>
  <entry>
    <title>xorm应用测试</title>
    <url>/2023/08/09/xorm-test/</url>
    <content><![CDATA[<h2 id="xorm包应用测试"><a href="#xorm包应用测试" class="headerlink" title="xorm包应用测试"></a>xorm包应用测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	_ &quot;github.com/go-sql-driver/mysql&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;xorm.io/xorm&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type XormTest struct &#123;</span><br><span class="line">	Id        int64  `json:&quot;id&quot; xorm:&quot;autoincr pk&quot;`     </span><br><span class="line">	Username  string `json:&quot;username&quot;`                  //用户名</span><br><span class="line">	CreatedAt string `json:&quot;created_at&quot; xorm:&quot;created&quot;` //创建时间</span><br><span class="line">	UpdatedAt string `json:&quot;updated_at&quot; xorm:&quot;updated&quot;` //更新时间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var engine *xorm.Engine</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	//mysql -h localhost -uroot -p  -P 3306 --default-character-set=utf8 -A</span><br><span class="line">	var err error</span><br><span class="line">	engine, err = xorm.NewEngine(&quot;mysql&quot;, &quot;root:xxx@tcp(127.0.0.1:3306)/yago_test?charset=utf8&quot;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s, _ := engine.IsTableEmpty(&quot;xorm_test&quot;)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line"></span><br><span class="line">	//查询</span><br><span class="line">	//selectElement(&quot;zhangsan&quot;)</span><br><span class="line">	//使用sql查询</span><br><span class="line">	queryElement()</span><br><span class="line">	//执行sql命令</span><br><span class="line">	updateBySql()</span><br><span class="line">	//插入</span><br><span class="line">	//insertElement()</span><br><span class="line">	//修改</span><br><span class="line">	//updateElement()</span><br><span class="line">	//删除</span><br><span class="line">	//deleteElement()</span><br><span class="line">	//事务</span><br><span class="line">	//transTest()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func updateBySql() &#123;</span><br><span class="line">	sql := &quot;update xorm_test set username=? where id=?&quot;</span><br><span class="line">	updateRes, err := engine.Exec(sql, &quot;wangwu&quot;, 9)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;RowNumber ==&gt; &quot;, updateRes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func queryElement() &#123;</span><br><span class="line">	sql := &quot;select * from xorm_test where id = 8;&quot;</span><br><span class="line">	results, _ := engine.QueryString(sql)</span><br><span class="line">	fmt.Println(results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func updateElement() &#123;</span><br><span class="line">	user := XormTest&#123;</span><br><span class="line">		Username: &quot;jpshi&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	if _, err := engine.Where(&quot;username = &#x27;wangwu&#x27;&quot;).Update(&amp;user); err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func deleteElement() &#123;</span><br><span class="line">	rowNumber, err := engine.ID(2).Delete(new(XormTest))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;RowNumber ==&gt; &quot;, rowNumber)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func transTest() &#123;</span><br><span class="line">	session := engine.NewSession()</span><br><span class="line">	defer session.Close()</span><br><span class="line">	// 开启事务</span><br><span class="line">	if err := session.Begin(); err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	// 插入User</span><br><span class="line">	if _, err := session.Insert(XormTest&#123;</span><br><span class="line">		Username: &quot;zhangsan&quot;,</span><br><span class="line">	&#125;); err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	// 更新User</span><br><span class="line">	if _, err := session.Where(&quot;id = &#x27;7&#x27;&quot;).Update(XormTest&#123;</span><br><span class="line">		Username: &quot;lisi&quot;,</span><br><span class="line">	&#125;); err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	// 提交事务</span><br><span class="line">	session.Commit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func insertElement() () &#123;</span><br><span class="line">	user := XormTest&#123;</span><br><span class="line">		Username: &quot;^_^&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">	rowNumber, err := engine.Insert(&amp;user) // rowNumber 受影响的行数</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;RowNumber ==&gt; &quot;, rowNumber)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func selectElement(name string)  &#123;</span><br><span class="line">	users := make([]*XormTest, 0)</span><br><span class="line">	err := engine.Where(&quot;username regexp ? &quot;,name).Find(&amp;users)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	for _, v := range users &#123;</span><br><span class="line">		fmt.Printf(&quot;%v\n&quot;, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>k8s整洁yaml输出（yq）</title>
    <url>/2024/11/18/yq/</url>
    <content><![CDATA[<h2 id="yq"><a href="#yq" class="headerlink" title="yq"></a>yq</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#文档：https://github.com/mikefarah/yq/releases</span></span><br><span class="line">wget https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar vxf yq_linux_amd64.tar.gz ./</span><br><span class="line"><span class="built_in">mv</span> ./yq_linux_amd64 /usr/local/bin/yq</span><br><span class="line"></span><br><span class="line"><span class="comment">#k8s使用yq导出较为整洁的导出yaml</span></span><br><span class="line">kubectl get deployment &lt;deployment&gt; -n &lt;namespace&gt; -o yaml --ignore-not-found | \</span><br><span class="line">yq <span class="string">&#x27;del(.metadata.annotations, .metadata.creationTimestamp, .metadata.generation, .metadata.resourceVersion, .metadata.uid, .status, .spec.template.metadata.creationTimestamp)&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title>使用github镜像加速安装pyenv</title>
    <url>/2024/08/22/%E4%BD%BF%E7%94%A8github%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%AE%89%E8%A3%85pyenv/</url>
    <content><![CDATA[<h1 id="使用github镜像加速安装pyenv"><a href="#使用github镜像加速安装pyenv" class="headerlink" title="使用github镜像加速安装pyenv"></a>使用github镜像加速安装pyenv</h1><h2 id="安装pyenv脚本"><a href="#安装pyenv脚本" class="headerlink" title="安装pyenv脚本"></a>安装pyenv脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line"></span><br><span class="line">set -e</span><br><span class="line">[ -n &quot;$PYENV_DEBUG&quot; ] &amp;&amp; set -x</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$PYENV_ROOT&quot; ]; then</span><br><span class="line">  export PYENV_ROOT=&quot;$&#123;HOME&#125;/.pyenv&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">colorize() &#123;</span><br><span class="line">  if [ -t 1 ]; then printf &quot;\e[%sm%s\e[m&quot; &quot;$1&quot; &quot;$2&quot;</span><br><span class="line">  else echo -n &quot;$2&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Checks for `.pyenv` file, and suggests to remove it for installing</span><br><span class="line">if [ -d &quot;$&#123;PYENV_ROOT&#125;&quot; ]; then</span><br><span class="line">  &#123; echo</span><br><span class="line">    colorize 1 &quot;WARNING&quot;</span><br><span class="line">    echo &quot;: Can not proceed with installation. Kindly remove the &#x27;$&#123;PYENV_ROOT&#125;&#x27; directory first.&quot;</span><br><span class="line">    echo</span><br><span class="line">  &#125; &gt;&amp;2</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">failed_checkout() &#123;</span><br><span class="line">  echo &quot;Failed to git clone $1&quot;</span><br><span class="line">  exit -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkout() &#123;</span><br><span class="line">  [ -d &quot;$2&quot; ] || git -c advice.detachedHead=0 clone --branch &quot;$3&quot; --depth 1 &quot;$1&quot; &quot;$2&quot; || failed_checkout &quot;$1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ! command -v git 1&gt;/dev/null 2&gt;&amp;1; then</span><br><span class="line">  echo &quot;pyenv: Git is not installed, can&#x27;t continue.&quot; &gt;&amp;2</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$&#123;USE_GIT_URI&#125;&quot; ]; then</span><br><span class="line">  GITHUB=&quot;git://github.com&quot;</span><br><span class="line">else</span><br><span class="line">  GITHUB=&quot;https://kkgithub.com&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">checkout &quot;$&#123;GITHUB&#125;/pyenv/pyenv.git&quot;            &quot;$&#123;PYENV_ROOT&#125;&quot;                           &quot;$&#123;PYENV_GIT_TAG:-master&#125;&quot;</span><br><span class="line">checkout &quot;$&#123;GITHUB&#125;/pyenv/pyenv-doctor.git&quot;     &quot;$&#123;PYENV_ROOT&#125;/plugins/pyenv-doctor&quot;      &quot;master&quot;</span><br><span class="line">checkout &quot;$&#123;GITHUB&#125;/pyenv/pyenv-installer.git&quot;  &quot;$&#123;PYENV_ROOT&#125;/plugins/pyenv-installer&quot;   &quot;master&quot;</span><br><span class="line">checkout &quot;$&#123;GITHUB&#125;/pyenv/pyenv-update.git&quot;     &quot;$&#123;PYENV_ROOT&#125;/plugins/pyenv-update&quot;      &quot;master&quot;</span><br><span class="line">checkout &quot;$&#123;GITHUB&#125;/pyenv/pyenv-virtualenv.git&quot; &quot;$&#123;PYENV_ROOT&#125;/plugins/pyenv-virtualenv&quot;  &quot;master&quot;</span><br><span class="line">checkout &quot;$&#123;GITHUB&#125;/pyenv/pyenv-which-ext.git&quot;  &quot;$&#123;PYENV_ROOT&#125;/plugins/pyenv-which-ext&quot;   &quot;master&quot;</span><br><span class="line"></span><br><span class="line">if ! command -v pyenv 1&gt;/dev/null; then</span><br><span class="line">  &#123; echo</span><br><span class="line">    colorize 1 &quot;WARNING&quot;</span><br><span class="line">    echo &quot;: seems you still have not added &#x27;pyenv&#x27; to the load path.&quot;</span><br><span class="line">    echo</span><br><span class="line">  &#125; &gt;&amp;2</span><br><span class="line"></span><br><span class="line">  &#123; # Without args, `init` commands print installation help</span><br><span class="line">    &quot;$&#123;PYENV_ROOT&#125;/bin/pyenv&quot; init || true</span><br><span class="line">    &quot;$&#123;PYENV_ROOT&#125;/bin/pyenv&quot; virtualenv-init || true</span><br><span class="line">  &#125; &gt;&amp;2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><ul>
<li>vim .bash_profile<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PYENV_ROOT=&quot;$HOME/.pyenv&quot;</span><br><span class="line">command -v pyenv &gt;/dev/null || export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br></pre></td></tr></table></figure></li>
<li>source .bash_profile</li>
</ul>
<h2 id="安装tips"><a href="#安装tips" class="headerlink" title="安装tips"></a>安装tips</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式一：因为pyenv会自动到github上下载，速度超慢，因此推荐第二种方式</span><br><span class="line">$ pyenv install 3.12.2 -v  #-v 以日志模式显示安装过程</span><br><span class="line"></span><br><span class="line">#方式二：使用curl或者wget下载到~/.pyenv/cache下，然后再用pyenv安装。软件源可以用自己熟悉的镜像源</span><br><span class="line">$ cd ~/.pyenv</span><br><span class="line">$ sudo mkdir cache</span><br><span class="line">$ sudo wget -c https://mirrors.huaweicloud.com/python/3.12.2/Python-3.12.2.tar.xz -P  ~/.pyenv/cache/</span><br><span class="line">$ pyenv install 3.12.2 -v</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看所有可用的Python版本</span><br><span class="line">pyenv install --list</span><br><span class="line"></span><br><span class="line">#列出本地可用的Python版本</span><br><span class="line">pyenv versions</span><br><span class="line"></span><br><span class="line">#生效范围不同，当前shell可用</span><br><span class="line">pyenv shell 3.12.2</span><br><span class="line">#当前目录</span><br><span class="line">pyenv local 3.12.2</span><br><span class="line">#全局</span><br><span class="line">pyenv global 3.12.2</span><br><span class="line"></span><br><span class="line">#查看当前Python版本</span><br><span class="line">python --version</span><br><span class="line"></span><br><span class="line">#删除指定Python版本</span><br><span class="line">pyenv uninstall 3.12.2</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="安装ssh-audit"><a href="#安装ssh-audit" class="headerlink" title="安装ssh-audit"></a>安装ssh-audit</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install ssh-audit</span><br><span class="line"></span><br><span class="line">#使用</span><br><span class="line">ssh-audit 10.16.100.100</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>删除Terminatin状态的命名空间</title>
    <url>/2024/12/04/%E5%88%A0%E9%99%A4Terminatin%E7%8A%B6%E6%80%81%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="命名空间一直处于Terminating问题分析"><a href="#命名空间一直处于Terminating问题分析" class="headerlink" title="命名空间一直处于Terminating问题分析"></a>命名空间一直处于Terminating问题分析</h2><ul>
<li>报错 Error from server (MethodNotAllowed) 表示某些资源类型的操作（如 GET 或 DELETE）在命名空间中不被支持，可能是某些残留的自定义资源（CRD）或特殊系统资源导致。</li>
<li>部分资源仍存在于命名空间中，但 Kubernetes 无法正确清理，命名空间因而停留在 Terminating 状态。</li>
</ul>
<h3 id="方法-1：逐步清理残留资源"><a href="#方法-1：逐步清理残留资源" class="headerlink" title="方法 1：逐步清理残留资源"></a>方法 1：逐步清理残留资源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.列出命名空间中的资源：</span><br><span class="line">使用以下命令列出所有可能影响命名空间删除的资源：</span><br><span class="line">kubectl api-resources --namespaced=true -o name | xargs -n 1 kubectl -n jpshi-ca-test get --ignore-not-found</span><br><span class="line">如果某些资源显示报错（如 MethodNotAllowed），需要针对这些资源进一步操作。</span><br><span class="line"></span><br><span class="line">2.强制删除特定资源：</span><br><span class="line">对于残留资源，可以手动清理：</span><br><span class="line">kubectl delete &lt;resource-type&gt; &lt;resource-name&gt; -n jpshi-ca-test --force --grace-period=0</span><br><span class="line">如果资源类型无法直接删除，可能需要查看其定义并移除 finalizers。</span><br><span class="line"></span><br><span class="line">3.编辑特定资源的 Finalizers：</span><br><span class="line">kubectl edit &lt;resource-type&gt; &lt;resource-name&gt; -n jpshi-ca-test</span><br><span class="line">在资源定义中删除类似以下内容：</span><br><span class="line">metadata:</span><br><span class="line">  finalizers:</span><br><span class="line">  - example.finalizer.kubernetes.io</span><br></pre></td></tr></table></figure>

<h3 id="方法2：强制移除命名空间-Finalizers"><a href="#方法2：强制移除命名空间-Finalizers" class="headerlink" title="方法2：强制移除命名空间 Finalizers"></a>方法2：强制移除命名空间 Finalizers</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命名空间未删除的核心问题通常是 finalizers 阻止删除。以下命令会直接移除命名空间的 finalizers，强制删除：</span><br><span class="line">1.编辑命名空间：</span><br><span class="line">kubectl edit namespace jpshi-ca-test</span><br><span class="line">删除以下字段：</span><br><span class="line">spec:</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes</span><br><span class="line"></span><br><span class="line">2.或通过命令强制移除 Finalizers：</span><br><span class="line">kubectl patch namespace jpshi-ca-test -p &#x27;&#123;&quot;metadata&quot;:&#123;&quot;finalizers&quot;:[]&#125;&#125;&#x27; --type=merge</span><br></pre></td></tr></table></figure>

<h3 id="方法-3：彻底清理命名空间及其关联资源"><a href="#方法-3：彻底清理命名空间及其关联资源" class="headerlink" title="方法 3：彻底清理命名空间及其关联资源"></a>方法 3：彻底清理命名空间及其关联资源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.使用 kubectl proxy 调试：</span><br><span class="line">kubectl proxy &amp;</span><br><span class="line">通过 Kubernetes API 调用直接操作命名空间：</span><br><span class="line">curl -k -H &quot;Content-Type: application/json&quot; -X PUT \</span><br><span class="line">--data &#x27;&#123;&quot;metadata&quot;:&#123;&quot;finalizers&quot;:[]&#125;&#125;&#x27; \</span><br><span class="line">http://localhost:8001/api/v1/namespaces/jpshi-ca-test/finalize</span><br><span class="line"></span><br><span class="line">2.删除命名空间及其资源：</span><br><span class="line">如果仍无法删除，可以使用以下命令强制清理：</span><br><span class="line">kubectl delete namespace jpshi-ca-test --force --grace-period=0</span><br></pre></td></tr></table></figure>

<h3 id="方法-4：排查-CRD-资源问题"><a href="#方法-4：排查-CRD-资源问题" class="headerlink" title="方法 4：排查 CRD 资源问题"></a>方法 4：排查 CRD 资源问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果命名空间中涉及 CRD（CustomResourceDefinitions），需要特别检查这些资源类型是否存在问题。</span><br><span class="line">1.列出所有 CRD 实例：</span><br><span class="line">kubectl get crd</span><br><span class="line"></span><br><span class="line">2.删除与命名空间相关的 CRD 实例：</span><br><span class="line">kubectl delete &lt;crd-name&gt; -n jpshi-ca-test --force --grace-period=0</span><br><span class="line"></span><br><span class="line">3.检查并清理 CRD Finalizers：</span><br><span class="line">kubectl patch &lt;crd-name&gt; -n jpshi-ca-test -p &#x27;&#123;&quot;metadata&quot;:&#123;&quot;finalizers&quot;:[]&#125;&#125;&#x27; --type=merge</span><br><span class="line">验证命名空间删除</span><br><span class="line"></span><br><span class="line">删除命名空间后，确认其状态：</span><br><span class="line">kubectl get namespaces</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>强制删除命名空间可能会导致资源不一致或孤立资源，请谨慎操作。</li>
<li>如果问题持续未解决，可能需要检查 Kubernetes API Server 或 Controller Manager 的日志进行深入排查。</li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
  </entry>
  <entry>
    <title>各层网络探测工具</title>
    <url>/2024/12/08/%E5%90%84%E5%B1%82%E7%BD%91%E7%BB%9C%E6%8E%A2%E6%B5%8B%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>探测网络连通性的方法和工具可以分为不同网络层次（OSI 模型）来讨论，涵盖从物理层到应用层的探测工具及其用途。以下是具体分类及工具：</p>
<ol>
<li>物理层 (Layer 1)</li>
</ol>
<p>主要检测物理连接是否正常。</p>
<p>工具与方法：<br>    •	电缆测试仪<br>    •	用于检查网线、光纤的连接和质量问题。<br>    •	网络接口卡 (NIC) 指示灯<br>    •	查看网卡指示灯是否正常闪烁。<br>    •	信号检测工具<br>    •	测试信号强度和干扰（如 Wi-Fi 信号分析仪）。</p>
<ol start="2">
<li>数据链路层 (Layer 2)</li>
</ol>
<p>检测交换机、MAC 地址、VLAN 配置问题。</p>
<p>工具与方法：<br>    •	ARP (Address Resolution Protocol)<br>    •	通过发送 ARP 请求检查目标主机是否在线。</p>
<p>arp -a</p>
<pre><code>•	Ethernet Sniffing (如 Wireshark)
•	捕获数据链路层帧，分析网络广播、交换机转发问题。
</code></pre>
<ol start="3">
<li>网络层 (Layer 3)</li>
</ol>
<p>主要用于检查 IP 地址是否可达。</p>
<p>工具与方法：<br>    •	ping<br>    •	发送 ICMP 回显请求，检测目标是否可达、往返时间及丢包情况。</p>
<p>ping &lt;目标IP&gt;</p>
<pre><code>•	traceroute / tracert
•	路径跟踪工具，显示从源到目标的每一跳。
</code></pre>
<p>traceroute &lt;目标IP&gt; (Linux)<br>tracert &lt;目标IP&gt; (Windows)</p>
<pre><code>•	mtr (My Traceroute)
•	结合 ping 和 traceroute 的功能，动态显示网络路径质量。
</code></pre>
<p>mtr &lt;目标IP&gt;</p>
<pre><code>•	iputils-tools
•	例如 ip link 和 ip addr 命令，用于检查网络接口和 IP 配置。
</code></pre>
<ol start="4">
<li>传输层 (Layer 4)</li>
</ol>
<p>检测端口和连接的状态。</p>
<p>工具与方法：<br>    •	tcping<br>    •	使用 TCP 连接检测目标主机的指定端口是否开放。</p>
<p>tcping &lt;目标IP&gt; &lt;端口&gt;</p>
<pre><code>•	telnet
•	连接到目标主机指定端口，检查服务是否响应。
</code></pre>
<p>telnet &lt;目标IP&gt; &lt;端口&gt;</p>
<pre><code>•	nc (Netcat)
•	多功能网络工具，可用于测试端口可达性和数据传输。
</code></pre>
<p>nc -zv &lt;目标IP&gt; &lt;端口&gt;</p>
<pre><code>•	ss / netstat
•	查看当前主机的端口状态和连接情况。
</code></pre>
<p>ss -tuln</p>
<ol start="5">
<li>应用层 (Layer 7)</li>
</ol>
<p>检测具体应用服务是否正常。</p>
<p>工具与方法：<br>    •	curl &#x2F; wget<br>    •	访问 HTTP&#x2F;HTTPS 服务，测试 Web 服务可用性。</p>
<p>curl -I http:&#x2F;&#x2F;&lt;目标地址&gt;</p>
<pre><code>•	httping
•	类似于 ping，但针对 HTTP/HTTPS 服务。
</code></pre>
<p>httping -h &lt;目标地址&gt;</p>
<pre><code>•	dig / nslookup
•	测试 DNS 解析是否正常。
</code></pre>
<p>dig &lt;域名&gt;<br>nslookup &lt;域名&gt;</p>
<pre><code>•	OpenSSL
•	测试 SSL/TLS 连接。
</code></pre>
<p>openssl s_client -connect &lt;目标IP&gt;:443</p>
<p>综合网络探测工具<br>    •	Wireshark<br>    •	捕获并分析各层流量，深入排查问题。<br>    •	Nmap<br>    •	网络扫描器，用于检测主机存活状态、端口开放情况及服务版本。</p>
<p>nmap -sP &lt;子网&gt;</p>
<pre><code>•	Zabbix / Nagios
•	网络监控系统，长期监测网络连接和服务状态。
</code></pre>
<p>选择合适的工具<br>    •	快速测试：ping、tcping、curl<br>    •	路由问题：traceroute、mtr<br>    •	端口问题：telnet、nc、nmap<br>    •	协议深入分析：Wireshark、OpenSSL<br>    •	服务监控：Zabbix、Nagios</p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
  </entry>
  <entry>
    <title>学习方式</title>
    <url>/2024/11/13/%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Bloom’s-Taxonomy"><a href="#Bloom’s-Taxonomy" class="headerlink" title="Bloom’s Taxonomy"></a>Bloom’s Taxonomy</h2><ul>
<li>1956 年布鲁姆分类法将知识分为六大类：知识、理解、应用、分析、综合和评价。</li>
<li>2001 年，一群认知心理学家、课程理论家、教学研究者和测试专家将布鲁姆分类法的类别名称从名词改为动词。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/shispring/picgo/master/Bloom's-Taxonomy.jpeg" alt="Bloom-pic1"><br><img src="https://raw.githubusercontent.com/shispring/picgo/master/17361731479986_.pic.jpg" alt="Bloom-pic2"><br><img src="https://raw.githubusercontent.com/shispring/picgo/master/17321731479764_.pic.jpg" alt="Bloom-pic3"></p>
<hr>
<table aria-describedby="chart-description">
<thead>
<tr><th id="Remembering">Remembering</th><th id="Understanding">Understanding</th><th id="Applying">Applying</th><th id="Analyzing">Analyzing</th><th id="Evaluating">Evaluating</th><th id="Creating">Creating</th></tr>
</thead>
<tbody>
<tr>
<td headers="Remembering">Recall specific facts.</td>
<td headers="Understanding">Grasp meaning of materials.</td>
<td headers="Applying">Use information in a new situation.&nbsp;</td>
<td headers="Analyzing">Identify schemas or relationships.&nbsp;</td>
<td headers="Evaluating">Use information to make judgments.&nbsp;</td>
<td headers="Creating">Create or develop something new.&nbsp;</td>
</tr>
<tr>
<td headers="Remembering">
<p>define<br>
describe<br>
examine<br>
identify<br>
label<br>
list<br>
locate<br>
match<br>
memorize<br>
recall<br>
recite<br>
recognize<br>
record<br>
reproduce<br>
retell<br>
select<br>
state<br>
tabulate<br>
tell<br>
visualize<br></p>
</td>
<td headers="Understanding">
<p>associate<br>
classify<br>
compare<br>
contrast<br>
convert<br>
describe<br>
discuss<br>
distinguish<br>
explain<br>
illustrate<br>
interpret<br>
order<br>
predict<br>
relate<br>
report<br>
represent<br>
restate<br>
select<br>
summarize<br>
trace<br>
transform<br>
translate<br></p>
</td>
<td headers="Applying">
<p>apply<br>
articulate<br>
calculate<br>
change<br>
chart<br>
compute<br>
construct<br>
develop<br>
employ<br>
examine<br>
experiment<br>
explain<br>
illustrate<br>
interpret<br>
manipulate<br>
modify<br>
operate<br>
predict<br>
produce<br>
relate<br>
solve<br>
transfer<br></p>
</td>
<td headers="Analyzing">
<p>analyze<br>
categorize<br>
compare<br>
connect<br>
contrast<br>
criticize<br>
deduce<br>
diagram<br>
differentiate<br>
discriminate<br>
dissect<br>
estimate<br>
evaluate<br>
experiment<br>
infer<br>
organize<br>
plan<br>
prioritize<br>
question<br>
separate<br>
survey<br>
test</p></td>
<td headers="Evaluating">
appraise<br>
argue<br>
assess<br>
choose<br>
convince<br>
critique<br>
debate<br>
defend<br>
editorialize<br>
estimate<br>
evaluate<br>
grade<br>
judge<br>
justify<br>
measure<br>
persuade<br>
predict<br>
rank<br>
rate<br>
reframe<br>
summarize<br>
support<br><p></p>
</td>
<td headers="Creating">
<p>adapt<br>
assemble<br>
compose<br>
construct<br>
create<br>
design<br>
develop<br>
facilitate<br>
hypothesize<br>
integrate<br>
invent<br>
modify<br>
negotiate<br>
plan<br>
propose<br>
revise<br>
role-play<br>
schematize<br>
simulate<br>
speculate<br>
support<br>
validate</p>
</td>
</tr>
</tbody>
</table>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://citt.ufl.edu/resources/the-learning-process/designing-the-learning-experience/blooms-taxonomy">https://citt.ufl.edu/resources/the-learning-process/designing-the-learning-experience/blooms-taxonomy</a></li>
</ul>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title>挂载磁盘及迁移docker数据</title>
    <url>/2025/01/23/%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98%E5%8F%8A%E8%BF%81%E7%A7%BBdocker%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="挂载设备"><a href="#挂载设备" class="headerlink" title="挂载设备"></a>挂载设备</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将设备挂载的操作，以设备/dev/sdb为例</span><br><span class="line">登录机器查看设备：</span><br><span class="line">fdisk -l </span><br><span class="line"></span><br><span class="line">挂载到/data目录方法：</span><br><span class="line">yum -y install xfsprogs</span><br><span class="line">mkdir -p /data</span><br><span class="line">/sbin/mkfs.xfs -f /dev/sdb</span><br><span class="line">grep -q &quot;/dev/sdb /data xfs defaults,nofail 1 2&quot; /etc/fstab || echo &quot;/dev/sdb /data xfs defaults,nofail 1 2&quot; &gt;&gt; /etc/fstab </span><br><span class="line">mount -a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="迁移docker"><a href="#迁移docker" class="headerlink" title="迁移docker"></a>迁移docker</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1 停止docker服务，完全关闭 Docker 服务，记得同时处理 docker.socket 和 docker.service</span><br><span class="line">systemctl stop docker.socket</span><br><span class="line">systemctl stop docker</span><br><span class="line"></span><br><span class="line">#验证状态</span><br><span class="line">systemctl status docker.socket</span><br><span class="line">systemctl status docker.service</span><br><span class="line"></span><br><span class="line">#docker.socket 监听客户端请求（例如 docker CLI 工具或 API 调用）并激活 docker.service。systemd 的 Socket Activation 机制在起作用，它允许服务按需启动</span><br><span class="line"></span><br><span class="line">#2 拷贝docke数据到新目录</span><br><span class="line">rsync -aP /var/lib/docker /data/docker</span><br><span class="line">或者</span><br><span class="line">mv /var/lib/docker /data/docker</span><br><span class="line"></span><br><span class="line">#3 配置 Docker 使用新的数据目录 /etc/docker/daemon.json 添加data-root配置</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://dockerproxy.com&quot;,</span><br><span class="line">    &quot;https://fw92oidw.mirror.aliyuncs.com&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;data-root&quot;: &quot;/data/docker/docker&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#4 重启docker</span><br><span class="line">systemctl daemon-reload &amp;&amp; systemctl start docker</span><br><span class="line"></span><br><span class="line">#5 检查</span><br><span class="line">docker info | grep &quot;Docker Root Dir&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>有意思的Docker镜像</title>
    <url>/2024/12/19/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84docker%E9%95%9C%E5%83%8F%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="docker镜像加速参考"><a href="#docker镜像加速参考" class="headerlink" title="docker镜像加速参考"></a>docker镜像加速参考</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/DaoCloud/public-image-mirror</span><br><span class="line"></span><br><span class="line">https://www.cnblogs.com/jiaxzeng/p/18023137</span><br></pre></td></tr></table></figure>

<h2 id="markdown-server服务"><a href="#markdown-server服务" class="headerlink" title="markdown server服务"></a>markdown server服务</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it -d --name markdown-server-demo  -v /root/markdown:/docs -p 7000:3000 dannyben/madness server</span><br><span class="line"></span><br><span class="line">- 将容器的 3000 端口映射到主机的 7000 端口。</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="阿里镜像（rpm包）"><a href="#阿里镜像（rpm包）" class="headerlink" title="阿里镜像（rpm包）"></a>阿里镜像（rpm包）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://developer.aliyun.com/packageSearch</span><br></pre></td></tr></table></figure>

<h2 id="自签证书"><a href="#自签证书" class="headerlink" title="自签证书"></a>自签证书</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --rm -v /root/cert:/opt/certs kingsd/generate-cert:v0.1 --ssl-domain=rancher.demo.cn</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>火焰图</title>
    <url>/2024/11/04/%E7%81%AB%E7%84%B0%E5%9B%BE/</url>
    <content><![CDATA[<p>在 Linux 系统上可以通过 <code>perf</code> 工具结合 <code>FlameGraph</code> 进行程序性能分析，特别适用于 CPU 密集型应用。</p>
<h3 id="1-准备工具"><a href="#1-准备工具" class="headerlink" title="1. 准备工具"></a>1. 准备工具</h3><p>首先，确保系统安装了 <code>perf</code> 和 <code>FlameGraph</code>：</p>
<h3 id="安装-perf"><a href="#安装-perf" class="headerlink" title="安装 perf"></a>安装 <code>perf</code></h3><p>对于大多数 Linux 发行版，可以通过包管理器安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过系统包管理器安装 Perl 核心模块：</span></span><br><span class="line"><span class="built_in">sudo</span> yum install -y perf  perf-core </span><br></pre></td></tr></table></figure>

<h3 id="获取-FlameGraph"><a href="#获取-FlameGraph" class="headerlink" title="获取 FlameGraph"></a>获取 <code>FlameGraph</code></h3><p><code>FlameGraph</code> 是一个工具集，可以从 GitHub 上克隆：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/brendangregg/FlameGraph.git</span><br></pre></td></tr></table></figure>

<p>下载完成后，进入 <code>FlameGraph</code> 目录，确保其中有 <code>stackcollapse-perf.pl</code> 和 <code>flamegraph.pl</code> 等脚本。</p>
<h3 id="2-使用-perf-收集性能数据"><a href="#2-使用-perf-收集性能数据" class="headerlink" title="2. 使用 perf 收集性能数据"></a>2. 使用 <code>perf</code> 收集性能数据</h3><p>假设你想要分析一个进程的 CPU 使用情况。可以先使用 <code>top</code> 或 <code>htop</code> 来获取目标进程的 PID。</p>
<h3 id="记录目标进程的性能数据"><a href="#记录目标进程的性能数据" class="headerlink" title="记录目标进程的性能数据"></a>记录目标进程的性能数据</h3><p>假设 PID 为 <code>1234</code>，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> perf record -F 99 -p 1234 -g -- <span class="built_in">sleep</span> 30</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>F 99</code>：每秒采样 99 次，可根据需要调整采样频率。</li>
<li><code>p 1234</code>：指定要分析的进程 PID。</li>
<li><code>g</code>：记录调用栈信息。</li>
<li><code>- sleep 30</code>：采样时间为 30 秒。</li>
</ul>
<p>采样完成后会生成一个 <code>perf.data</code> 文件，包含采样数据。</p>
<h3 id="3-处理-perf-数据"><a href="#3-处理-perf-数据" class="headerlink" title="3. 处理 perf 数据"></a>3. 处理 <code>perf</code> 数据</h3><p>将 <code>perf.data</code> 转换为 FlameGraph 可以使用的堆栈信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> perf script &gt; out.perf</span><br></pre></td></tr></table></figure>

<p>这会将 <code>perf.data</code> 文件解析成 <code>out.perf</code>，便于生成火焰图。</p>
<h3 id="4-生成火焰图"><a href="#4-生成火焰图" class="headerlink" title="4. 生成火焰图"></a>4. 生成火焰图</h3><p>在 <code>FlameGraph</code> 目录下运行以下命令：</p>
<h3 id="折叠堆栈信息"><a href="#折叠堆栈信息" class="headerlink" title="折叠堆栈信息"></a>折叠堆栈信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./stackcollapse-perf.pl out.perf &gt; out.folded</span><br></pre></td></tr></table></figure>

<h3 id="生成火焰图"><a href="#生成火焰图" class="headerlink" title="生成火焰图"></a>生成火焰图</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./flamegraph.pl out.folded &gt; flamegraph.svg</span><br></pre></td></tr></table></figure>

<p>生成的 <code>flamegraph.svg</code> 文件是一个交互式火焰图，可以通过浏览器打开查看。</p>
<h3 id="5-分析火焰图"><a href="#5-分析火焰图" class="headerlink" title="5. 分析火焰图"></a>5. 分析火焰图</h3><p>火焰图中各个块的宽度表示 CPU 使用时间，占用时间越多，宽度越大。图层深度表示调用堆栈的深度。可以查看性能热点并根据需要进行优化。</p>
<h3 id="总结的命令流程"><a href="#总结的命令流程" class="headerlink" title="总结的命令流程"></a>总结的命令流程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> perf record -F 99 -p 1234 -g -- <span class="built_in">sleep</span> 30</span><br><span class="line"><span class="built_in">sudo</span> perf script &gt; out.perf</span><br><span class="line">./stackcollapse-perf.pl out.perf &gt; out.folded</span><br><span class="line">./flamegraph.pl out.folded &gt; flamegraph.svg</span><br></pre></td></tr></table></figure>

<p>通过上述步骤，你可以生成并查看程序的 CPU 性能火焰图，为性能瓶颈定位和优化提供参考。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>负载均衡</title>
    <url>/2024/11/18/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/shispring/picgo/master/lvs.svg" alt="lvs"></p>
]]></content>
  </entry>
  <entry>
    <title>集群测试相关</title>
    <url>/2025/01/07/%E9%9B%86%E7%BE%A4%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="coreDNS压测"><a href="#coreDNS压测" class="headerlink" title="coreDNS压测"></a>coreDNS压测</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 参考</span><br><span class="line">https://github.com/guessi/dnsperf-bench</span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">kubectl get configmap coredns -n kube-system -o jsonpath=&#x27;&#123;$.data.Corefile&#125;&#x27;</span><br><span class="line">kubectl get deployments coredns -n kube-system -o jsonpath=&#x27;&#123;$.spec.template.spec.containers[0].resources&#125;&#x27; | jq</span><br><span class="line">kubectl get service kube-dns -n kube-system -o jsonpath=&#x27;&#123;$.spec.clusterIP&#125;&#x27;</span><br><span class="line"></span><br><span class="line">kubectl top pods -n kube-system -l k8s-app=kube-dns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 集群外测试</span><br><span class="line">dnsperf -s 11.33.162.100 -d domain_test.txt -Q 10000 -l 30</span><br><span class="line"></span><br><span class="line">#domain_test.txt内容</span><br><span class="line">www.google.com A</span><br><span class="line">www.amazon.com A</span><br><span class="line">kubernetes.default.svc.cluster.local A</span><br><span class="line">kube-dns.kube-system.svc.cluster.local A</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>test</category>
      </categories>
  </entry>
  <entry>
    <title>龙蜥安装docker</title>
    <url>/2024/09/27/%E9%BE%99%E8%9C%A5%E5%AE%89%E8%A3%85docker/</url>
    <content><![CDATA[<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用root用户</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看可以安装的版本</span></span><br><span class="line">yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br><span class="line"></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动docker</span></span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<h3 id="配置docker镜像源"><a href="#配置docker镜像源" class="headerlink" title="配置docker镜像源"></a>配置docker镜像源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置docker镜像源</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/docker  </span><br><span class="line"><span class="comment">#创建添加/更新 daemon.josn文件</span></span><br><span class="line"><span class="built_in">touch</span> /etc/docker/daemon.json            </span><br><span class="line"><span class="comment">#更换腾讯镜像源                         </span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt; /etc/docker/daemon.json</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;registry-mirrors&quot;: [</span></span><br><span class="line"><span class="string">	&quot;https://dockerproxy.com&quot;,</span></span><br><span class="line"><span class="string">        &quot;https://fw92oidw.mirror.aliyuncs.com&quot;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于更新了daemon.json文件 需要重新加载daemon.json</span></span><br><span class="line">systemctl daemon-reload   </span><br><span class="line"><span class="comment">#重新启动docker</span></span><br><span class="line">systemctl restart docker  </span><br><span class="line"><span class="comment">#查看docker运行状态</span></span><br><span class="line">docker info  </span><br></pre></td></tr></table></figure>

<h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装Docker-compose</span><br><span class="line">Docker-compose 要求docker的内核版本高于所对应的docker最低版本 。</span><br><span class="line">1.查看当前docker的内核版本</span><br><span class="line">docker version</span><br><span class="line">2.进入docker-compose的github官方release页面</span><br><span class="line">https://github.com/docker/compose/releases</span><br><span class="line">3.下载docker-compose-Linux-x86_64</span><br><span class="line">wget https://github.com/docker/compose/releases/download/v2.27.1/docker-compose-linux-x86_64</span><br><span class="line">4.上传并移动到到 /usr/local/bin 目录下，然后重命名为 docker-compose</span><br><span class="line">mv docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br><span class="line">5.赋予 docker-compose 文件root权限</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line">6.查看 docker-compose 版本</span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>time.After内存泄漏探测</title>
    <url>/2025/01/24/time-After%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%A2%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="demo-v1"><a href="#demo-v1" class="headerlink" title="demo-v1"></a>demo-v1</h2><ul>
<li>代码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    _ <span class="string">&quot;net/http/pprof&quot;</span> // 引入 pprof 包</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var chs chan int</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">Get</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> v := &lt;-chs:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;print:%v\n&quot;</span>, v)</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(3 * time.Minute):</span><br><span class="line">            fmt.Printf(<span class="string">&quot;time.After:%v\n&quot;</span>, time.Now().Unix())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">Put</span></span>() &#123;</span><br><span class="line">    var i = 0</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        chs &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    chs = make(chan int, 100)</span><br><span class="line"></span><br><span class="line">    // 启动一个 goroutine 运行 pprof 服务</span><br><span class="line">    go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;pprof server running on :6060&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;localhost:6060&quot;</span>, nil); err != nil &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;pprof server failed: %v\n&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    go Put()</span><br><span class="line">    Get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>pprof监控</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof -http=:8081 http://127.0.0.1:6060/debug/pprof/heap</span><br></pre></td></tr></table></figure>

<ul>
<li>内存使用情况</li>
</ul>
<p><img src="https://raw.githubusercontent.com/shispring/picgo/master/20250124165556.png" alt="image"></p>
<h2 id="demo-v2"><a href="#demo-v2" class="headerlink" title="demo-v2"></a>demo-v2</h2><ul>
<li>代码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    _ <span class="string">&quot;net/http/pprof&quot;</span> // 引入 pprof 包</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var chs chan int</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">Get</span></span>() &#123;</span><br><span class="line">    delay := time.NewTimer(3 * time.Minute)</span><br><span class="line"></span><br><span class="line">    defer delay.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        delay.Reset(3 * time.Minute)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> v := &lt;- chs:</span><br><span class="line">                fmt.Printf(<span class="string">&quot;print:%v\n&quot;</span>, v)</span><br><span class="line">            <span class="keyword">case</span> &lt;- delay.C:</span><br><span class="line">                fmt.Printf(<span class="string">&quot;time.After:%v&quot;</span>, time.Now().Unix())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">Put</span></span>() &#123;</span><br><span class="line">    var i = 0</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        chs &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    chs = make(chan int, 100)</span><br><span class="line"></span><br><span class="line">    // 启动一个 goroutine 运行 pprof 服务</span><br><span class="line">    go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;pprof server running on :6060&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;localhost:6060&quot;</span>, nil); err != nil &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;pprof server failed: %v\n&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    go Put()</span><br><span class="line">    Get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>pprof监控</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go tool pprof -http=:8082 http://127.0.0.1:6060/debug/pprof/heap</span><br></pre></td></tr></table></figure>

<ul>
<li>内存使用</li>
</ul>
<p><img src="https://raw.githubusercontent.com/shispring/picgo/master/20250124165624.png" alt="image"></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title>linux查看内核模块</title>
    <url>/2025/02/06/linux%E6%9F%A5%E7%9C%8B%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="linux源码包"><a href="#linux源码包" class="headerlink" title="linux源码包"></a>linux源码包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://mirrors.edge.kernel.org/pub/linux/kernel/</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="查看linux是否开启虚拟化"><a href="#查看linux是否开启虚拟化" class="headerlink" title="查看linux是否开启虚拟化"></a>查看linux是否开启虚拟化</h2><ul>
<li>cat &#x2F;proc&#x2F;cpuinfo | grep -E “vmx|svm”<br>其中，vmx 表示Intel的虛拟化技术（InteIVT），svm 表示AMD的虚拟化技术（AMD-V）。</li>
<li>lscpu</li>
<li>lsmod | grep kvm</li>
</ul>
<h3 id="lsmod-命令的作用"><a href="#lsmod-命令的作用" class="headerlink" title="lsmod 命令的作用"></a><strong><code>lsmod</code> 命令的作用</strong></h3><p><code>lsmod</code> 是 Linux 系统中的一个命令，用于显示当前已加载的 <strong>内核模块（Kernel Modules）</strong>。它可以帮助用户检查哪些模块正在运行，并用于诊断系统硬件和驱动相关问题。</p>
<h3 id="lsmod-的基本输出格式"><a href="#lsmod-的基本输出格式" class="headerlink" title="lsmod 的基本输出格式"></a><strong><code>lsmod</code> 的基本输出格式</strong></h3><p>执行 <code>lsmod</code> 命令时，会得到如下格式的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod</span><br></pre></td></tr></table></figure>
<p>示例输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Module                  Size  Used by</span><br><span class="line">ip_tables              28672  2</span><br><span class="line">x_tables               40960  1 ip_tables</span><br><span class="line">i915                 2330624  12</span><br><span class="line">drm_kms_helper        217088  1 i915</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Module</strong>：模块名称（例如 <code>i915</code>，为 Intel 显卡驱动模块）。</li>
<li><strong>Size</strong>：模块占用的字节数（以 KB 计算）。</li>
<li><strong>Used by</strong>：当前使用该模块的进程数或依赖该模块的其他内核模块。</li>
</ul>
<hr>
<h3 id="lsmod-的常见操作"><a href="#lsmod-的常见操作" class="headerlink" title="lsmod 的常见操作"></a><strong><code>lsmod</code> 的常见操作</strong></h3><h4 id="1-查看已加载的所有内核模块"><a href="#1-查看已加载的所有内核模块" class="headerlink" title="1. 查看已加载的所有内核模块"></a><strong>1. 查看已加载的所有内核模块</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod</span><br></pre></td></tr></table></figure>
<p>显示所有当前正在运行的内核模块。</p>
<h4 id="2-过滤特定模块"><a href="#2-过滤特定模块" class="headerlink" title="2. 过滤特定模块"></a><strong>2. 过滤特定模块</strong></h4><p>如果想要查找某个特定模块（如 <code>i915</code> 显卡驱动）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep i915</span><br></pre></td></tr></table></figure>

<h4 id="3-查看模块的详细信息"><a href="#3-查看模块的详细信息" class="headerlink" title="3. 查看模块的详细信息"></a><strong>3. 查看模块的详细信息</strong></h4><p><code>lsmod</code> 本身不提供详细信息，但可以使用 <code>modinfo</code> 获取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modinfo i915</span><br></pre></td></tr></table></figure>
<p>返回结果可能包含：</p>
<ul>
<li>模块名称</li>
<li>描述信息</li>
<li>版本</li>
<li>依赖关系</li>
<li>加载参数等</li>
</ul>
<h4 id="4-手动加载模块"><a href="#4-手动加载模块" class="headerlink" title="4. 手动加载模块"></a><strong>4. 手动加载模块</strong></h4><p>如果某个模块没有被自动加载，可以使用 <code>modprobe</code> 加载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> modprobe module_name</span><br></pre></td></tr></table></figure>
<p>例如加载 <code>i915</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> modprobe i915</span><br></pre></td></tr></table></figure>

<h4 id="5-卸载内核模块"><a href="#5-卸载内核模块" class="headerlink" title="5. 卸载内核模块"></a><strong>5. 卸载内核模块</strong></h4><p>如果一个模块没有被任何进程使用，可以使用 <code>rmmod</code> 卸载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> rmmod module_name</span><br></pre></td></tr></table></figure>
<p>例如卸载 <code>ip_tables</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> rmmod ip_tables</span><br></pre></td></tr></table></figure>
<p>但如果模块正在使用，可能会报错，可以使用 <code>modprobe -r</code> 尝试卸载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> modprobe -r ip_tables</span><br></pre></td></tr></table></figure>

<h4 id="6-列出模块的依赖关系"><a href="#6-列出模块的依赖关系" class="headerlink" title="6. 列出模块的依赖关系"></a><strong>6. 列出模块的依赖关系</strong></h4><p>使用 <code>lsmod</code> 看到的 <code>Used by</code> 列并不详细，可以使用 <code>modinfo</code> 或 <code>lsmod | grep</code> 结合 <code>lsmod</code> 查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep drm_kms_helper</span><br><span class="line">modinfo drm_kms_helper</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ul>
<li><strong>诊断硬件驱动</strong>：例如，检查显卡、网卡、USB 设备是否正确加载了驱动模块。</li>
<li><strong>调试系统问题</strong>：如果某些功能无法使用，可以检查相关模块是否被正确加载。</li>
<li><strong>手动管理模块</strong>：在某些情况下，用户可能需要手动加载或卸载某些模块，以优化性能或排除问题。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><code>lsmod</code> 用于列出当前已加载的内核模块。</li>
<li>结合 <code>grep</code> 可以快速查找特定模块。</li>
<li><code>modinfo</code> 获取模块详细信息。</li>
<li><code>modprobe</code> 加载模块，<code>rmmod</code> 或 <code>modprobe -r</code> 卸载模块。</li>
<li>常用于硬件驱动诊断和系统调试。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>社会运行&amp;人性&amp;生存&amp;事物本质</title>
    <url>/2025/02/06/%E7%A4%BE%E4%BC%9A%E8%BF%90%E8%A1%8C-%E4%BA%BA%E6%80%A7-%E7%94%9F%E5%AD%98-%E4%BA%8B%E7%89%A9%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<h3 id="一、社会的运行、人性的本质、生存法则"><a href="#一、社会的运行、人性的本质、生存法则" class="headerlink" title="一、社会的运行、人性的本质、生存法则"></a><strong>一、社会的运行、人性的本质、生存法则</strong></h3><p>人类社会的运行可以从 <strong>社会结构、人性、生存法则</strong> 三个层面来理解。  </p>
<h4 id="1-社会的运行逻辑："><a href="#1-社会的运行逻辑：" class="headerlink" title="1. 社会的运行逻辑："></a><strong>1. 社会的运行逻辑</strong>：</h4><p>社会是一个复杂的系统，由 <strong>资源分配、权力结构、文化规则、技术发展</strong> 等多个因素共同塑造。从宏观上看，社会运行的规律可以归纳为：  </p>
<ul>
<li><strong>资源分配</strong>：社会的核心矛盾之一在于 <strong>资源的有限性</strong> 与 <strong>人类欲望的无限性</strong>，这导致了竞争、阶层分化与利益冲突。  </li>
<li><strong>权力结构</strong>：无论是国家、公司还是社交圈，都存在 <strong>强者制定规则，弱者适应规则</strong> 的现实。掌握权力的人往往能影响资源流向。  </li>
<li><strong>文化与信念系统</strong>：宗教、法律、道德、教育等塑造了社会运作的方式，使群体行为趋向稳定。  </li>
<li><strong>技术变革</strong>：技术推动生产力发展，影响社会形态，如工业革命、互联网、人工智能等改变了生产方式和社会结构。</li>
</ul>
<p>社会的稳定建立在“契约”和“信任”之上，而真正的现实是——<strong>本质上所有社会规则都是人为创造的秩序</strong>。  </p>
<h4 id="2-人性的本质："><a href="#2-人性的本质：" class="headerlink" title="2. 人性的本质："></a><strong>2. 人性的本质</strong>：</h4><p>人性既包含理性的一面，也包含非理性、甚至是“黑暗”的一面，核心表现为：  </p>
<ul>
<li><strong>趋利避害</strong>：人类的行为本质上是基于 <strong>成本-收益</strong> 计算，趋向能带来好处、减少损失的决策。  </li>
<li><strong>有限理性</strong>：人类并非完全理性，而是受 <strong>情绪、直觉、认知偏差</strong> 影响，例如 “损失厌恶” 让人害怕失败，“从众心理” 让人趋向主流观点。  </li>
<li><strong>社会性需求</strong>：人类是社会性动物，渴望归属感、认可、影响力，这驱使我们形成群体、阶层、身份认同。  </li>
<li><strong>竞争与合作并存</strong>：人类既有自私的基因，追求个体利益最大化；也有合作的倾向，依赖团队才能生存。</li>
</ul>
<p>如果人性过于偏向竞争，就会导致冲突；如果完全偏向合作，个体动力又不足。因此，<strong>真正的平衡点在于“有限合作+理性竞争”</strong>。  </p>
<h4 id="3-生存法则："><a href="#3-生存法则：" class="headerlink" title="3. 生存法则："></a><strong>3. 生存法则</strong>：</h4><ul>
<li><strong>认清世界不公平，接受并利用它</strong>：现实世界并不公平，出生背景、资源分配、教育机会存在巨大差异。重要的是认清这个事实，而不是试图让世界变得公平。  </li>
<li><strong>提升“不可替代性”</strong>：市场经济下，个人价值的核心在于 <strong>“不可替代”</strong>，只有掌握稀缺技能、资源或影响力，才能保持竞争优势。  </li>
<li><strong>利益驱动一切</strong>：无论是商业、政治还是社交，<strong>99% 的决策都围绕利益展开</strong>。理解这一点，可以更清晰地判断人和事的本质。  </li>
<li><strong>建立自己的护城河</strong>：想在社会中长期生存，必须构建属于自己的 <strong>认知壁垒、技能壁垒、人脉壁垒、资本壁垒</strong>，让自己在某个领域形成垄断或高进入门槛。</li>
</ul>
<hr>
<h3 id="二、如何迅速认知事物的本质？"><a href="#二、如何迅速认知事物的本质？" class="headerlink" title="二、如何迅速认知事物的本质？"></a><strong>二、如何迅速认知事物的本质？</strong></h3><p>要快速洞察事物的本质，需要建立一套 <strong>高效的认知框架</strong>，避免陷入表象和信息噪音之中。  </p>
<h4 id="1-用“第一性原理”拆解问题"><a href="#1-用“第一性原理”拆解问题" class="headerlink" title="1. 用“第一性原理”拆解问题"></a><strong>1. 用“第一性原理”拆解问题</strong></h4><p><strong>第一性原理</strong>（First Principles Thinking）是埃隆·马斯克等人极力推崇的思维方式，即 <strong>从基本事实和原理出发，层层推理，去掉一切假设和框架</strong>。  </p>
<ul>
<li><strong>如何使用？</strong><br>例如，如果要理解 <strong>“为什么贫富差距越来越大？”</strong>，用第一性原理拆解：  <ul>
<li>资本的复利效应：富人投资资本 -&gt; 资本增长 -&gt; 收益持续累积。  </li>
<li>资源分配的不对称性：有资源者获取更多机会，社会结构难以逆转。  </li>
<li>技术提升对劳动力需求的改变：自动化降低低技能劳动者的市场价值。<br><strong>结论</strong>：财富不均是市场机制的必然结果，短期难以通过外部干预消除。</li>
</ul>
</li>
</ul>
<h4 id="2-逆向思考法"><a href="#2-逆向思考法" class="headerlink" title="2. 逆向思考法"></a><strong>2. 逆向思考法</strong></h4><ul>
<li><strong>与主流认知反向思考</strong>，避免盲目跟风。例如：  <ul>
<li>大部分人认为“学历决定命运”，但事实是 <strong>学历只是敲门砖，真正决定命运的是能力+人脉+资源</strong>。  </li>
<li>大部分人相信“努力就会成功”，但更接近现实的是 <strong>选择比努力更重要，认知边界决定了成功概率</strong>。<br><strong>如何练习？</strong>  </li>
<li>每当你看到一个社会现象，问自己：如果事实正好相反会怎样？</li>
</ul>
</li>
</ul>
<h4 id="3-框架化思维：用多元思维模型分析问题"><a href="#3-框架化思维：用多元思维模型分析问题" class="headerlink" title="3. 框架化思维：用多元思维模型分析问题"></a><strong>3. 框架化思维：用多元思维模型分析问题</strong></h4><p>查理·芒格提倡 <strong>“多元思维模型”</strong>，即用不同学科的思维方式看问题，让自己更接近客观真相。例如：  </p>
<ul>
<li><strong>经济学</strong>：供需决定价格（市场现象）。  </li>
<li><strong>博弈论</strong>：策略互动决定个体行为（竞争关系）。  </li>
<li><strong>心理学</strong>：人受认知偏差影响（决策错误）。</li>
</ul>
<p><strong>练习方法</strong>：当遇到问题时，尝试用 <strong>不同学科的角度分析</strong>，寻找最佳解法。  </p>
<hr>
<h3 id="三、如何思考得更深，见解更犀利？"><a href="#三、如何思考得更深，见解更犀利？" class="headerlink" title="三、如何思考得更深，见解更犀利？"></a><strong>三、如何思考得更深，见解更犀利？</strong></h3><p>思维深度和犀利的见解，来自于 <strong>知识输入+思维训练+持续输出</strong>。  </p>
<h4 id="1-深度输入：阅读高质量信息"><a href="#1-深度输入：阅读高质量信息" class="headerlink" title="1. 深度输入：阅读高质量信息"></a><strong>1. 深度输入：阅读高质量信息</strong></h4><ul>
<li>选择 <strong>跨学科、底层逻辑强的书</strong>，如《穷查理宝典》《思考，快与慢》《自私的基因》这些能塑造思维方式的书籍。  </li>
<li>阅读具有洞察力的文章，例如 <strong>经济学、科技前沿、社会学分析</strong>，而不是被快餐化信息（微博、短视频）消耗注意力。</li>
</ul>
<h4 id="2-逼迫自己用逻辑拆解问题"><a href="#2-逼迫自己用逻辑拆解问题" class="headerlink" title="2. 逼迫自己用逻辑拆解问题"></a><strong>2. 逼迫自己用逻辑拆解问题</strong></h4><ul>
<li>看到一个观点时，问自己 <strong>“它的依据是什么？”</strong>，然后尝试拆解成逻辑链。  </li>
<li>训练自己表达一个观点时，能用 <strong>3-5 个清晰的理由支持</strong>，避免模糊化思考。</li>
</ul>
<h4 id="3-多做思维实验，模拟真实情境"><a href="#3-多做思维实验，模拟真实情境" class="headerlink" title="3. 多做思维实验，模拟真实情境"></a><strong>3. 多做思维实验，模拟真实情境</strong></h4><ul>
<li><strong>代入不同角色思考</strong>：如果我是政府、资本家、普通打工人，我会怎么决策？  </li>
<li><strong>假设极端情况</strong>：如果社会崩溃，最有价值的能力是什么？如果 AI 取代 80% 的职业，我们应该如何应对？</li>
</ul>
<h4 id="4-输出见解，逼迫自己思考更透彻"><a href="#4-输出见解，逼迫自己思考更透彻" class="headerlink" title="4. 输出见解，逼迫自己思考更透彻"></a><strong>4. 输出见解，逼迫自己思考更透彻</strong></h4><ul>
<li>通过 <strong>写作、演讲、讨论</strong> 逼迫自己把想法表达清楚，提高逻辑性。  </li>
<li>发表观点后，欢迎别人的批评和挑战，思考自己是否有漏洞，从而不断优化认知。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol>
<li><strong>社会运行的本质</strong>：权力、资源、技术、文化共同塑造秩序，本质上社会规则是人为创造的。  </li>
<li><strong>人性的核心</strong>：趋利避害、有限理性、社会需求、竞争与合作并存。  </li>
<li><strong>生存法则</strong>：提升不可替代性、认清世界的不公平、利用规则建立优势。  </li>
<li><strong>迅速认知本质的方法</strong>：第一性原理拆解、逆向思维、多元思维模型。  </li>
<li><strong>如何思考得更深</strong>：深度输入+逻辑拆解+思维实验+持续输出。</li>
</ol>
<p><strong>思考的本质是不断突破认知边界，只有理解世界，才能更好地适应它。</strong> 🚀</p>
]]></content>
      <tags>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑链（思维链）培养</title>
    <url>/2025/02/06/%E9%80%BB%E8%BE%91%E9%93%BE%EF%BC%88%E6%80%9D%E7%BB%B4%E9%93%BE%EF%BC%89%E5%9F%B9%E5%85%BB/</url>
    <content><![CDATA[<h3 id="如何训练逻辑拆解与逻辑链？"><a href="#如何训练逻辑拆解与逻辑链？" class="headerlink" title="如何训练逻辑拆解与逻辑链？"></a><strong>如何训练逻辑拆解与逻辑链？</strong></h3><p>逻辑拆解能力的核心在于 <strong>结构化思维</strong> 和 <strong>系统性推理</strong>。要训练这一能力，需要掌握一些方法论，并通过持续实践加速掌握。  </p>
<hr>
<h2 id="一、逻辑拆解的核心原则"><a href="#一、逻辑拆解的核心原则" class="headerlink" title="一、逻辑拆解的核心原则"></a><strong>一、逻辑拆解的核心原则</strong></h2><p>在训练逻辑思维前，先明确 <strong>逻辑拆解</strong> 需要遵循的几个核心原则：  </p>
<ol>
<li><p><strong>MECE 原则（相互独立，完全穷尽）</strong>  </p>
<ul>
<li><strong>Mutually Exclusive（相互独立）</strong>：拆解的各部分不应有重叠。  </li>
<li><strong>Collectively Exhaustive（完全穷尽）</strong>：拆解的部分应覆盖整体，不能遗漏。  </li>
<li>📌 <strong>示例</strong>：如果要分析“提升工作效率的方法”，按 MECE 原则拆解：  <ul>
<li><strong>工具层面</strong>：自动化工具、AI 辅助、优化软件配置  </li>
<li><strong>方法层面</strong>：番茄工作法、任务优先级管理、时间管理  </li>
<li><strong>环境层面</strong>：减少干扰、优化工位、提升身体状态</li>
</ul>
</li>
<li><strong>错误拆解</strong>：如果“AI 辅助”和“自动化工具”有重叠，或者漏掉“环境因素”，就不符合 MECE。</li>
</ul>
</li>
<li><p><strong>金字塔原理（Pyramid Principle）</strong>  </p>
<ul>
<li>由上到下：先结论，再展开论证。  </li>
<li>由下到上：通过事实支撑结论，确保逻辑链完整。  </li>
<li>📌 <strong>示例</strong>：“为什么学习逻辑拆解很重要？”  <ul>
<li><strong>结论</strong>：掌握逻辑拆解能提升思维效率，避免模糊思考。  </li>
<li><strong>分论点</strong>：  <ol>
<li>逻辑拆解让你更容易分析复杂问题（举例：商业决策、市场分析）。  </li>
<li>逻辑拆解提升沟通表达能力（举例：让别人更快理解你的观点）。  </li>
<li>逻辑拆解有助于避免认知偏差（举例：避免情绪化决策）。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>因果推理（Causal Reasoning）</strong>  </p>
<ul>
<li>逻辑链必须能解释“为什么 A 导致 B”。  </li>
<li><strong>训练方法</strong>：每次看到一个结论时，问自己“它的依据是什么？”  </li>
<li>📌 <strong>示例</strong>：“为什么贫富差距越来越大？”  <ul>
<li>直接说“因为资本主义”是无效解释，逻辑链需要拆解：</li>
</ul>
<ol>
<li>资本的复利效应导致富人财富增长快于穷人。  </li>
<li>资源的分配结构使低收入人群难以获得增值资产。  </li>
<li>技术进步导致高技能人才的收入增长远高于低技能劳动力。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>费曼技巧（Feynman Technique）</strong>  </p>
<ul>
<li>通过 <strong>教会别人</strong> 来检验自己的逻辑是否清晰。  </li>
<li>📌 <strong>方法</strong>：拿一个复杂概念（如量子力学、通货膨胀），用最简单的语言解释，如果不能做到，就说明理解不透彻。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="二、逻辑链训练方法"><a href="#二、逻辑链训练方法" class="headerlink" title="二、逻辑链训练方法"></a><strong>二、逻辑链训练方法</strong></h2><p><strong>1. 逆向思考训练（Invert Thinking）</strong>  </p>
<ul>
<li>反向推理：如果结论是错的，最可能的原因是什么？  </li>
<li>📌 <strong>示例</strong>：“如何避免投资失败？” → 逆向思考：“投资失败的常见原因是什么？”  <ul>
<li>过度自信，买高风险资产  </li>
<li>盲目跟风，没有研究市场  </li>
<li>缺乏耐心，频繁交易导致损失</li>
</ul>
</li>
<li><strong>练习方法</strong>：每天找一个结论，逆向推演错误情况，锻炼因果逻辑能力。</li>
</ul>
<p><strong>2. 逻辑树训练（Logic Tree）</strong>  </p>
<ul>
<li>逻辑树是一种 <strong>从中心问题向外扩展</strong> 的拆解方式，用于分解复杂问题。  </li>
<li>📌 <strong>示例</strong>：“提高公司盈利能力的核心因素是什么？”  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌── 产品定价  </span><br><span class="line">│   ├── 市场需求  </span><br><span class="line">│   ├── 竞争对手价格  </span><br><span class="line">│   ├── 生产成本  </span><br><span class="line">│  </span><br><span class="line">├── 运营效率  </span><br><span class="line">│   ├── 供应链优化  </span><br><span class="line">│   ├── 自动化管理  </span><br><span class="line">│  </span><br><span class="line">├── 客户获取  </span><br><span class="line">    ├── 营销策略  </span><br><span class="line">    ├── 品牌影响力  </span><br><span class="line">    ├── 口碑传播</span><br></pre></td></tr></table></figure></li>
<li><strong>练习方法</strong>：每天选择一个问题，画出逻辑树，确保各层级不重叠、不遗漏。</li>
</ul>
<p><strong>3. 案例分析法（Case Study Thinking）</strong>  </p>
<ul>
<li>选择真实商业案例，尝试拆解其成功或失败的逻辑。  </li>
<li>📌 <strong>示例</strong>：“为什么拼多多能在竞争激烈的电商市场成功？”  <ol>
<li><strong>低价策略</strong>：主打下沉市场，利用社交裂变获取用户。  </li>
<li><strong>供应链控制</strong>：去中间商，提高利润率。  </li>
<li><strong>用户心理</strong>：利用社交拼团带来价格敏感用户。</li>
</ol>
</li>
<li><strong>练习方法</strong>：每周选一个企业，自己拆解其商业模式，形成分析报告。</li>
</ul>
<p><strong>4. “五个为什么”法（5 Whys）</strong>  </p>
<ul>
<li>连续问自己 “为什么” 至少 5 次，直到找到问题的根因。  </li>
<li>📌 <strong>示例</strong>：“为什么工作效率低？”  <ol>
<li><strong>为什么？</strong> → 因为总是拖延。  </li>
<li><strong>为什么？</strong> → 因为任务太多，不知道先做什么。  </li>
<li><strong>为什么？</strong> → 因为没有优先级管理。  </li>
<li><strong>为什么？</strong> → 因为没有清晰的目标。  </li>
<li><strong>为什么？</strong> → 因为没有合理的时间管理习惯。</li>
</ol>
</li>
<li>解决方案：设定每日优先任务、使用番茄工作法、减少无效干扰。  </li>
<li><strong>练习方法</strong>：每天用 “五个为什么” 分析一个自己遇到的问题。</li>
</ul>
<hr>
<h2 id="三、如何加速掌握逻辑拆解？"><a href="#三、如何加速掌握逻辑拆解？" class="headerlink" title="三、如何加速掌握逻辑拆解？"></a><strong>三、如何加速掌握逻辑拆解？</strong></h2><ol>
<li><p><strong>每天训练至少 15 分钟</strong>：</p>
<ul>
<li>选择一个主题，尝试用 <strong>MECE 原则、逻辑树、金字塔原理</strong> 拆解。  </li>
<li>用 “五个为什么” 练习问题溯源。</li>
</ul>
</li>
<li><p><strong>主动输出，逼迫自己表达清晰</strong>：</p>
<ul>
<li><strong>写作训练</strong>：尝试写逻辑清晰的分析文章，比如“如何做好职业规划？”  </li>
<li><strong>口头表达</strong>：找朋友讨论一个问题，要求自己条理清晰地解释观点。</li>
</ul>
</li>
<li><p><strong>学会利用框架化工具</strong>：</p>
<ul>
<li><strong>金字塔原理</strong> → 先结论，再拆解。  </li>
<li><strong>逻辑树</strong> → 拆解复杂问题，找核心因素。  </li>
<li><strong>因果推理</strong> → 找到影响某个现象的真正原因。</li>
</ul>
</li>
<li><p><strong>学习优秀的逻辑表达者</strong>：</p>
<ul>
<li>关注一些逻辑清晰的商业分析、科技文章，如《第一性原理》《思考，快与慢》。  </li>
<li>观察一些顶级 CEO（如查理·芒格、埃隆·马斯克）的思维方式。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul>
<li><strong>逻辑拆解核心原则</strong>：MECE 原则、金字塔原理、因果推理、费曼技巧。  </li>
<li><strong>提升逻辑链的方法</strong>：逆向思考、逻辑树分析、案例分析、“五个为什么”训练。  </li>
<li><strong>如何加速掌握</strong>：每天练习 + 主动输出 + 学习优秀案例。</li>
</ul>
<p>长期训练，你会发现自己的逻辑思维越来越清晰，表达越来越精准，洞察事物本质的速度也越来越快！ 🚀</p>
]]></content>
      <tags>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s问题排查类总结</title>
    <url>/2025/02/10/k8s%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="容器与宿主机之间复制文件"><a href="#容器与宿主机之间复制文件" class="headerlink" title="容器与宿主机之间复制文件"></a>容器与宿主机之间复制文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl cp &lt;pod_name&gt;:&lt;container_path&gt; &lt;local_path&gt;</span><br><span class="line">kubectl cp &lt;local_path&gt; &lt;pod_name&gt;:&lt;container_path&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#docker</span><br><span class="line">docker cp &lt;container_name&gt;:&lt;container_path&gt; &lt;host_path&gt;</span><br><span class="line">docker cp &lt;host_path&gt; &lt;container_name&gt;:&lt;container_path&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="netshoot网络调试容器（也可以在宿主机上使用nsenter）"><a href="#netshoot网络调试容器（也可以在宿主机上使用nsenter）" class="headerlink" title="netshoot网络调试容器（也可以在宿主机上使用nsenter）"></a>netshoot网络调试容器（也可以在宿主机上使用nsenter）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#介绍</span><br><span class="line">https://github.com/nicolaka/netshoot</span><br><span class="line"></span><br><span class="line">#k8s命令</span><br><span class="line">kubectl run tmp-shell --rm -it --image swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/nicolaka/netshoot:v0.13</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#加入一个长时间运行的命令，如 tail -f /dev/null，使得容器一直处于运行状态</span><br><span class="line">echo &quot;</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: tmp-mysql</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/nicolaka/netshoot:latest</span><br><span class="line">    name: tmp-shell</span><br><span class="line">    resources: &#123;&#125;</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    command: [\&quot;/bin/sh\&quot;, \&quot;-c\&quot;, \&quot;tail -f /dev/null\&quot;]  # 保持容器运行</span><br><span class="line">  dnsPolicy: ClusterFirst</span><br><span class="line">  restartPolicy: Never</span><br><span class="line">&quot; | kubectl apply -f -</span><br></pre></td></tr></table></figure>

<h2 id="数据库连接验证"><a href="#数据库连接验证" class="headerlink" title="数据库连接验证"></a>数据库连接验证</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#docker</span><br><span class="line">docker run -it --rm mysql:5.7 mysql -h &lt;host&gt; -P &lt;port&gt; -D &lt;database&gt; -u &lt;user&gt; -p &lt;passwd&gt;</span><br><span class="line"></span><br><span class="line">#宿主机上nsenter验证</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="高级调试分析"><a href="#高级调试分析" class="headerlink" title="高级调试分析"></a>高级调试分析</h2><h3 id="Jaeger"><a href="#Jaeger" class="headerlink" title="Jaeger"></a>Jaeger</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo add jaegertracing https://jaegertracing.github.io/helm-charts</span><br><span class="line">helm repo update</span><br><span class="line">helm install jaeger jaegertracing/jaeger</span><br><span class="line"></span><br><span class="line">#应用程序代码中添加 Jaeger 客户端库，并将其配置为向 Jaeger 后端报告</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>kubectl rollout 命令的常见操作</title>
    <url>/2025/02/10/kubectl-rollout-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="kubectl-rollout-命令的常见操作"><a href="#kubectl-rollout-命令的常见操作" class="headerlink" title="kubectl rollout 命令的常见操作"></a><strong><code>kubectl rollout</code> 命令的常见操作</strong></h3><p><code>kubectl rollout</code> 主要用于管理 <strong>Deployment、DaemonSet 和 StatefulSet</strong> 等控制器的 <strong>更新、回滚和状态查询</strong>。以下是常见用法汇总：</p>
<h4 id="1-滚动重启-Deployment"><a href="#1-滚动重启-Deployment" class="headerlink" title="1. 滚动重启 Deployment"></a><strong>1. 滚动重启 Deployment</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout restart deployment &lt;deployment-name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：逐步终止并重新创建 Pod，适用于配置变更但未修改 <code>image</code> 时。</li>
</ul>
<h4 id="2-查看-Deployment-DaemonSet-StatefulSet-的更新状态"><a href="#2-查看-Deployment-DaemonSet-StatefulSet-的更新状态" class="headerlink" title="2. 查看 Deployment&#x2F;DaemonSet&#x2F;StatefulSet 的更新状态"></a><strong>2. 查看 Deployment&#x2F;DaemonSet&#x2F;StatefulSet 的更新状态</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout status deployment &lt;deployment-name&gt; -n &lt;namespace&gt;</span><br><span class="line">kubectl rollout status daemonset &lt;daemonset-name&gt; -n &lt;namespace&gt;</span><br><span class="line">kubectl rollout status statefulset &lt;statefulset-name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：检查滚动更新的状态，确保 Pod 更新完成。</li>
</ul>
<h4 id="3-进行版本回滚"><a href="#3-进行版本回滚" class="headerlink" title="3. 进行版本回滚"></a><strong>3. 进行版本回滚</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment &lt;deployment-name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：回滚到上一个版本，适用于错误的更新。</li>
</ul>
<h4 id="4-指定回滚到某个历史版本"><a href="#4-指定回滚到某个历史版本" class="headerlink" title="4. 指定回滚到某个历史版本"></a><strong>4. 指定回滚到某个历史版本</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment &lt;deployment-name&gt; --to-revision=&lt;revision-number&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：回滚到指定的历史版本。</li>
</ul>
<h4 id="5-查看-Deployment-的修订历史"><a href="#5-查看-Deployment-的修订历史" class="headerlink" title="5. 查看 Deployment 的修订历史"></a><strong>5. 查看 Deployment 的修订历史</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout <span class="built_in">history</span> deployment &lt;deployment-name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：列出所有历史版本，方便回滚。</li>
</ul>
<h4 id="6-暂停-Deployment-的更新"><a href="#6-暂停-Deployment-的更新" class="headerlink" title="6. 暂停 Deployment 的更新"></a><strong>6. 暂停 Deployment 的更新</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout pause deployment &lt;deployment-name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：暂停滚动更新，适用于批量修改多个参数但不立即生效。</li>
</ul>
<h4 id="7-继续-Deployment-的更新"><a href="#7-继续-Deployment-的更新" class="headerlink" title="7. 继续 Deployment 的更新"></a><strong>7. 继续 Deployment 的更新</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl rollout resume deployment &lt;deployment-name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>作用</strong>：恢复之前暂停的 Deployment 更新。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>kubectl rollout restart</code></td>
<td>重新启动 Pod（滚动重启）</td>
</tr>
<tr>
<td><code>kubectl rollout status</code></td>
<td>查看更新状态</td>
</tr>
<tr>
<td><code>kubectl rollout undo</code></td>
<td>版本回滚</td>
</tr>
<tr>
<td><code>kubectl rollout undo --to-revision=X</code></td>
<td>回滚到指定版本</td>
</tr>
<tr>
<td><code>kubectl rollout history</code></td>
<td>查看修订历史</td>
</tr>
<tr>
<td><code>kubectl rollout pause</code></td>
<td>暂停滚动更新</td>
</tr>
<tr>
<td><code>kubectl rollout resume</code></td>
<td>继续滚动更新</td>
</tr>
</tbody></table>
<p>这些命令在 Kubernetes <strong>CI&#x2F;CD 更新、问题回滚、版本控制</strong> 等场景中非常常用。</p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>rke命令解析</title>
    <url>/2025/02/14/rke%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="🔍-RKE-v1-5-13-主要功能"><a href="#🔍-RKE-v1-5-13-主要功能" class="headerlink" title="🔍 RKE v1.5.13 主要功能"></a><strong>🔍 RKE v1.5.13 主要功能</strong></h2><p>Rancher Kubernetes Engine (RKE) 是 Rancher Labs 开发的 <strong>轻量级 Kubernetes 安装工具</strong>，适用于裸机和云环境。<strong>v1.5.13</strong> 是 <strong>RKE 1.x 系列的一个稳定版本</strong>，支持 Kubernetes v1.26.x，并提供了一些关键功能：</p>
<p>✅ <strong>多节点集群管理</strong>（支持 etcd、controlplane、worker 节点）<br>✅ <strong>高可用 Kubernetes 安装</strong>（多 etcd 保障 HA）<br>✅ <strong>SSH 远程管理</strong>（基于 SSH 访问集群，无需额外工具）<br>✅ <strong>支持多种 CNI 网络插件</strong>（Flannel、Canal、Calico、Weave）<br>✅ <strong>容器运行时支持</strong>（Docker）<br>✅ <strong>自动生成 Kubernetes 证书</strong><br>✅ <strong>故障恢复和状态管理</strong>（state file）<br>✅ <strong>集群增删节点</strong>（动态扩缩容）<br>✅ <strong>Air-Gap 离线安装</strong>（可在无外网环境安装）  </p>
<hr>
<h2 id="📌-常用-RKE-命令总结"><a href="#📌-常用-RKE-命令总结" class="headerlink" title="📌 常用 RKE 命令总结"></a><strong>📌 常用 RKE 命令总结</strong></h2><p>以下是 RKE 的 <strong>常用命令</strong> 及 <strong>具体使用场景</strong>，涵盖 Kubernetes 集群的 <strong>初始化、扩容、升级、删除</strong> 等操作。</p>
<h3 id="1️⃣-初始化-Kubernetes-集群"><a href="#1️⃣-初始化-Kubernetes-集群" class="headerlink" title="1️⃣ 初始化 Kubernetes 集群"></a><strong>1️⃣ 初始化 Kubernetes 集群</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rke up --config cluster.yml</span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：</p>
<ul>
<li>读取 <code>cluster.yml</code> 配置文件 <strong>创建</strong> 或 <strong>更新</strong> Kubernetes 集群。</li>
</ul>
<p>📌 <strong>使用场景</strong>：</p>
<ul>
<li><strong>第一次部署</strong> Kubernetes 集群。</li>
<li><strong>更新集群配置</strong>（例如变更节点角色、调整网络插件等）。</li>
</ul>
<hr>
<h3 id="2️⃣-添加新节点"><a href="#2️⃣-添加新节点" class="headerlink" title="2️⃣ 添加新节点"></a><strong>2️⃣ 添加新节点</strong></h3><p>📌 <strong>场景：集群扩容（新增 Master 或 Worker）</strong><br><strong>➜ 修改 <code>cluster.yml</code>，然后执行：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rke up --config cluster.yml</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>集群不会重装</strong>，RKE 会自动添加新节点，并重新生成 <code>kube_config</code> 文件。</li>
</ul>
<hr>
<h3 id="3️⃣-删除节点"><a href="#3️⃣-删除节点" class="headerlink" title="3️⃣ 删除节点"></a><strong>3️⃣ 删除节点</strong></h3><p>📌 <strong>场景：集群缩容（移除某个 etcd、controlplane、worker）</strong></p>
<ol>
<li>**编辑 <code>cluster.yml</code>**，删除对应节点信息。</li>
<li><strong>运行 RKE 更新集群</strong>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rke up --config cluster.yml</span><br></pre></td></tr></table></figure></li>
<li><strong>SSH 进入被移除的节点</strong>，执行：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -q)</span><br><span class="line">docker <span class="built_in">rm</span> $(docker ps -aq)</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="4️⃣-备份和恢复-etcd"><a href="#4️⃣-备份和恢复-etcd" class="headerlink" title="4️⃣ 备份和恢复 etcd"></a><strong>4️⃣ 备份和恢复 etcd</strong></h3><p>📌 <strong>场景：etcd 故障恢复</strong></p>
<h4 id="（1）手动备份-etcd"><a href="#（1）手动备份-etcd" class="headerlink" title="（1）手动备份 etcd"></a><strong>（1）手动备份 etcd</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rke etcd snapshot-save --name backup.db</span><br></pre></td></tr></table></figure>
<ul>
<li>备份 etcd 数据，文件存储在 <code>/opt/rke/etcd-snapshots/backup.db</code>。</li>
</ul>
<h4 id="（2）恢复-etcd"><a href="#（2）恢复-etcd" class="headerlink" title="（2）恢复 etcd"></a><strong>（2）恢复 etcd</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rke etcd snapshot-restore --name backup.db</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <strong>etcd 备份文件</strong> 还原整个集群状态。</li>
</ul>
<hr>
<h3 id="5️⃣-查看-RKE-版本"><a href="#5️⃣-查看-RKE-版本" class="headerlink" title="5️⃣ 查看 RKE 版本"></a><strong>5️⃣ 查看 RKE 版本</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rke --version</span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：查看当前 RKE 版本。</p>
<hr>
<h3 id="6️⃣-获取-kube-config-文件"><a href="#6️⃣-获取-kube-config-文件" class="headerlink" title="6️⃣ 获取 kube_config 文件"></a><strong>6️⃣ 获取 <code>kube_config</code> 文件</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rke config --list-all</span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：</p>
<ul>
<li>生成 <code>kube_config</code>，用于 <code>kubectl</code> 连接集群。</li>
</ul>
<p><strong>➜ 如果 <code>kube_config</code> 丢失，可重新生成：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rke up --config cluster.yml</span><br></pre></td></tr></table></figure>
<p>然后将 <code>kube_config_cluster.yml</code> 复制到 <code>~/.kube/config</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> kube_config_cluster.yml ~/.kube/config</span><br><span class="line"><span class="built_in">export</span> KUBECONFIG=~/.kube/config</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7️⃣-升级-Kubernetes"><a href="#7️⃣-升级-Kubernetes" class="headerlink" title="7️⃣ 升级 Kubernetes"></a><strong>7️⃣ 升级 Kubernetes</strong></h3><p>📌 <strong>场景：Kubernetes 版本升级</strong></p>
<ol>
<li><strong>修改 <code>cluster.yml</code>，更新 <code>kubernetes_version</code></strong><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kubernetes_version:</span> <span class="string">&quot;v1.26.15-rancher1-1&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>执行 RKE 重新部署</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rke up --config cluster.yml</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><strong>注意</strong>：确保 <strong>所有节点</strong> 运行支持的 Docker 版本。</li>
</ul>
<hr>
<h3 id="8️⃣-删除集群"><a href="#8️⃣-删除集群" class="headerlink" title="8️⃣ 删除集群"></a><strong>8️⃣ 删除集群</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rke remove --config cluster.yml</span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：</p>
<ul>
<li><strong>彻底删除 Kubernetes 集群</strong>，清理所有 RKE 相关容器。</li>
</ul>
<p>📌 <strong>慎用</strong>：</p>
<ul>
<li>该命令会清除所有 etcd 数据，无法恢复！</li>
</ul>
<hr>
<h3 id="9️⃣-诊断集群健康"><a href="#9️⃣-诊断集群健康" class="headerlink" title="9️⃣ 诊断集群健康"></a><strong>9️⃣ 诊断集群健康</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rke up --config cluster.yml --debug</span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：</p>
<ul>
<li>以 <strong>Debug 模式</strong> 启动 RKE，显示详细日志信息。</li>
<li>适用于 <strong>排查 RKE 运行失败的情况</strong>。</li>
</ul>
<hr>
<h2 id="📌-总结"><a href="#📌-总结" class="headerlink" title="📌 总结"></a><strong>📌 总结</strong></h2><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>使用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>rke up</code></td>
<td>初始化或更新 Kubernetes 集群</td>
</tr>
<tr>
<td><code>rke remove</code></td>
<td><strong>删除 Kubernetes 集群</strong>（⚠️ 慎用！）</td>
</tr>
<tr>
<td><code>rke etcd snapshot-save</code></td>
<td><strong>备份 etcd</strong>（快照）</td>
</tr>
<tr>
<td><code>rke etcd snapshot-restore</code></td>
<td><strong>恢复 etcd</strong>（从备份还原）</td>
</tr>
<tr>
<td><code>rke config --list-all</code></td>
<td>获取 <code>kube_config</code> 配置</td>
</tr>
<tr>
<td><code>rke --version</code></td>
<td>查看 RKE 版本</td>
</tr>
<tr>
<td><code>rke up --debug</code></td>
<td><strong>调试模式</strong> 运行 RKE，排查错误</td>
</tr>
<tr>
<td><code>rke up --config cluster.yml</code></td>
<td><strong>添加或删除节点</strong></td>
</tr>
<tr>
<td><code>rke up --config cluster.yml</code>（更新 <code>kubernetes_version</code>）</td>
<td><strong>升级 Kubernetes</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="🚀-RKE-适用场景"><a href="#🚀-RKE-适用场景" class="headerlink" title="🚀 RKE 适用场景"></a><strong>🚀 RKE 适用场景</strong></h2><p>✅ <strong>适合离线安装</strong>（无需外部网络）<br>✅ <strong>适合多节点、云&#x2F;裸机环境</strong>（支持 HA 集群）<br>✅ <strong>免去复杂的 <code>kubeadm</code> 配置</strong>，简化 Kubernetes 安装<br>✅ <strong>自动处理证书管理</strong>，减少人为错误  </p>
<hr>
<h2 id="📌-你的下一步"><a href="#📌-你的下一步" class="headerlink" title="📌 你的下一步"></a><strong>📌 你的下一步</strong></h2><p>1️⃣ <strong>查看 <code>cluster.yml</code> 配置是否正确</strong>：<br>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> cluster.yml</span><br></pre></td></tr></table></figure><br>2️⃣ <strong>使用 <code>rke up</code> 部署集群</strong>：<br>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rke up --config cluster.yml</span><br></pre></td></tr></table></figure><br>3️⃣ <strong>使用 <code>kubectl</code> 连接 Kubernetes</strong>：<br>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>curl --unix-socket 用法</title>
    <url>/2025/02/14/curl-unix-socket-%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="📌-curl-unix-socket-的作用"><a href="#📌-curl-unix-socket-的作用" class="headerlink" title="📌 curl --unix-socket 的作用"></a><strong>📌 <code>curl --unix-socket</code> 的作用</strong></h2><p><code>curl --unix-socket</code> 选项用于 <strong>通过 UNIX 域套接字（Unix Domain Socket, UDS）</strong> 发送 HTTP 请求。它主要用于 <strong>与本地进程通信</strong>，而不依赖 TCP 网络端口。例如：</p>
<ul>
<li><strong>与 Docker Daemon 交互</strong>（<code>/var/run/docker.sock</code>）</li>
<li><strong>与 Podman、Containerd 交互</strong></li>
<li><strong>与 Nginx、Envoy 代理本地服务</strong></li>
<li><strong>访问本地 REST API</strong></li>
</ul>
<hr>
<h2 id="📌-curl-unix-socket-var-run-docker-sock-在-Docker-中的常见用法"><a href="#📌-curl-unix-socket-var-run-docker-sock-在-Docker-中的常见用法" class="headerlink" title="📌 curl --unix-socket /var/run/docker.sock 在 Docker 中的常见用法"></a><strong>📌 <code>curl --unix-socket /var/run/docker.sock</code> 在 Docker 中的常见用法</strong></h2><p>Docker 的 **API 服务器监听 <code>/var/run/docker.sock</code>**，可以使用 <code>curl</code> 直接向 <strong>Docker API</strong> 发送 HTTP 请求，而 <strong>不需要 <code>docker</code> CLI 工具</strong>。</p>
<hr>
<h3 id="1️⃣-获取-Docker-版本信息"><a href="#1️⃣-获取-Docker-版本信息" class="headerlink" title="1️⃣ 获取 Docker 版本信息"></a><strong>1️⃣ 获取 Docker 版本信息</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock http://localhost/version</span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：查询 Docker 服务器的 API 版本。</p>
<p>📌 <strong>返回示例</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;24.0.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ApiVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.41&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;MinAPIVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.12&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;GitCommit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;abcdef123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;GoVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;go1.20.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Os&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Arch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2️⃣-获取所有运行的容器"><a href="#2️⃣-获取所有运行的容器" class="headerlink" title="2️⃣ 获取所有运行的容器"></a><strong>2️⃣ 获取所有运行的容器</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock http://localhost/containers/json</span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：返回所有正在运行的 Docker 容器列表（类似 <code>docker ps</code>）。</p>
<p>📌 <strong>返回示例</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b9b3f20a9a5f&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Names&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;/nginx&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nginx:latest&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;State&quot;</span><span class="punctuation">:</span> <span class="string">&quot;running&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Ports&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span><span class="attr">&quot;PrivatePort&quot;</span><span class="punctuation">:</span> <span class="number">80</span><span class="punctuation">,</span> <span class="attr">&quot;PublicPort&quot;</span><span class="punctuation">:</span> <span class="number">8080</span><span class="punctuation">,</span> <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tcp&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3️⃣-获取所有容器（包含已停止的）"><a href="#3️⃣-获取所有容器（包含已停止的）" class="headerlink" title="3️⃣ 获取所有容器（包含已停止的）"></a><strong>3️⃣ 获取所有容器（包含已停止的）</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock <span class="string">&quot;http://localhost/containers/json?all=true&quot;</span></span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：类似 <code>docker ps -a</code>，<strong>列出所有容器</strong>（包括停止的）。</p>
<hr>
<h3 id="4️⃣-获取某个容器的详细信息"><a href="#4️⃣-获取某个容器的详细信息" class="headerlink" title="4️⃣ 获取某个容器的详细信息"></a><strong>4️⃣ 获取某个容器的详细信息</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock http://localhost/containers/nginx/json</span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：获取 <code>nginx</code> 容器的详细信息。</p>
<p>📌 <strong>返回示例</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b9b3f20a9a5f&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;State&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;running&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Running&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Paused&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Restarting&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b9b3f20a9a5f&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nginx:latest&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Cmd&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;nginx&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span> <span class="string">&quot;daemon off;&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5️⃣-停止容器"><a href="#5️⃣-停止容器" class="headerlink" title="5️⃣ 停止容器"></a><strong>5️⃣ 停止容器</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock -X POST http://localhost/containers/nginx/stop</span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：停止 <code>nginx</code> 容器（类似 <code>docker stop nginx</code>）。</p>
<hr>
<h3 id="6️⃣-删除容器"><a href="#6️⃣-删除容器" class="headerlink" title="6️⃣ 删除容器"></a><strong>6️⃣ 删除容器</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock -X DELETE http://localhost/containers/nginx</span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：删除 <code>nginx</code> 容器（类似 <code>docker rm nginx</code>）。</p>
<hr>
<h3 id="7️⃣-创建并运行容器"><a href="#7️⃣-创建并运行容器" class="headerlink" title="7️⃣ 创建并运行容器"></a><strong>7️⃣ 创建并运行容器</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock -X POST \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;Image&quot;: &quot;nginx:latest&quot;,</span></span><br><span class="line"><span class="string">    &quot;Cmd&quot;: [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;],</span></span><br><span class="line"><span class="string">    &quot;HostConfig&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;PortBindings&quot;: &#123; &quot;80/tcp&quot;: [&#123; &quot;HostPort&quot;: &quot;8080&quot; &#125;] &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;&#x27;</span> http://localhost/containers/create</span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：使用 <code>nginx:latest</code> <strong>创建并运行</strong> 容器，并将容器的 <code>80</code> 端口映射到主机的 <code>8080</code> 端口。</p>
<p>📌 <strong>返回示例</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b9b3f20a9a5f...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Warnings&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后，使用以下命令启动该容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock -X POST http://localhost/containers/b9b3f20a9a5f/start</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8️⃣-获取所有-Docker-镜像"><a href="#8️⃣-获取所有-Docker-镜像" class="headerlink" title="8️⃣ 获取所有 Docker 镜像"></a><strong>8️⃣ 获取所有 Docker 镜像</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock http://localhost/images/json</span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：获取本地 Docker 镜像列表（类似 <code>docker images</code>）。</p>
<p>📌 <strong>返回示例</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sha256:4a27b...&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;RepoTags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;nginx:latest&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Size&quot;</span><span class="punctuation">:</span> <span class="number">1337323</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="9️⃣-拉取-Docker-镜像"><a href="#9️⃣-拉取-Docker-镜像" class="headerlink" title="9️⃣ 拉取 Docker 镜像"></a><strong>9️⃣ 拉取 Docker 镜像</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock -X POST \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123; &quot;fromImage&quot;: &quot;nginx&quot;, &quot;tag&quot;: &quot;latest&quot; &#125;&#x27;</span> \</span><br><span class="line">  http://localhost/images/create</span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：拉取 <code>nginx:latest</code> 镜像（类似 <code>docker pull nginx:latest</code>）。</p>
<hr>
<h3 id="🔟-监控-Docker-事件"><a href="#🔟-监控-Docker-事件" class="headerlink" title="🔟 监控 Docker 事件"></a><strong>🔟 监控 Docker 事件</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock http://localhost/events</span><br></pre></td></tr></table></figure>
<p>📌 <strong>作用</strong>：<strong>实时监听 Docker 事件</strong>（如容器创建、删除、启动等）。</p>
<p>📌 <strong>示例输出</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;start&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b9b3f20a9a5f...&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nginx&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;container&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;start&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📌-总结"><a href="#📌-总结" class="headerlink" title="📌 总结"></a><strong>📌 总结</strong></h2><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>curl --unix-socket /var/run/docker.sock http://localhost/version</code></td>
<td>获取 Docker 版本信息</td>
</tr>
<tr>
<td><code>curl --unix-socket /var/run/docker.sock http://localhost/containers/json</code></td>
<td>获取运行中的容器列表</td>
</tr>
<tr>
<td><code>curl --unix-socket /var/run/docker.sock &quot;http://localhost/containers/json?all=true&quot;</code></td>
<td>获取所有容器（包括停止的）</td>
</tr>
<tr>
<td><code>curl --unix-socket /var/run/docker.sock http://localhost/containers/nginx/json</code></td>
<td>获取 <code>nginx</code> 容器信息</td>
</tr>
<tr>
<td><code>curl --unix-socket /var/run/docker.sock -X POST http://localhost/containers/nginx/stop</code></td>
<td>停止 <code>nginx</code> 容器</td>
</tr>
<tr>
<td><code>curl --unix-socket /var/run/docker.sock -X DELETE http://localhost/containers/nginx</code></td>
<td>删除 <code>nginx</code> 容器</td>
</tr>
<tr>
<td><code>curl --unix-socket /var/run/docker.sock http://localhost/images/json</code></td>
<td>获取本地镜像</td>
</tr>
<tr>
<td><code>curl --unix-socket /var/run/docker.sock -X POST http://localhost/images/create -d &#39;&#123; &quot;fromImage&quot;: &quot;nginx&quot;, &quot;tag&quot;: &quot;latest&quot; &#125;&#39;</code></td>
<td>拉取 <code>nginx</code> 镜像</td>
</tr>
<tr>
<td><code>curl --unix-socket /var/run/docker.sock http://localhost/events</code></td>
<td>监听 Docker 事件</td>
</tr>
</tbody></table>
<hr>
<h2 id="🚀-你的下一步"><a href="#🚀-你的下一步" class="headerlink" title="🚀 你的下一步"></a><strong>🚀 你的下一步</strong></h2><p>1️⃣ <strong>检查 Docker API 是否开启</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock http://localhost/version</span><br></pre></td></tr></table></figure>
<p>如果返回 <code>Permission Denied</code>，尝试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 666 /var/run/docker.sock</span><br></pre></td></tr></table></figure>

<p>2️⃣ <strong>尝试 <code>curl</code> 操作容器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock http://localhost/containers/json</span><br></pre></td></tr></table></figure>

<p>3️⃣ <strong>测试创建 &amp; 运行容器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --unix-socket /var/run/docker.sock -X POST http://localhost/containers/create ...</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>🎯 这样，你就可以直接使用 <code>curl --unix-socket</code> 与 Docker 交互，而无需 <code>docker</code> CLI！</strong> 🚀</p>
<hr>
<h2 id="curl-URL-耗时分析"><a href="#curl-URL-耗时分析" class="headerlink" title="curl URL  耗时分析"></a>curl URL  耗时分析</h2><blockquote>
<p><a href="https://www.rockylinux.cn/notes/the-curl-command-detects-the-time-consumption-of-each-stage.html">https://www.rockylinux.cn/notes/the-curl-command-detects-the-time-consumption-of-each-stage.html</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -o /dev/null -s -w time_namelookup:&quot;\t&quot;%&#123;time_namelookup&#125;&quot;\n&quot;time_connect:&quot;\t\t&quot;%&#123;time_connect&#125;&quot;\n&quot;time_appconnect:&quot;\t&quot;%&#123;time_appconnect&#125;&quot;\n&quot;time_pretransfer:&quot;\t&quot;%&#123;time_pretransfer&#125;&quot;\n&quot;time_starttransfer:&quot;\t&quot;%&#123;time_starttransfer&#125;&quot;\n&quot;time_total:&quot;\t\t&quot;%&#123;time_total&#125;&quot;\n&quot;time_redirect:&quot;\t\t&quot;%&#123;time_redirect&#125;&quot;\n&quot; --location &#x27;https://api.rockylinux.cn&#x27; --header &#x27;Content-Type: application/json&#x27; --header &#x27;Cookie: ID=xxx;&#x27; --data &#x27;&#123;&quot;key&quot;:[&quot;xxx&quot;,&quot;xxx&quot;]&#125;&#x27;</span><br><span class="line"></span><br><span class="line">curl 命令的参数非常多，可以使用 curl --help all 命令查看所有参数，这里使用 curl 命令来测试接口性能，下面是每个参数的具体含义： </span><br><span class="line">-o /dev/null：告诉 curl 将下载的数据丢弃，不输出到任何文件中。</span><br><span class="line">&quot;/dev/null&quot; 是一个特殊的设备，它会丢弃所有写入它的数据。 </span><br><span class="line">-s：告诉 curl 在操作过程中不显示进度信息或错误信息。这通常用于在脚本中静默运行 curl。 </span><br><span class="line">-w：允许您设置显示的格式，后面跟的是具体的格式字符串。在这个命令中，它被用来显示各种时间信息。 </span><br><span class="line">time_namelookup：DNS 解析的时间，即从请求开始到域名解析完成的时间。 </span><br><span class="line">time_connect：建立到服务器的 TCP 连接所需的时间。 </span><br><span class="line">time_appconnect：建立到应用级别协议的连接所需的时间。例如，在使用 HTTPS 时，这将包括 SSL 握手的时间。 </span><br><span class="line">time_pretransfer：从请求开始到文件传输即将开始所需的时间。 </span><br><span class="line">time_starttransfer：从请求开始到第一个字节被 curl 接收的时间。 </span><br><span class="line">time_total：整个请求所需的总时间。 </span><br><span class="line">time_redirect：所有重定向步骤所需的时间，包括 DNS 解析、连接、预传输等。 https://api.rockylinux.cn：想要访问的网站的 URL。 这个命令的总体目的是测试访问指定 URL 各个阶段所需时间。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>rke离线安装k8s集群镜像列表问题</title>
    <url>/2025/02/17/rke%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85k8s%E9%9B%86%E7%BE%A4%E9%95%9C%E5%83%8F%E5%88%97%E8%A1%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://www.rockylinux.cn/notes/deploying-k8s-cluster-with-rke.html">https://www.rockylinux.cn/notes/deploying-k8s-cluster-with-rke.html</a></p>
</blockquote>
<h2 id="一、rke工具（不同版本支持的k8s集群版本不同）"><a href="#一、rke工具（不同版本支持的k8s集群版本不同）" class="headerlink" title="一、rke工具（不同版本支持的k8s集群版本不同）"></a>一、rke工具（不同版本支持的k8s集群版本不同）</h2><blockquote>
<p><a href="https://github.com/rancher/rke/releases">https://github.com/rancher/rke/releases</a></p>
</blockquote>
<h2 id="二、生成cluster-yml"><a href="#二、生成cluster-yml" class="headerlink" title="二、生成cluster.yml"></a>二、生成cluster.yml</h2><blockquote>
<p>参考:<a href="https://www.cnblogs.com/jdbinfo/p/17476878.html">https://www.cnblogs.com/jdbinfo/p/17476878.html</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">11.100.100.100</span><br><span class="line">$ rke config --name cluster.yml</span><br><span class="line">[+] Cluster Level SSH Private Key Path [~/.ssh/id_rsa]:</span><br><span class="line">[+] Number of Hosts [1]:</span><br><span class="line">[+] SSH Address of host (1) [none]: 11.100.100.100</span><br><span class="line">[+] SSH Port of host (1) [22]:</span><br><span class="line">[+] SSH Private Key Path of host (11.101.222.248) [none]: ~/.ssh/id_rsa</span><br><span class="line">[+] SSH User of host (11.101.222.248) [ubuntu]: stark</span><br><span class="line">[+] Is host (11.101.222.248) a Control Plane host (y/n)? [y]: y</span><br><span class="line">[+] Is host (11.101.222.248) a Worker host (y/n)? [n]: y</span><br><span class="line">[+] Is host (11.101.222.248) an etcd host (y/n)? [n]: y</span><br><span class="line">[+] Override Hostname of host (11.101.222.248) [none]:</span><br><span class="line">[+] Internal IP of host (11.101.222.248) [none]:</span><br><span class="line">[+] Docker socket path on host (11.101.222.248) [/var/run/docker.sock]:</span><br><span class="line">[+] Network Plugin Type (flannel, calico, weave, canal, aci) [canal]: calico</span><br><span class="line">[+] Authentication Strategy [x509]:</span><br><span class="line">[+] Authorization Mode (rbac, none) [rbac]:</span><br><span class="line">[+] Kubernetes Docker image [rancher/hyperkube:v1.28.13-rancher1]: rancher/hyperkube:v1.26.15-rancher1</span><br><span class="line">[+] Cluster domain [cluster.local]:</span><br><span class="line">[+] Service Cluster IP Range [10.43.0.0/16]:</span><br><span class="line">[+] Enable PodSecurityPolicy [n]:</span><br><span class="line">[+] Cluster Network CIDR [10.42.0.0/16]:</span><br><span class="line">[+] Cluster DNS Service IP [10.43.0.10]:</span><br><span class="line">[+] Add addon manifest URLs or YAML files [no]:</span><br></pre></td></tr></table></figure>

<h2 id="三、需离线下载的镜像"><a href="#三、需离线下载的镜像" class="headerlink" title="三、需离线下载的镜像"></a>三、需离线下载的镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat ./cluster.yml | grep &quot;rancher/&quot; | awk -F &quot;: &quot; &#x27;&#123;print $2&#125;&#x27; | sort | uniq | sort</span><br><span class="line">rancher/calico-cni:v3.27.4-rancher1</span><br><span class="line">rancher/flannel-cni:v0.3.0-rancher9</span><br><span class="line">rancher/hyperkube:v1.26.15-rancher1</span><br><span class="line">rancher/mirrored-calico-ctl:v3.27.4</span><br><span class="line">rancher/mirrored-calico-kube-controllers:v3.27.4</span><br><span class="line">rancher/mirrored-calico-node:v3.27.4</span><br><span class="line">rancher/mirrored-calico-pod2daemon-flexvol:v3.27.4</span><br><span class="line">rancher/mirrored-cluster-proportional-autoscaler:v1.8.9</span><br><span class="line">rancher/mirrored-coredns-coredns:1.10.1</span><br><span class="line">rancher/mirrored-coreos-etcd:v3.5.10</span><br><span class="line">rancher/mirrored-flannel-flannel:v0.24.2</span><br><span class="line">rancher/mirrored-ingress-nginx-kube-webhook-certgen:v20231226-1a7112e06</span><br><span class="line">rancher/mirrored-k8s-dns-dnsmasq-nanny:1.22.28</span><br><span class="line">rancher/mirrored-k8s-dns-kube-dns:1.22.28</span><br><span class="line">rancher/mirrored-k8s-dns-node-cache:1.22.28</span><br><span class="line">rancher/mirrored-k8s-dns-sidecar:1.22.28</span><br><span class="line">rancher/mirrored-metrics-server:v0.7.0</span><br><span class="line">rancher/mirrored-nginx-ingress-controller-defaultbackend:1.5-rancher1</span><br><span class="line">rancher/mirrored-pause:3.7</span><br><span class="line">rancher/nginx-ingress-controller:nginx-1.11.2-rancher1</span><br><span class="line">rancher/rke-tools:v0.1.102</span><br></pre></td></tr></table></figure>

<h2 id="四、下载k8s所需镜像并导出"><a href="#四、下载k8s所需镜像并导出" class="headerlink" title="四、下载k8s所需镜像并导出"></a>四、下载k8s所需镜像并导出</h2><blockquote>
<p>镜像加速：<br><a href="https://docker.aityp.com/">https://docker.aityp.com/</a><br><a href="https://www.coderjia.cn/archives/dba3f94c-a021-468a-8ac6-e840f85867ea">https://www.coderjia.cn/archives/dba3f94c-a021-468a-8ac6-e840f85867ea</a> </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">set -e  # 遇到错误就退出</span><br><span class="line">set -o pipefail  # 管道中任何命令失败都导致整个脚本失败</span><br><span class="line"></span><br><span class="line"># 镜像列表</span><br><span class="line">IMAGES=(</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/calico-cni:v3.27.4-rancher1&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/flannel-cni:v0.3.0-rancher9&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/hyperkube:v1.26.15-rancher1&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-calico-ctl:v3.27.4&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-calico-kube-controllers:v3.27.4&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-calico-node:v3.27.4&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-calico-pod2daemon-flexvol:v3.27.4&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-cluster-proportional-autoscaler:v1.8.9&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-coredns-coredns:1.10.1&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-coreos-etcd:v3.5.10&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-flannel-flannel:v0.24.2&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-ingress-nginx-kube-webhook-certgen:v20231226-1a7112e06&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-k8s-dns-dnsmasq-nanny:1.22.28&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-k8s-dns-kube-dns:1.22.28&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-k8s-dns-node-cache:1.22.28&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-k8s-dns-sidecar:1.22.28&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-metrics-server:v0.7.0&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-nginx-ingress-controller-defaultbackend:1.5-rancher1&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/mirrored-pause:3.7&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/nginx-ingress-controller:nginx-1.11.2-rancher1&quot;</span><br><span class="line">    &quot;hub.fast360.xyz/rancher/rke-tools:v0.1.102&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 下载并重新打 tag</span><br><span class="line">for IMAGE in &quot;$&#123;IMAGES[@]&#125;&quot;; do</span><br><span class="line">    echo &quot;Pulling $IMAGE ...&quot;</span><br><span class="line">    docker pull &quot;$IMAGE&quot;</span><br><span class="line"></span><br><span class="line">    # 去掉前缀 hub.fast360.xyz/</span><br><span class="line">    NEW_TAG=$(echo &quot;$IMAGE&quot; | sed &#x27;s|hub.fast360.xyz/||&#x27;)</span><br><span class="line"></span><br><span class="line">    echo &quot;Tagging $IMAGE as $NEW_TAG ...&quot;</span><br><span class="line">    docker tag &quot;$IMAGE&quot; &quot;$NEW_TAG&quot;</span><br><span class="line"></span><br><span class="line">    echo &quot;Removing original $IMAGE to save space ...&quot;</span><br><span class="line">    docker rmi &quot;$IMAGE&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 导出所有处理后的镜像</span><br><span class="line">echo &quot;Saving images to rke-images-1.26.15.tar ...&quot;</span><br><span class="line">docker save -o rke-images-1.26.15.tar $(docker images --format &quot;&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125;&quot; | grep grep rancher)</span><br><span class="line"></span><br><span class="line">echo &quot;All images downloaded, tagged, and saved successfully!&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>alpine源及使用</title>
    <url>/2025/02/20/alpine%E6%BA%90%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="alpine更换国内源"><a href="#alpine更换国内源" class="headerlink" title="alpine更换国内源"></a>alpine更换国内源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式一</span><br><span class="line">sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27; /etc/apk/repositories</span><br><span class="line"></span><br><span class="line">#方式二</span><br><span class="line">cat /etc/os-release</span><br><span class="line">cat &gt; test.txt &lt;&lt; EOF</span><br><span class="line">https://mirrors.aliyun.com/alpine/v3.19/main/</span><br><span class="line">https://mirrors.aliyun.com/alpine/v3.19/community/</span><br><span class="line">EOF</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="apk工具"><a href="#apk工具" class="headerlink" title="apk工具"></a>apk工具</h2><p><a href="https://wangchujiang.com/linux-command/c/apk.html" title="apk工具介绍">apk工具介绍</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>systemctl的一些用法</title>
    <url>/2025/02/24/systemctl%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><code>systemctl</code> 是 <strong>Systemd</strong> 系统和服务管理器的控制工具，在现代 Linux 系统中广泛使用。它用于启动、停止、重启、查看服务状态、管理服务单元（unit）等。</p>
<hr>
<h3 id="🌟-常用-systemctl-命令"><a href="#🌟-常用-systemctl-命令" class="headerlink" title="🌟 常用 systemctl 命令"></a>🌟 <strong>常用 systemctl 命令</strong></h3><h4 id="1-列出当前所有服务"><a href="#1-列出当前所有服务" class="headerlink" title="1. 列出当前所有服务"></a>1. <strong>列出当前所有服务</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl list-units --<span class="built_in">type</span>=service</span><br><span class="line">systemctl --no-pager list-units --<span class="built_in">type</span>=service</span><br></pre></td></tr></table></figure>
<ul>
<li>这个命令列出当前机器上所有正在运行的服务（包含活跃和非活跃的）。如果要查看更多详细信息，可以加上 <code>--all</code>。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl list-units --<span class="built_in">type</span>=service --all</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-查看服务的状态"><a href="#2-查看服务的状态" class="headerlink" title="2. 查看服务的状态"></a>2. <strong>查看服务的状态</strong></h4><p>查看某个服务（比如 <code>sshd</code>）的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status sshd</span><br></pre></td></tr></table></figure>
<ul>
<li>会显示该服务是否正在运行，启动类型（<code>active</code> 或 <code>inactive</code>），以及日志输出的最新部分。</li>
</ul>
<h4 id="3-启动服务"><a href="#3-启动服务" class="headerlink" title="3. 启动服务"></a>3. <strong>启动服务</strong></h4><p>启动某个服务，比如 <code>sshd</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start sshd</span><br></pre></td></tr></table></figure>
<ul>
<li>这将立即启动 <code>sshd</code> 服务。</li>
</ul>
<h4 id="4-停止服务"><a href="#4-停止服务" class="headerlink" title="4. 停止服务"></a>4. <strong>停止服务</strong></h4><p>停止某个服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop sshd</span><br></pre></td></tr></table></figure>
<ul>
<li>停止 <code>sshd</code> 服务后，你将无法通过 SSH 访问机器，除非本地访问或其他服务仍然活跃。</li>
</ul>
<h4 id="5-重启服务"><a href="#5-重启服务" class="headerlink" title="5. 重启服务"></a>5. <strong>重启服务</strong></h4><p>重启某个服务，适用于更新配置等操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>

<h4 id="6-重新加载服务配置"><a href="#6-重新加载服务配置" class="headerlink" title="6. 重新加载服务配置"></a>6. <strong>重新加载服务配置</strong></h4><p>有时候更改了服务的配置文件（例如 SSH 配置），并希望让服务应用新的配置，而不完全重启服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl reload sshd</span><br></pre></td></tr></table></figure>
<ul>
<li>此命令会让 <code>sshd</code> 服务重新加载配置，但不中断当前的连接。</li>
</ul>
<h4 id="7-启用服务开机自启"><a href="#7-启用服务开机自启" class="headerlink" title="7. 启用服务开机自启"></a>7. <strong>启用服务开机自启</strong></h4><p>使服务在系统启动时自动启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> sshd</span><br></pre></td></tr></table></figure>
<ul>
<li>这会创建一个符号链接，使 <code>sshd</code> 服务在系统启动时自动启动。</li>
</ul>
<h4 id="8-禁用服务自启"><a href="#8-禁用服务自启" class="headerlink" title="8. 禁用服务自启"></a>8. <strong>禁用服务自启</strong></h4><p>取消服务的开机自启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> sshd</span><br></pre></td></tr></table></figure>

<h4 id="9-查看服务日志"><a href="#9-查看服务日志" class="headerlink" title="9. 查看服务日志"></a>9. <strong>查看服务日志</strong></h4><p>查看 <code>sshd</code> 服务的日志，利用 <code>journalctl</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">journalctl -u sshd</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-u</code> 用来指定服务，默认显示最近的日志。如果需要查看更早的日志，可以使用 <code>--since</code> 和 <code>--until</code> 选项。</li>
</ul>
<h4 id="10-查看系统日志"><a href="#10-查看系统日志" class="headerlink" title="10. 查看系统日志"></a>10. <strong>查看系统日志</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">journalctl</span><br><span class="line"></span><br><span class="line">journalctl -u docker --no-pager -n 50</span><br></pre></td></tr></table></figure>
<ul>
<li>查看所有系统日志。默认会显示所有日志，如果想查看最近的日志，可以使用 <code>-n</code> 参数，查看最新的 100 行：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">journalctl -n 100</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-查看服务的启动类型"><a href="#11-查看服务的启动类型" class="headerlink" title="11. 查看服务的启动类型"></a>11. <strong>查看服务的启动类型</strong></h4><p>查看 <code>sshd</code> 服务的启动类型（是否是自动启动）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl is-enabled sshd</span><br></pre></td></tr></table></figure>
<ul>
<li>会显示 <code>enabled</code>（已启用）、<code>disabled</code>（已禁用）或者 <code>static</code>（由其他服务依赖的启动）。</li>
</ul>
<h4 id="12-查看服务的依赖"><a href="#12-查看服务的依赖" class="headerlink" title="12. 查看服务的依赖"></a>12. <strong>查看服务的依赖</strong></h4><p>查看服务的所有依赖项和依赖于它的服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl list-dependencies sshd</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🔧-对服务的其他操作"><a href="#🔧-对服务的其他操作" class="headerlink" title="🔧 对服务的其他操作"></a>🔧 <strong>对服务的其他操作</strong></h3><h4 id="13-查看服务的启动情况"><a href="#13-查看服务的启动情况" class="headerlink" title="13. 查看服务的启动情况"></a><strong>13. 查看服务的启动情况</strong></h4><p>查看当前系统启动时的所有服务状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl list-units --<span class="built_in">type</span>=service --state=running</span><br></pre></td></tr></table></figure>
<ul>
<li>这只会显示当前正在运行的服务。</li>
</ul>
<h4 id="14-查看是否正在等待某个服务"><a href="#14-查看是否正在等待某个服务" class="headerlink" title="14. 查看是否正在等待某个服务"></a><strong>14. 查看是否正在等待某个服务</strong></h4><p>如果你想查看某个服务（如 <code>sshd</code>）是否正在等待其他服务启动，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl show sshd</span><br></pre></td></tr></table></figure>

<h4 id="15-开机后立即启动服务"><a href="#15-开机后立即启动服务" class="headerlink" title="15. 开机后立即启动服务"></a><strong>15. 开机后立即启动服务</strong></h4><p>如果你想在系统启动时立即启动某个服务（而不是等到下次重启），可以使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start sshd</span><br></pre></td></tr></table></figure>

<h4 id="16-管理多个服务"><a href="#16-管理多个服务" class="headerlink" title="16. 管理多个服务"></a><strong>16. 管理多个服务</strong></h4><p>你可以在一个命令中管理多个服务。例如，停止 <code>sshd</code> 和 <code>nginx</code> 服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop sshd nginx</span><br></pre></td></tr></table></figure>

<h4 id="17-显示服务的更多细节"><a href="#17-显示服务的更多细节" class="headerlink" title="17. 显示服务的更多细节"></a><strong>17. 显示服务的更多细节</strong></h4><p>查看某个服务的详细信息（包括环境变量、启动命令等）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl show sshd</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="📋-总结"><a href="#📋-总结" class="headerlink" title="📋 总结"></a>📋 <strong>总结</strong></h3><ul>
<li><strong>启动&#x2F;停止&#x2F;重启</strong>：<code>start</code> &#x2F; <code>stop</code> &#x2F; <code>restart</code></li>
<li><strong>状态检查</strong>：<code>status</code></li>
<li><strong>查看日志</strong>：<code>journalctl -u &lt;service&gt;</code></li>
<li><strong>启用&#x2F;禁用自启</strong>：<code>enable</code> &#x2F; <code>disable</code></li>
<li><strong>服务依赖</strong>：<code>list-dependencies</code></li>
<li><strong>开机自启服务控制</strong>：<code>systemctl is-enabled &lt;service&gt;</code></li>
</ul>
<hr>
<h2 id="journalctl用法"><a href="#journalctl用法" class="headerlink" title="journalctl用法"></a>journalctl用法</h2><blockquote>
<p><a href="https://mp.weixin.qq.com/s/XAEyJ_LMXisHELcZO8jUpw">https://mp.weixin.qq.com/s/XAEyJ_LMXisHELcZO8jUpw</a><br><a href="https://mp.weixin.qq.com/s/FpDcGtKMcyLKFyk3jxnjcg">https://mp.weixin.qq.com/s/FpDcGtKMcyLKFyk3jxnjcg</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看所有日志</span><br><span class="line">journalctl</span><br><span class="line"></span><br><span class="line">#查看实时日志</span><br><span class="line">journalctl -f   </span><br><span class="line"></span><br><span class="line">#查看指定服务的日志, -u 即 --unit</span><br><span class="line">journalctl -u nginx   </span><br><span class="line"></span><br><span class="line">#查看指定行数的日志</span><br><span class="line">journalctl -n 5000             # -n 即 --lines</span><br><span class="line"></span><br><span class="line">#查看指定启动会话的日志</span><br><span class="line"># 查看当前启动会话的日志</span><br><span class="line">journalctl -b                  # -b 即 --boot</span><br><span class="line"></span><br><span class="line"># 查看上次启动会话的日志</span><br><span class="line">journalctl -b -1               # 依此类推，-2 ...</span><br><span class="line"></span><br><span class="line">#查看指定时间的日志</span><br><span class="line"># 查看开始于某个时间的日志</span><br><span class="line">journalctl -S &quot;2024-04-14&quot;  # -S 即 --since</span><br><span class="line">journalctl -S &quot;1 hour ago&quot; # 也可以是相对时间</span><br><span class="line"></span><br><span class="line"># 查看截止到某个时间的日志</span><br><span class="line">journalctl -U &quot;2025-04-15&quot; # -U 即 --until</span><br><span class="line">journalctl -U &quot;yesterday&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看指定优先级的日志</span><br><span class="line">journalctl -p 3 # -P 即 --priority</span><br><span class="line">journalctl -p 2..4</span><br><span class="line"></span><br><span class="line"># 查看多个优先级</span><br><span class="line"># O 或 emerg：系统不可用 （Emergency） </span><br><span class="line"># 1 或 alert： 需要立即采取行动 （Alert） </span><br><span class="line"># 2 或 crit：严重情况 （Critical） </span><br><span class="line"># 3 或 err： 错误情况 （Error）</span><br><span class="line"># 4 或 warning：警告情况 （Warning） </span><br><span class="line"># 5 或 notice： 正常但重要的情况 （Notice） </span><br><span class="line"># 6 或 info：一般信息 （Informational） </span><br><span class="line"># 7或 debug：调试信息 （Debug）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看内核日志</span><br><span class="line">journalctl -k   # -k 即 --dmesg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定日志输出格式</span><br><span class="line">journalctl -o json-pretty # -o 即 --output</span><br><span class="line"># 可选short、short-precise、short-iso、short-iso-precise、short-full、short-monotonic、short-unix、verbose、export、json、json-pretty、json-sse、json-seq、cat、with-unit</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>harbor离线镜像仓库搭建</title>
    <url>/2025/03/10/harbor%E7%A6%BB%E7%BA%BF%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="开源离线包"><a href="#开源离线包" class="headerlink" title="开源离线包"></a>开源离线包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/goharbor/harbor/releases</span><br></pre></td></tr></table></figure>

<h2 id="阿里云ECS安装harbor脚本"><a href="#阿里云ECS安装harbor脚本" class="headerlink" title="阿里云ECS安装harbor脚本"></a>阿里云ECS安装harbor脚本</h2><blockquote>
<p>参考<br><a href="https://blog.csdn.net/jianghuchuang/article/details/141362831">https://blog.csdn.net/jianghuchuang/article/details/141362831</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash	</span><br><span class="line"></span><br><span class="line">#设置脚本执行过程中出现错误就停止</span><br><span class="line">set -euo pipefail</span><br><span class="line"></span><br><span class="line"># root账户执行命令</span><br><span class="line">USER=&quot;root&quot;</span><br><span class="line">#检查是否安装了相关命令</span><br><span class="line">REQUIRE_COMMAND=(docker docker-compose dig nslookup telnet tree)</span><br><span class="line"></span><br><span class="line"># 自定义证书时配置的自定义证书生成路径，如果是已有证书，需要将证书拷贝到 $HARBOR_CERT_DIR 路径下</span><br><span class="line">CUSTOM_CERT_DIR=&quot;/root/cert&quot;</span><br><span class="line"># 配置harbor的访问域名，1、在hulk上解析的 2、自定义时配置host访问</span><br><span class="line">HARBOR_DOMAIN=&quot;test.harbor.com&quot;</span><br><span class="line"></span><br><span class="line"># harbor服务不同系统架构的安装包</span><br><span class="line">HARBOR_X86_VERSION=&quot;https://github.com/goharbor/harbor/releases/download/v2.12.2/&quot;</span><br><span class="line">HARBOR_X86_PACKAGE=&quot;harbor-offline-installer-v2.12.2.tgz&quot;</span><br><span class="line">HARBOR_IMAGE_PACKAGE=&quot;harbor.v2.12.2.tar.gz&quot;</span><br><span class="line"></span><br><span class="line"># 解压安装包的路径</span><br><span class="line">HARBOR_INSTALL_DIR=&quot;/root&quot;</span><br><span class="line"># harbor存放证书及私钥路径</span><br><span class="line">HARBOR_CERT_DIR=&quot;/data/harbor/cert&quot;</span><br><span class="line"># harbor镜像仓库存放地址</span><br><span class="line">DATA_VOLUME=&quot;/data/harbor&quot;</span><br><span class="line"></span><br><span class="line"># 日志文件</span><br><span class="line">LOG_FILE=&quot;harbor.log&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义颜色代码</span><br><span class="line">readonly RED=&#x27;\033[0;31m&#x27;</span><br><span class="line">readonly GREEN=&#x27;\033[0;32m&#x27;</span><br><span class="line">readonly YELLOW=&#x27;\033[0;33m&#x27;</span><br><span class="line">readonly BLUE=&#x27;\033[0;34m&#x27;</span><br><span class="line">readonly NC=&#x27;\033[0m&#x27;</span><br><span class="line"></span><br><span class="line"># 定义日志级别对应的颜色</span><br><span class="line">declare -A LOG_COLORS=(</span><br><span class="line">    [&quot;ERROR&quot;]=&quot;$&#123;RED&#125;&quot;</span><br><span class="line">    [&quot;NOTICE&quot;]=&quot;$&#123;YELLOW&#125;&quot;</span><br><span class="line">    [&quot;INFO&quot;]=&quot;$&#123;BLUE&#125;&quot;</span><br><span class="line">    [&quot;SUCCESS&quot;]=&quot;$&#123;GREEN&#125;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 改进的日志函数</span><br><span class="line">log() &#123;</span><br><span class="line">    local level=$1</span><br><span class="line">    shift</span><br><span class="line">    local color=$&#123;LOG_COLORS[$level]:-$NC&#125;</span><br><span class="line">    local timestamp=$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">    local message=&quot;[$&#123;timestamp&#125;] [$&#123;level&#125;] $*&quot;</span><br><span class="line">    echo -e &quot;$&#123;color&#125;$&#123;message&#125;$&#123;NC&#125;&quot; | tee -a &quot;$LOG_FILE&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#检查操作系统</span><br><span class="line">check_os()</span><br><span class="line">&#123;</span><br><span class="line">	log &quot;INFO&quot; &quot;检查操作系统...&quot;</span><br><span class="line">	OS_ID=$(grep &quot;^ID=&quot; /etc/os-release | cut -d= -f2 | tr -d &#x27;&quot;&#x27;)</span><br><span class="line">	OS_VERSION=$(grep &quot;^VERSION_ID=&quot; /etc/os-release | cut -d= -f2 | tr -d &#x27;&quot;&#x27;)</span><br><span class="line"></span><br><span class="line">	# 判断是否是 Anolis OS 8</span><br><span class="line">	if [[ &quot;$OS_ID&quot; == &quot;anolis&quot; &amp;&amp; &quot;$OS_VERSION&quot; =~ ^8 ]]; then</span><br><span class="line">		log &quot;SUCCESS&quot; &quot;当前系统是 Anolis OS $OS_VERSION，继续执行程序...&quot;</span><br><span class="line">	else</span><br><span class="line">		log &quot;ERROR&quot; &quot;当前系统不是 Anolis OS 8，而是 $OS_ID $OS_VERSION，无法继续执行。&quot;</span><br><span class="line">		exit 1</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#下载离线包内容</span><br><span class="line">download_harbor()</span><br><span class="line">&#123;	</span><br><span class="line">	mkdir -p $HARBOR_INSTALL_DIR</span><br><span class="line">	log &quot;INFO&quot; &quot;开始下载 Harbor 安装包...&quot;</span><br><span class="line">	wget -c  -P $HARBOR_INSTALL_DIR HARBOR_X86_VERSION/$HARBOR_X86_PACKAGE</span><br><span class="line">	log &quot;SUCCESS&quot; &quot;安装包下载完成&quot;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#解压安装包</span><br><span class="line">uncompress_harbor()</span><br><span class="line">&#123;</span><br><span class="line">	log &quot;INFO&quot; &quot;解压安装包...&quot;</span><br><span class="line">	tar -zxvf $HARBOR_INSTALL_DIR/$HARBOR_X86_PACKAGE -C $HARBOR_INSTALL_DIR</span><br><span class="line">	log &quot;SUCCESS&quot; &quot;安装包解压完成&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#加载 Harbor Docker 镜像</span><br><span class="line">load_harbor_image()</span><br><span class="line">&#123;</span><br><span class="line">	log &quot;INFO&quot; &quot;加载 Harbor Docker 镜像...&quot;</span><br><span class="line">	docker load -i $HARBOR_INSTALL_DIR/harbor/$HARBOR_IMAGE_PACKAGE</span><br><span class="line">	log &quot;SUCCESS&quot; &quot;Harbor 安装包处理完成&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#检查安装命令</span><br><span class="line">check_command()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for cmd in &quot;$&#123;REQUIRE_COMMAND[@]&#125;&quot;; do</span><br><span class="line">        if ! command -v &quot;$cmd&quot; &gt; /dev/null 2&gt;&amp;1; then</span><br><span class="line">            log &quot;ERROR&quot; &quot;命令 $cmd 未找到,将进行安装，请保证主机联网：&quot;</span><br><span class="line">			check_os</span><br><span class="line">            case $cmd in</span><br><span class="line">		        docker) </span><br><span class="line">					instal_docker ;;</span><br><span class="line">		        docker-compose) </span><br><span class="line">					install_docker-compose ;;</span><br><span class="line">		        dig|nslookup|telnet) </span><br><span class="line">					install_network_tools ;;</span><br><span class="line">		    esac</span><br><span class="line">        	return 1</span><br><span class="line">        else</span><br><span class="line">            log &quot;SUCCESS&quot; &quot;系统已安装命令 $cmd&quot;</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#安装docker服务</span><br><span class="line">instal_docker()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	log &quot;INFO&quot; &quot;安装yum-utils&quot; </span><br><span class="line">	dnf install -y yum-utils</span><br><span class="line"></span><br><span class="line">	#ECS VPC网络访问地址</span><br><span class="line">	log &quot;INFO&quot; &quot;大陆主机配置docker-ce.repo&quot; </span><br><span class="line">	dnf config-manager --add-repo http://mirrors.cloud.aliyuncs.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">	sed -i &#x27;s/mirrors.aliyun.com/mirrors.cloud.aliyuncs.com/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">	sed -i &#x27;s/https/http/g&#x27; /etc/yum.repos.d/docker-ce.repo	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	log &quot;INFO&quot; &quot;安装docker服务:&quot; </span><br><span class="line">	dnf install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line">	log &quot;SUCCESS&quot; &quot;安装docker服务 OK ！&quot; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	log &quot;INFO&quot; &quot;启动docker服务&quot; </span><br><span class="line">	systemctl start docker &amp;&amp; systemctl enable docker </span><br><span class="line">	log &quot;SUCCESS&quot; &quot;启动docker服务 OK ！&quot; </span><br><span class="line"></span><br><span class="line">	log &quot;INFO&quot; &quot;docker版本&quot; </span><br><span class="line">	docker --version</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_docker-compose()</span><br><span class="line">&#123;</span><br><span class="line">	#下载安装docker-compose</span><br><span class="line">	log &quot;INFO&quot; &quot;从github下载docker-compose二进制文件...&quot;</span><br><span class="line">	wget http://github.com/docker/compose/releases/download/v2.33.0/docker-compose-linux-x86_64</span><br><span class="line">	log &quot;INFO&quot; &quot;移动docker-compose到/usr/local/bin&quot;</span><br><span class="line">	mv docker-compose-linux-x86_64 /usr/local/bin/docker-compose</span><br><span class="line">	chmod +x /usr/local/bin/docker-compose</span><br><span class="line">	log &quot;SUCCESS&quot; &quot;安装docker-compose命令 OK ！&quot;</span><br><span class="line"></span><br><span class="line">	log &quot;INFO&quot; &quot;docker-compose版本&quot;</span><br><span class="line">	docker-compose --version</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#安装网络软件</span><br><span class="line">#阿里云安装包下载地址</span><br><span class="line">#https://mirrors.aliyun.com/anolis/8.2/AppStream/x86_64/os/Packages/</span><br><span class="line">install_network_tools()</span><br><span class="line">&#123;</span><br><span class="line">	log &quot;INFO&quot; &quot;正在安装网络工具：dig、nslookup、telnet、tree...&quot; </span><br><span class="line">	dnf install -y bind-utils</span><br><span class="line">	dnf install -y tree</span><br><span class="line">	wget https://http://mirrors.cloud.aliyuncs.com/anolis/8.2/AppStream/x86_64/os/Packages/telnet-0.17-73.el8.x86_64.rpm</span><br><span class="line">	rpm -ivh ./telnet-0.17-73.el8.x86_64.rpm</span><br><span class="line">	rm -f ./telnet-0.17-73.el8.x86_64.rpm</span><br><span class="line">	log &quot;SUCCESS&quot; &quot;安装网络工具 OK !&quot; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#openssl subj子参数详解</span><br><span class="line">#C 含义:国家名称缩写，英文：Country Name (2 letter code)</span><br><span class="line">#ST 含义:州或省名称，英文：State or Province Name (full name)</span><br><span class="line">#L 含义:城市或区域称，英文：Locality Name (eg, city)</span><br><span class="line">#O 含义:组织名（或公司名），英文：Organization Name (eg, company)</span><br><span class="line">#OU 含义:组织单位名称（或部门名），英文：Organizational Unit Name (eg, section)</span><br><span class="line">#CN 含义:服务器域名/证书拥有者名称，英文：Common Name (e.g. server FQDN or YOUR name)</span><br><span class="line">#emailAddress 含义:邮件地址，英文：Email            </span><br><span class="line"></span><br><span class="line">#自定义证书</span><br><span class="line">custom_certificate()</span><br><span class="line">&#123;</span><br><span class="line">	log &quot;INFO&quot; &quot;开始生成自定义证书...&quot;</span><br><span class="line">	mkdir -p $CUSTOM_CERT_DIR</span><br><span class="line">	cd $CUSTOM_CERT_DIR</span><br><span class="line"></span><br><span class="line">	log &quot;INFO&quot; &quot;生成 CA 私钥...&quot;</span><br><span class="line">	openssl genrsa -out ca.key 4096</span><br><span class="line"></span><br><span class="line">	log &quot;INFO&quot; &quot;生成 CA 证书...&quot;</span><br><span class="line">	openssl req -x509 -new -nodes -sha512 -days 3650 \</span><br><span class="line">	 -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=MyPersonal Root CA&quot; \</span><br><span class="line">	 -key ca.key \</span><br><span class="line">	 -out ca.crt</span><br><span class="line"></span><br><span class="line">	log &quot;INFO&quot; &quot;生成服务器私钥: $&#123;HARBOR_DOMAIN&#125;&quot;</span><br><span class="line">	openssl genrsa -out $HARBOR_DOMAIN.key 4096</span><br><span class="line"></span><br><span class="line">	log &quot;INFO&quot; &quot;生成证书签名请求(CSR)...&quot;</span><br><span class="line">	openssl req -sha512 -new \</span><br><span class="line">	    -subj &quot;/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=$HARBOR_DOMAIN&quot; \</span><br><span class="line">	    -key $HARBOR_DOMAIN.key \</span><br><span class="line">	    -out $HARBOR_DOMAIN.csr</span><br><span class="line"></span><br><span class="line">#创建扩展文件 v3.ext</span><br><span class="line">cat &gt; v3.ext &lt;&lt;-EOF</span><br><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints=CA:FALSE</span><br><span class="line">keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">extendedKeyUsage = serverAuth</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1=$HARBOR_DOMAIN</span><br><span class="line">DNS.2=hostname</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">	log &quot;INFO&quot; &quot;签发服务器证书...&quot;</span><br><span class="line">	openssl x509 -req -sha512 -days 3650 \</span><br><span class="line">	    -extfile v3.ext \</span><br><span class="line">	    -CA ca.crt -CAkey ca.key -CAcreateserial \</span><br><span class="line">	    -in $HARBOR_DOMAIN.csr \</span><br><span class="line">	    -out $HARBOR_DOMAIN.crt</span><br><span class="line"></span><br><span class="line">	log &quot;INFO&quot; &quot;复制证书到 Harbor 证书目录...&quot;</span><br><span class="line">	mkdir -p $HARBOR_CERT_DIR</span><br><span class="line">	cp $HARBOR_DOMAIN.crt $HARBOR_CERT_DIR</span><br><span class="line">	cp $HARBOR_DOMAIN.key $HARBOR_CERT_DIR</span><br><span class="line">	</span><br><span class="line">	log &quot;SUCCESS&quot; &quot;证书配置完成&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">verify_harbor_config() &#123;</span><br><span class="line">	log &quot;INFO&quot; &quot;验证 Harbor 所需配置...&quot;</span><br><span class="line">	harbor_config=&quot;$HARBOR_INSTALL_DIR/harbor/harbor.yml&quot;</span><br><span class="line">	if [ ! -f &quot;$harbor_config&quot; ]; then</span><br><span class="line">		log &quot;ERROR&quot; &quot;未找到 $harbor_config 配置文件, 请编辑 $harbor_config 文件！&quot;</span><br><span class="line">		return 1</span><br><span class="line">	fi</span><br><span class="line">	</span><br><span class="line">	# 验证证书文件</span><br><span class="line">	read -rp &quot;请输入配置证书域名【默认：$&#123;HARBOR_DOMAIN&#125;】: &quot; input_domain</span><br><span class="line">	# 变更全局域名变量</span><br><span class="line">	HARBOR_DOMAIN=$&#123;input_domain:-$HARBOR_DOMAIN&#125;</span><br><span class="line">	log &quot;INFO&quot; &quot;当前配置域名为：$HARBOR_DOMAIN &quot;</span><br><span class="line">	log &quot;NOTICE&quot; &quot;$&#123;HARBOR_CERT_DIR&#125;下证书及私钥文件:&quot;</span><br><span class="line">	if [ ! -f &quot;$&#123;HARBOR_CERT_DIR&#125;/$&#123;HARBOR_DOMAIN&#125;.crt&quot; ] || [ ! -f &quot;$&#123;HARBOR_CERT_DIR&#125;/$&#123;HARBOR_DOMAIN&#125;.key&quot; ]; then</span><br><span class="line">		log &quot;ERROR&quot; &quot;对应证书或私钥文件不存在！&quot;</span><br><span class="line">		return 1</span><br><span class="line">	else</span><br><span class="line">		tree $&#123;HARBOR_CERT_DIR&#125;</span><br><span class="line">		log &quot;SUCCESS&quot; &quot;$&#123;HARBOR_CERT_DIR&#125;下证书及私钥文件已存在!&quot;</span><br><span class="line">	fi</span><br><span class="line">	</span><br><span class="line">	log &quot;NOTICE&quot; &quot;查看 $harbor_config 配置内容，执行命令: \ncat $harbor_config | grep -E &#x27;hostname|certificate|private_key|password|harbor_admin_password|data_volume&#x27; | grep -v &#x27;#&#x27;&quot;</span><br><span class="line">	cat $harbor_config | grep -E &quot;hostname|certificate|private_key|password|harbor_admin_password|data_volume&quot; | grep -v &quot;#&quot;</span><br><span class="line">	</span><br><span class="line">	read -rp &quot;是否要编辑$harbor_config配置？[y/n]: &quot; answer</span><br><span class="line">	if [[ $answer == &quot;y&quot; ]]; then</span><br><span class="line">		config_harbor_yml $harbor_config</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	log &quot;SUCCESS&quot; &quot;Harbor 服务所需文件均已存在&quot;</span><br><span class="line">	return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#启动服务</span><br><span class="line">start_harbor()</span><br><span class="line">&#123;</span><br><span class="line">	log &quot;INFO&quot; &quot;验证 Harbor 配置...&quot;</span><br><span class="line">	if ! verify_harbor_config; then</span><br><span class="line">		log &quot;ERROR&quot; &quot;Harbor 配置验证失败,请查看日志说明！&quot;</span><br><span class="line">		return 1</span><br><span class="line">	fi</span><br><span class="line">	</span><br><span class="line">	read -rp &quot;是否确认启动harbor？[y/n]: &quot; answer</span><br><span class="line">	if [[ $answer != &quot;y&quot; ]]; then</span><br><span class="line">		log &quot;INFO&quot; &quot;退出程序！&quot;</span><br><span class="line">		exit</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">		# 验证必要端口</span><br><span class="line">	if ! netstat -tuln | grep -q &quot;:443&quot;; then</span><br><span class="line">		log &quot;INFO&quot; &quot;443 端口未被占用，可以继续安装&quot;</span><br><span class="line">	else</span><br><span class="line">		log &quot;ERROR&quot; &quot;443 端口已被占用，请检查并释放端口&quot;</span><br><span class="line">		return 1</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	log &quot;INFO&quot; &quot;执行 Harbor 准备脚本...&quot;</span><br><span class="line">	$HARBOR_INSTALL_DIR/harbor/prepare</span><br><span class="line">	</span><br><span class="line">	log &quot;INFO&quot; &quot;启动 Harbor 容器服务...&quot;</span><br><span class="line">	if docker-compose -f &quot;$HARBOR_INSTALL_DIR/harbor/docker-compose.yml&quot; up -d ; then</span><br><span class="line">		log &quot;SUCCESS&quot; &quot;Harbor 服务启动成功&quot;</span><br><span class="line">		log &quot;INFO&quot; &quot;请使用以下地址访问 Harbor: https://$&#123;HARBOR_DOMAIN&#125;&quot;</span><br><span class="line">	else</span><br><span class="line">		log &quot;ERROR&quot; &quot;Harbor 服务启动失败&quot;</span><br><span class="line">		return 1</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config_harbor_yml()</span><br><span class="line">&#123;</span><br><span class="line">	# 定义变量</span><br><span class="line">	NEW_CERT=&quot;$HARBOR_CERT_DIR/$HARBOR_DOMAIN.crt&quot;</span><br><span class="line">	NEW_KEY=&quot;$HARBOR_CERT_DIR/$HARBOR_DOMAIN.key&quot;</span><br><span class="line"></span><br><span class="line">	mkdir -p $DATA_VOLUME</span><br><span class="line">	log &quot;NOTICE&quot; &quot;编辑 $1 配置... &quot;</span><br><span class="line">	# 进行替换</span><br><span class="line">	sed -i -e &quot;s|^hostname: .*|hostname: $HARBOR_DOMAIN|&quot; \</span><br><span class="line">		-e &quot;s|  certificate: .*|  certificate: $NEW_CERT|&quot; \</span><br><span class="line">		-e &quot;s|  private_key: .*|  private_key: $NEW_KEY|&quot; \</span><br><span class="line">		-e &quot;s|^data_volume: .*|data_volume: $DATA_VOLUME|&quot; &quot;$1&quot;</span><br><span class="line">	</span><br><span class="line">	log &quot;SUCCESS&quot; &quot;配置 $1 文件OK，当前配置为： &quot;</span><br><span class="line">	cat $1 | grep -E &quot;hostname|certificate|private_key|password|harbor_admin_password|data_volume&quot; | grep -v &quot;#&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop_harbor()</span><br><span class="line">&#123;</span><br><span class="line">	log &quot;INFO&quot; &#x27;docker-compose -f &quot;$HARBOR_INSTALL_DIR/harbor/docker-compose.yml&quot; down&#x27;</span><br><span class="line">	docker-compose -f &quot;$HARBOR_INSTALL_DIR/harbor/docker-compose.yml&quot; down</span><br><span class="line">	log &quot;SUCCESS&quot; &quot;Harbor 服务已停止并删除！&quot;</span><br><span class="line">	return 1</span><br><span class="line">&#125;</span><br><span class="line"># 显示菜单</span><br><span class="line">show_menu() &#123;</span><br><span class="line">    local options=(</span><br><span class="line">		&quot;查看必要的软件包&quot;</span><br><span class="line">        &quot;下载harbor安装包&quot;</span><br><span class="line">        &quot;解压harbor安装包&quot;	</span><br><span class="line">        &quot;加载harbor镜像&quot;	</span><br><span class="line">        &quot;配置自定义域名&quot;</span><br><span class="line">        &quot;启动harbor服务&quot;</span><br><span class="line">        &quot;停止并删除harbor服务&quot;</span><br><span class="line">        &quot;退出&quot;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    echo -e &quot;\n$&#123;BLUE&#125;请选择要执行的操作：$&#123;NC&#125;&quot;</span><br><span class="line">    for i in &quot;$&#123;!options[@]&#125;&quot;; do</span><br><span class="line">        echo &quot;$((i+1)). $&#123;options[i]&#125;&quot;</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    read -rp &quot;请输入选项 [1-$&#123;#options[@]&#125;]: &quot; choice</span><br><span class="line"></span><br><span class="line">    case $choice in</span><br><span class="line">		1)</span><br><span class="line">			check_command ;;</span><br><span class="line">        2) </span><br><span class="line">			download_harbor ;;</span><br><span class="line">		3) </span><br><span class="line">			uncompress_harbor ;;</span><br><span class="line">		4)</span><br><span class="line">			load_harbor_image ;;</span><br><span class="line">        5) </span><br><span class="line">			read -rp &quot;配置自定义域名[默认：$HARBOR_DOMAIN]: &quot; input_domain</span><br><span class="line">			HARBOR_DOMAIN=$&#123;input_domain:-$HARBOR_DOMAIN&#125;</span><br><span class="line">			custom_certificate ;;</span><br><span class="line">        6) start_harbor ;;</span><br><span class="line">        7) stop_harbor ;;</span><br><span class="line">        8) exit 0 ;;</span><br><span class="line">        *) log &quot;ERROR&quot; &quot;无效选择&quot; ;;</span><br><span class="line">    esac</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 显示系统信息</span><br><span class="line">hostinfo() &#123;</span><br><span class="line">    log &quot;INFO&quot; &quot;系统信息:&quot;</span><br><span class="line">    log &quot;INFO&quot; &quot;- 用户: $(whoami)&quot;</span><br><span class="line">    log &quot;INFO&quot; &quot;- 主机名: $(hostname)&quot;</span><br><span class="line">    log &quot;INFO&quot; &quot;- 操作系统: $(cat /etc/redhat-release)&quot;</span><br><span class="line">    log &quot;INFO&quot; &quot;- 操作内核: $(uname -r)&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 检查用户权限</span><br><span class="line">check_user() &#123;</span><br><span class="line">    if [[ $(whoami) != &quot;$&#123;USER&#125;&quot; ]]; then</span><br><span class="line">        log &quot;ERROR&quot; &quot;当前用户为: $(whoami), 请切换至 $&#123;USER&#125; 账户操作!&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 主函数</span><br><span class="line">main() &#123;</span><br><span class="line">	# 检查用户</span><br><span class="line">    check_user</span><br><span class="line">	# 检查系统信息</span><br><span class="line">    hostinfo</span><br><span class="line">    # 创建日志文件</span><br><span class="line">    touch &quot;$LOG_FILE&quot;</span><br><span class="line"></span><br><span class="line">    while true; do</span><br><span class="line">        show_menu</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main &quot;$@&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>混合云架构示意图</title>
    <url>/2025/03/10/%E6%B7%B7%E5%90%88%E4%BA%91%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="阿里混合云架构"><a href="#阿里混合云架构" class="headerlink" title="阿里混合云架构"></a>阿里混合云架构</h2><ul>
<li>大陆架构1<br><img src="https://raw.githubusercontent.com/shispring/picgo/master/p56761.png" alt="大陆" title="大陆"></li>
</ul>
<hr>
<ul>
<li>大陆架构2<br><img src="https://raw.githubusercontent.com/shispring/picgo/master/p142282.png" alt="大陆2" title="大陆2"></li>
</ul>
<hr>
<ul>
<li>全球架构<br><img src="https://raw.githubusercontent.com/shispring/picgo/master/onwbejlswgnv4_20240422_7402cd3196f34eb58eceaf87a6e60e2a.png" alt="全球" title="全球"></li>
</ul>
]]></content>
      <tags>
        <tag>cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>sublime tips</title>
    <url>/2025/03/17/sublime-tips/</url>
    <content><![CDATA[<h2 id="subline-去重"><a href="#subline-去重" class="headerlink" title="subline 去重"></a>subline 去重</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1、排序</span><br><span class="line">edit-&gt; sort lines</span><br><span class="line">#2、正则替换</span><br><span class="line">find行：^(.+)$[\r\n](^\1$[\r\n]&#123;0, 1&#125;)+</span><br><span class="line">replace行：\1\n</span><br></pre></td></tr></table></figure>

<h2 id="反选不包含http的行"><a href="#反选不包含http的行" class="headerlink" title="反选不包含http的行"></a>反选不包含http的行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find行：^((?!http).)*$</span><br><span class="line">或者</span><br><span class="line">find行：^(?!.*http).+</span><br><span class="line">replace：留空</span><br></pre></td></tr></table></figure>

<h2 id="去除空行"><a href="#去除空行" class="headerlink" title="去除空行"></a>去除空行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find配置：\s+$</span><br><span class="line">replace：留空</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>rancher安装k8s</title>
    <url>/2025/03/17/rancher%E5%AE%89%E8%A3%85k8s/</url>
    <content><![CDATA[<h2 id="部署k8s"><a href="#部署k8s" class="headerlink" title="部署k8s"></a>部署k8s</h2><blockquote>
<p>参考：<br><a href="https://blog.csdn.net/kanganrui/category_12287775.html">https://blog.csdn.net/kanganrui/category_12287775.html</a><br><a href="https://www.elisky.cn/p/rancher-dep/">https://www.elisky.cn/p/rancher-dep/</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#注意：Rancher 依赖于 iptables 进行网络流量管理和路由控制</span><br><span class="line">#如果宿主机未加载 ip_tables 模块，Rancher 将无法正常配置网络规则，导致启动失败。</span><br><span class="line"></span><br><span class="line">sudo modprobe ip_tables &amp;&amp; sudo echo &#x27;ip_tables&#x27; &gt;&gt; /etc/modules</span><br><span class="line"></span><br><span class="line">#使用docker启动rancher</span><br><span class="line">docker run -d --restart=unless-stopped \</span><br><span class="line">  -p 80:80 -p 443:443 \</span><br><span class="line">  --privileged \</span><br><span class="line">  rancher/rancher:latest</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>skaffold应用</title>
    <url>/2025/03/19/skaffold%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Skaffold"><a href="#Skaffold" class="headerlink" title="Skaffold"></a>Skaffold</h1><p><a href="https://skaffold.dev/">Skaffold</a> 是谷歌开源的应用开发神器。它的特点：</p>
<ul>
<li>没有服务器端组件，所以不会增加你的集群开销</li>
<li>自动检测源代码中的更改并自动构建&#x2F;推送&#x2F;部署</li>
<li>自动更新镜像<strong>TAG</strong>，不要担心手动去更改<code>kubernetes</code>的 manifest 文件</li>
<li>一次性构建&#x2F;部署&#x2F;上传不同的应用，因此它对于微服务同样完美适配</li>
<li>支持开发环境和生产环境，通过仅一次运行manifest，或者持续观察变更</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载最新的<code>Linux</code>版本，请运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-linux-amd64 &amp;&amp; <span class="built_in">chmod</span> +x skaffold &amp;&amp; <span class="built_in">sudo</span> <span class="built_in">mv</span> skaffold /usr/local/bin</span></span><br></pre></td></tr></table></figure>

<p>下载最新的<code>OSX</code>版本，请运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/latest/skaffold-darwin-amd64 &amp;&amp; <span class="built_in">chmod</span> +x skaffold &amp;&amp; <span class="built_in">sudo</span> <span class="built_in">mv</span> skaffold /usr/local/bin</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/GoogleCloudPlatform/skaffold</span><br></pre></td></tr></table></figure>
<p>example例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── k8s-pod.yaml</span><br><span class="line">├── main.go</span><br><span class="line">├── skaffold-gcb.yaml</span><br><span class="line">└── skaffold.yaml</span><br></pre></td></tr></table></figure>
<p>注意修改镜像仓库地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜ getting-started git:(main) cat Dockerfile | grep FROM</span><br><span class="line">FROM swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/library/golang:1.22.5 as builder</span><br><span class="line">FROM swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/loads/alpine:3.8</span><br><span class="line">➜ getting-started git:(main) cat skaffold.yaml</span><br><span class="line">apiVersion: skaffold/v4beta12</span><br><span class="line">kind: Config</span><br><span class="line">build:</span><br><span class="line">  artifacts:</span><br><span class="line">  - image: harbor.xxx.net/test/skaffold-example</span><br><span class="line">manifests:</span><br><span class="line">  rawYaml:</span><br><span class="line">  - k8s-pod.yaml</span><br><span class="line">➜ getting-started git:(main) cat k8s-pod.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: getting-started</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: getting-started</span><br><span class="line">    image: harbor.xxx.net/test/skaffold-example</span><br></pre></td></tr></table></figure>
<p>然后在<code>getting-started</code>目录下面执行<code>skaffold dev</code>命令就可以了，剩下的skaffold给你全部搞定</p>
<blockquote>
<p>注意要docker login你的镜像仓库地址<br>docker login -u test -p xxx harbor.xxx.net</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ getting-started git:(main) skaffold dev</span><br><span class="line">Generating tags...</span><br><span class="line"> - harbor.xxx.net/test/skaffold-example -&gt; harbor.xxx.net/test/skaffold-example:v2.14.0-35-gd5f6acc67-dirty</span><br><span class="line">Checking cache...</span><br><span class="line"> - harbor.xxx.net/test/skaffold-example: Found Remotely</span><br><span class="line">Tags used <span class="keyword">in</span> deployment:</span><br><span class="line"> - harbor.xxx.net/test/skaffold-example -&gt; harbor.xxx.net/test/skaffold-example:v2.14.0-35-gd5f6acc67-dirty@sha256:bb43dedc28353679a67e8697558460ebd031a601b102534fe2018c82c8ecd29d</span><br><span class="line">Starting deploy...</span><br><span class="line"> - pod/getting-started created</span><br><span class="line">Waiting <span class="keyword">for</span> deployments to stabilize...</span><br><span class="line"> - pods: creating container getting-started</span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl get po</span></span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">······</span><br><span class="line">getting-started           1/1     Running   0          9m3s</span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl logs getting-started</span></span><br><span class="line">Hello world!</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure>

<p>可以得知<code>Skaffold</code>已经帮我们做了很多事情了：</p>
<ul>
<li>用本地源代码构建 Docker 镜像</li>
<li>用它的<code>sha256</code>值作为镜像的标签</li>
<li>设置<code>skaffold.yaml</code>文件中定义的 kubernetes manifests 的镜像地址</li>
<li>用<code>kubectl apply -f</code>命令来部署 kubernetes 应用，然后把pod输出显示回来</li>
</ul>
<h2 id="结束调试"><a href="#结束调试" class="headerlink" title="结束调试"></a>结束调试</h2><p>调试模式下直接 <code>ctrl + c</code>， 会自动删除部署在集群内的资源，pod那些会删除掉，很方便</p>
<h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><p>对于应用本身的管理以及全套流程的打通，其实有很多路子，我个人觉得skaffold的价值最大就是减少了很多繁琐的调试步骤，不过我们也来看看它还有哪些功能，下面只简单介绍下，具体可以看官方文档</p>
<ul>
<li>本身有三种模式，<code>run</code>、<code>dev</code>、<code>debug</code>： run模式不会热更新镜像，debug模式和dev很像，但是debug模式禁用了重新构建镜像和sync功能</li>
<li>支持其他镜像构建软件</li>
<li>镜像tag也支持多种模式：gitCommit ID、日期时间、sha256</li>
<li>也可以对接helm</li>
<li>sync功能：dev模式下可以在某些文件发生改变时，直接将文件复制到容器内，从而省掉制作镜像的步骤，提供效率。这对于静态文件来说，非常有用</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://github.com/chenzongshu/Kubernetes/blob/master/k8s%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%A5%9E%E5%99%A8.md">https://github.com/chenzongshu/Kubernetes/blob/master/k8s%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%A5%9E%E5%99%A8.md</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>docker mainfest 使用</title>
    <url>/2025/03/19/docker-mainfest/</url>
    <content><![CDATA[<h3 id="1-什么是-docker-manifest？"><a href="#1-什么是-docker-manifest？" class="headerlink" title="1. 什么是 docker manifest？"></a><strong>1. 什么是 <code>docker manifest</code>？</strong></h3><p><code>docker manifest</code> 是 <strong>Docker 多架构镜像（Multi-Arch Images）</strong> 的一种机制，允许 <strong>同一个镜像名称（Tag）对应多个不同架构的镜像</strong>（如 <code>amd64</code>、<code>arm64</code>、<code>ppc64le</code> 等）。</p>
<ul>
<li><strong>作用</strong>：  <ul>
<li>让 <code>docker pull my-image:latest</code> <strong>自动选择适合当前系统架构的镜像</strong>。</li>
<li>避免用户手动指定架构（如 <code>my-image:amd64</code> 或 <code>my-image:arm64</code>）。</li>
<li>适用于 <code>Harbor</code>、<code>Docker Hub</code>、<code>quay.io</code> 等容器镜像仓库。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-docker-manifest-的使用方法"><a href="#2-docker-manifest-的使用方法" class="headerlink" title="2. docker manifest 的使用方法"></a><strong>2. <code>docker manifest</code> 的使用方法</strong></h3><h4 id="（1）创建多架构镜像"><a href="#（1）创建多架构镜像" class="headerlink" title="（1）创建多架构镜像"></a><strong>（1）创建多架构镜像</strong></h4><p>假设我们已经构建了两个不同架构的镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker buildx build --platform linux/amd64 -t myrepo/myimage:amd64 --push .</span><br><span class="line">docker buildx build --platform linux/arm64 -t myrepo/myimage:arm64 --push .</span><br></pre></td></tr></table></figure>
<p>此时，Harbor 上分别有：</p>
<ul>
<li><code>myrepo/myimage:amd64</code></li>
<li><code>myrepo/myimage:arm64</code></li>
</ul>
<h4 id="（2）创建-Manifest-List"><a href="#（2）创建-Manifest-List" class="headerlink" title="（2）创建 Manifest List"></a><strong>（2）创建 Manifest List</strong></h4><p>使用 <code>docker manifest create --insecure </code> 命令，将不同架构的镜像组合成一个 <code>manifest</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker manifest create  --insecure myrepo/myimage:latest \</span><br><span class="line">  myrepo/myimage:amd64 \</span><br><span class="line">  myrepo/myimage:arm64</span><br></pre></td></tr></table></figure>

<h4 id="（3）标注架构"><a href="#（3）标注架构" class="headerlink" title="（3）标注架构"></a><strong>（3）标注架构</strong></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker manifest annotate myrepo/myimage:latest myrepo/myimage:amd64 --<span class="built_in">arch</span> amd64</span><br><span class="line">docker manifest annotate myrepo/myimage:latest myrepo/myimage:arm64 --<span class="built_in">arch</span> arm64</span><br></pre></td></tr></table></figure>

<h4 id="（4）推送到-Harbor"><a href="#（4）推送到-Harbor" class="headerlink" title="（4）推送到 Harbor"></a><strong>（4）推送到 Harbor</strong></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker manifest push myrepo/myimage:latest</span><br></pre></td></tr></table></figure>
<p>此时，Harbor 就会存储 <code>myrepo/myimage:latest</code> 这个 <strong>多架构镜像</strong>。</p>
<hr>
<h3 id="3-docker-pull-如何选择合适的架构？"><a href="#3-docker-pull-如何选择合适的架构？" class="headerlink" title="3. docker pull 如何选择合适的架构？"></a><strong>3. <code>docker pull</code> 如何选择合适的架构？</strong></h3><p>当你执行 <code>docker pull myrepo/myimage:latest</code> 时：</p>
<ol>
<li>Docker 客户端 <strong>查询远程仓库</strong>，获取 <code>manifest list</code>（即不同架构的索引）。</li>
<li>Docker 客户端 <strong>检测本机架构</strong>：<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -m  <span class="comment"># 获取当前架构</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>x86_64</code> → 拉取 <code>amd64</code> 版本</li>
<li><code>aarch64</code> → 拉取 <code>arm64</code> 版本</li>
</ul>
</li>
<li>Docker 根据架构 <strong>自动拉取对应的镜像层（layers）</strong>。</li>
</ol>
<hr>
<h3 id="4-如何在-Harbor-中使用-docker-manifest"><a href="#4-如何在-Harbor-中使用-docker-manifest" class="headerlink" title="4. 如何在 Harbor 中使用 docker manifest"></a><strong>4. 如何在 Harbor 中使用 <code>docker manifest</code></strong></h3><p>Harbor <strong>完全支持多架构镜像</strong>，你可以在 Harbor 的 Web UI 看到：</p>
<ul>
<li><code>myimage:latest</code>（<code>manifest list</code>）</li>
<li>关联的 <code>amd64</code>、<code>arm64</code> 具体镜像</li>
</ul>
<p>如果要手动管理 <code>manifest</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker login harbor.example.com</span><br><span class="line">docker manifest create harbor.example.com/myrepo/myimage:latest \</span><br><span class="line">  harbor.example.com/myrepo/myimage:amd64 \</span><br><span class="line">  harbor.example.com/myrepo/myimage:arm64</span><br><span class="line">docker manifest push harbor.example.com/myrepo/myimage:latest</span><br></pre></td></tr></table></figure>

<p><strong>Harbor 7.x 及以上版本</strong> 也可以在 Web 界面直接管理 <code>manifest</code>，查看不同架构的 Tag。</p>
<hr>
<h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a><strong>5. 结论</strong></h3><table>
<thead>
<tr>
<th>问题</th>
<th>解答</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>docker manifest</code> 作用</strong></td>
<td>支持多架构镜像，自动匹配 <code>amd64</code>、<code>arm64</code></td>
</tr>
<tr>
<td><strong>Docker 何时判断架构</strong></td>
<td><code>docker pull</code> 时会解析 <code>manifest list</code>，然后根据本机架构拉取对应版本</td>
</tr>
<tr>
<td><strong>Harbor 是否支持</strong></td>
<td><strong>支持</strong>，可以 <code>docker manifest push</code> 或在 Web 界面查看</td>
</tr>
<tr>
<td><strong>如何在 Harbor 配置</strong></td>
<td><strong>构建不同架构的镜像</strong> → <strong>创建 manifest</strong> → <strong>push 到 Harbor</strong></td>
</tr>
</tbody></table>
<p>你可以先尝试 <strong><code>docker manifest inspect &lt;镜像&gt;</code></strong> 查看 Harbor 上是否已有 <code>manifest</code>，然后尝试 <code>docker pull</code> 来验证是否能正确拉取适配架构的镜像。</p>
<h2 id="如何使用docker拉取指定架构镜像"><a href="#如何使用docker拉取指定架构镜像" class="headerlink" title="如何使用docker拉取指定架构镜像"></a>如何使用docker拉取指定架构镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启实验功能</span></span><br><span class="line"><span class="comment">#1 修改/etc/docker/daemon.json</span></span><br><span class="line">添加 <span class="string">&quot;experimental&quot;</span>: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#验证</span></span><br><span class="line">docker version | grep Experimental</span><br><span class="line"></span><br><span class="line"><span class="comment">#2 拉取指定架构</span></span><br><span class="line">docker pull --platform=arm64 xxx</span><br><span class="line">or</span><br><span class="line">docker pull --platform=amd64 xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证架构</span></span><br><span class="line">docker inspect &lt;image_name&gt; | grep Architecture</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>事物&amp;认知&amp;思维方法论</title>
    <url>/2025/03/24/%E4%BA%8B%E7%89%A9-%E8%AE%A4%E7%9F%A5-%E6%80%9D%E7%BB%B4%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="1-事物的对立性分类"><a href="#1-事物的对立性分类" class="headerlink" title="1. 事物的对立性分类"></a><strong>1. 事物的对立性分类</strong></h2><table>
<thead>
<tr>
<th><strong>对立维度</strong></th>
<th><strong>分类1</strong></th>
<th><strong>分类2</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>存在形式</strong></td>
<td>物质（Matter）</td>
<td>能量（Energy）</td>
<td>物理世界中，物质和能量的对立统一</td>
</tr>
<tr>
<td><strong>抽象层次</strong></td>
<td>具象（Concrete）</td>
<td>抽象（Abstract）</td>
<td>具象是可直接感知的，抽象则需要概念化</td>
</tr>
<tr>
<td><strong>描述方式</strong></td>
<td>结构（Structure）</td>
<td>过程（Process）</td>
<td>结构关注静态关系，过程关注动态演化</td>
</tr>
<tr>
<td><strong>思维方式</strong></td>
<td>直觉（Intuition）</td>
<td>逻辑（Logic）</td>
<td>直觉是一种快速、经验性的认知，逻辑基于推理</td>
</tr>
<tr>
<td><strong>运动状态</strong></td>
<td>静态（Static）</td>
<td>动态（Dynamic）</td>
<td>事物在时间维度上的存在状态</td>
</tr>
<tr>
<td><strong>组织层级</strong></td>
<td>局部（Local）</td>
<td>整体（Global）</td>
<td>个体与系统的对立统一</td>
</tr>
<tr>
<td><strong>发展方向</strong></td>
<td>简单（Simple）</td>
<td>复杂（Complex）</td>
<td>事物的演化可以是由简入繁，也可以是由繁入简</td>
</tr>
<tr>
<td><strong>观测角度</strong></td>
<td>客观（Objective）</td>
<td>主观（Subjective）</td>
<td>事物可以从客观的事实描述，也可以从主观的体验理解</td>
</tr>
</tbody></table>
<p>这些对立性并不是绝对的，而是互相依存、动态转换的。例如，物质可以转化为能量，静态结构可以变成动态过程，整体由局部组成但又具有新的 emergent properties（涌现特性）。</p>
<hr>
<h2 id="2-认识事物本质的方法论"><a href="#2-认识事物本质的方法论" class="headerlink" title="2. 认识事物本质的方法论"></a><strong>2. 认识事物本质的方法论</strong></h2><p>不同的研究方法适用于不同类型的事物，以下是一些常见的认知方法论：</p>
<table>
<thead>
<tr>
<th><strong>方法论</strong></th>
<th><strong>描述</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>归纳法（Inductive Reasoning）</strong></td>
<td>通过观察个别事例，总结一般性规律</td>
<td>经验科学、机器学习</td>
</tr>
<tr>
<td><strong>演绎法（Deductive Reasoning）</strong></td>
<td>通过已知的普遍原理，推导具体结论</td>
<td>数学、形式逻辑</td>
</tr>
<tr>
<td><strong>还原论（Reductionism）</strong></td>
<td>把复杂系统拆解为更基本的部分进行研究</td>
<td>物理学、生物学</td>
</tr>
<tr>
<td><strong>整体论（Holism）</strong></td>
<td>关注系统整体的性质和交互关系</td>
<td>生态学、社会科学</td>
</tr>
<tr>
<td><strong>系统思维（Systems Thinking）</strong></td>
<td>研究事物的结构、功能及其相互作用</td>
<td>复杂系统、企业管理</td>
</tr>
<tr>
<td><strong>对立统一法（Dialectics）</strong></td>
<td>通过矛盾分析事物的本质和发展</td>
<td>哲学、社会学</td>
</tr>
<tr>
<td><strong>第一性原理（First Principles Thinking）</strong></td>
<td>追溯事物最基本的物理、数学或逻辑定律</td>
<td>创新、科技研发</td>
</tr>
<tr>
<td><strong>抽象与具象转换（Abstraction &amp; Concretization）</strong></td>
<td>通过抽象化简事物，再还原到现实应用</td>
<td>计算机科学、数学建模</td>
</tr>
<tr>
<td><strong>层次分析法（Top-down &amp; Bottom-up）</strong></td>
<td>自上而下（从整体到局部）、自下而上（从局部到整体）分析问题</td>
<td>组织架构设计、问题求解</td>
</tr>
<tr>
<td><strong>涌现分析（Emergent Analysis）</strong></td>
<td>研究复杂系统中整体属性如何由局部交互产生</td>
<td>人工智能、生命科学</td>
</tr>
<tr>
<td><strong>黑箱思维（Black Box Thinking）</strong></td>
<td>关注输入输出，而不研究内部机制</td>
<td>工程学、人工智能</td>
</tr>
<tr>
<td><strong>白箱思维（White Box Thinking）</strong></td>
<td>研究内部结构和机制，以理解其运行方式</td>
<td>物理学、软件开发</td>
</tr>
</tbody></table>
<hr>
<p>应试导向让很多人习惯了“标准答案”，缺乏系统性、灵活性、创造性的思维模式。为了长期提升思维能力，可以从以下几个方面进行系统训练：</p>
<h2 id="长期思维培养方案"><a href="#长期思维培养方案" class="headerlink" title="长期思维培养方案"></a><strong>长期思维培养方案</strong></h2><h3 id="1-建立多元化思维模型"><a href="#1-建立多元化思维模型" class="headerlink" title="1. 建立多元化思维模型"></a><strong>1. 建立多元化思维模型</strong></h3><p>人的认知受限于经验和知识框架，要突破局限，就要有多种思维模型。这包括但不限于：</p>
<table>
<thead>
<tr>
<th><strong>思维模型</strong></th>
<th><strong>核心特点</strong></th>
<th><strong>代表书籍 &#x2F; 训练方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>第一性原理（First Principles Thinking）</strong></td>
<td>追溯事物的最基本原理，避免因循守旧</td>
<td>埃隆·马斯克的创新方法，《物理学的基本原理》</td>
</tr>
<tr>
<td><strong>系统思维（Systems Thinking）</strong></td>
<td>关注事物的整体结构、交互关系</td>
<td>《第五项修炼》《系统思考》</td>
</tr>
<tr>
<td><strong>逆向思维（Inversion Thinking）</strong></td>
<td>从反面思考问题，预防风险</td>
<td>查理·芒格的投资哲学</td>
</tr>
<tr>
<td><strong>概率与统计思维（Probabilistic Thinking）</strong></td>
<td>认识不确定性，避免确定性偏差</td>
<td>《黑天鹅》《随机漫步的傻瓜》</td>
</tr>
<tr>
<td><strong>博弈论（Game Theory）</strong></td>
<td>理解人与人之间的策略互动</td>
<td>《博弈论与经济行为》</td>
</tr>
<tr>
<td><strong>计算思维（Computational Thinking）</strong></td>
<td>用算法、建模、抽象的方法解决问题</td>
<td>《算法之美》</td>
</tr>
<tr>
<td><strong>历史视角（Historical Thinking）</strong></td>
<td>从历史趋势预测未来，避免短视</td>
<td>《枪炮、病菌与钢铁》《人类简史》</td>
</tr>
</tbody></table>
<p>📌 <strong>实践方法</strong>：</p>
<ul>
<li>每月聚焦一个新的思维模型，尝试在日常决策、学习或工作中使用它。</li>
<li>记录不同思维模型的应用案例，形成自己的<strong>思维工具箱</strong>。</li>
</ul>
<hr>
<h3 id="2-训练认知弹性"><a href="#2-训练认知弹性" class="headerlink" title="2. 训练认知弹性"></a><strong>2. 训练认知弹性</strong></h3><p>思维的灵活性可以通过以下方式提升：</p>
<table>
<thead>
<tr>
<th><strong>训练方法</strong></th>
<th><strong>具体实践</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>提问式思考（Socratic Questioning）</strong></td>
<td>多问“为什么？”“有没有别的可能？”</td>
</tr>
<tr>
<td><strong>多视角分析（Multiple Perspectives）</strong></td>
<td>读不同立场的书籍，练习换位思考</td>
</tr>
<tr>
<td><strong>跨学科学习（Interdisciplinary Learning）</strong></td>
<td>结合数学、哲学、历史、心理学等多个领域</td>
</tr>
<tr>
<td><strong>写作训练（Writing to Think）</strong></td>
<td>通过写作理清复杂问题，如写长推文、博客</td>
</tr>
<tr>
<td><strong>冥想与深度思考</strong></td>
<td>训练自己的专注力，避免碎片化思维</td>
</tr>
</tbody></table>
<p>📌 <strong>实践方法</strong>：</p>
<ul>
<li>每周选择一个观点，主动找不同角度的论据去反驳自己。</li>
<li>练习写 <strong>“我对 X 事物的 3 个不同看法”</strong>。</li>
<li>关注跨学科内容，如科技、经济、哲学等，训练自己在不同领域间建立联系。</li>
</ul>
<hr>
<h3 id="3-习惯结构化思维"><a href="#3-习惯结构化思维" class="headerlink" title="3. 习惯结构化思维"></a><strong>3. 习惯结构化思维</strong></h3><p>许多人思维混乱，难以表达，最好的训练方式是<strong>结构化表达</strong>：</p>
<table>
<thead>
<tr>
<th><strong>思维方式</strong></th>
<th><strong>特点</strong></th>
<th><strong>实践方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>金字塔原理（Pyramid Principle）</strong></td>
<td>结论先行，层次清晰</td>
<td>用“总-分”结构表达观点</td>
</tr>
<tr>
<td><strong>MECE 原则（Mutually Exclusive, Collectively Exhaustive）</strong></td>
<td>不重不漏，全面分析问题</td>
<td>练习用框架拆解问题（如 2×2 矩阵）</td>
</tr>
<tr>
<td><strong>5W1H 分析法</strong></td>
<td>通过6个基本问题深度思考</td>
<td>训练问题拆解能力</td>
</tr>
</tbody></table>
<p>📌 <strong>实践方法</strong>：</p>
<ul>
<li>每天总结当天的学习或工作，尝试用<strong>金字塔原理</strong>归纳核心信息。</li>
<li>解决问题前，先画出<strong>思维导图</strong>，用 MECE 方法拆解。</li>
</ul>
<hr>
<h3 id="4-设定长期成长路径"><a href="#4-设定长期成长路径" class="headerlink" title="4. 设定长期成长路径"></a><strong>4. 设定长期成长路径</strong></h3><p>长期培养思维能力，需要系统规划：</p>
<table>
<thead>
<tr>
<th><strong>阶段</strong></th>
<th><strong>核心目标</strong></th>
<th><strong>关键训练</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1-3 个月（基础阶段）</strong></td>
<td>打破旧思维模式，建立新框架</td>
<td>了解 10 种以上思维模型，开始结构化表达</td>
</tr>
<tr>
<td><strong>4-6 个月（强化阶段）</strong></td>
<td>灵活运用不同思维模式</td>
<td>用新思维模式解决现实问题</td>
</tr>
<tr>
<td><strong>6-12 个月（应用阶段）</strong></td>
<td>形成个人的独立认知体系</td>
<td>写文章&#x2F;做分享，挑战复杂问题</td>
</tr>
<tr>
<td><strong>1 年+（长期进阶）</strong></td>
<td>持续优化认知模型</td>
<td>参与高水平思维训练，如哲学&#x2F;数学研究</td>
</tr>
</tbody></table>
<p>📌 <strong>实践方法</strong>：</p>
<ul>
<li>记录每周思维方式的应用案例，每月复盘优化。</li>
<li>找到一位 mentor 或加入高质量思维社群，定期交流挑战自己。</li>
</ul>
<hr>
<h2 id="长期培养思维能力的关键"><a href="#长期培养思维能力的关键" class="headerlink" title="长期培养思维能力的关键"></a><strong>长期培养思维能力的关键</strong></h2><ol>
<li><strong>主动思考 vs. 被动接受</strong>：不要只是接受信息，而是要提问、拆解、重构。</li>
<li><strong>跨学科 vs. 单一学科</strong>：用不同学科的思维方式解读同一问题。</li>
<li><strong>输出倒逼输入</strong>：定期写作、分享、辩论，强化思维的清晰度。</li>
<li><strong>挑战认知边界</strong>：刻意阅读不同观点，反思自己的偏见和盲区。</li>
</ol>
<hr>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a><strong>思维导图</strong></h2><p><img src="https://raw.githubusercontent.com/shispring/picgo/master/%E8%AE%A4%E7%9F%A5%E4%BA%8B%E7%89%A9%E6%9C%AC%E8%B4%A8%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA.jpg" alt="方法1" title="思维方法论"><br><img src="https://raw.githubusercontent.com/shispring/picgo/master/20250324120027.png" alt="方法2"></p>
]]></content>
      <tags>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s系统设计涉及的思想</title>
    <url>/2025/03/24/k8s%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%B6%89%E5%8F%8A%E7%9A%84%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h2 id="Kubernetes-探针（Probes）的设计初衷"><a href="#Kubernetes-探针（Probes）的设计初衷" class="headerlink" title="Kubernetes 探针（Probes）的设计初衷"></a><strong>Kubernetes 探针（Probes）的设计初衷</strong></h2><p>在 Kubernetes 中，<strong>探针（Probes）</strong> 的核心目的是<strong>确保 Pod 及其内部的容器处于健康可用状态</strong>，并在出现异常时采取自动化措施（如重启容器、从服务端点中移除等），从而<strong>提高应用的可靠性和稳定性</strong>。主要探针类型及其设计初衷如下：  </p>
<table>
<thead>
<tr>
<th><strong>探针类型</strong></th>
<th><strong>作用</strong></th>
<th><strong>设计初衷（解决什么问题）</strong></th>
<th><strong>典型应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>存活探针（Liveness Probe）</strong></td>
<td>确保容器进程存活</td>
<td>解决进程假死（进程仍在运行但已无响应）的情况</td>
<td>长时间运行的应用，避免因死锁或异常导致长期不可用</td>
</tr>
<tr>
<td><strong>就绪探针（Readiness Probe）</strong></td>
<td>确保容器准备好对外提供服务</td>
<td>解决应用启动慢或初始化未完成时被流量访问的问题</td>
<td>数据库、依赖外部服务的应用，需等待资源准备完毕</td>
</tr>
<tr>
<td><strong>启动探针（Startup Probe）</strong></td>
<td>确保应用完成启动</td>
<td>解决慢启动应用因 Liveness Probe 过早触发而被误杀的问题</td>
<td>需要长时间初始化的应用，如 Java 应用（JVM 启动）</td>
</tr>
</tbody></table>
<h3 id="为什么需要这些探针？"><a href="#为什么需要这些探针？" class="headerlink" title="为什么需要这些探针？"></a><strong>为什么需要这些探针？</strong></h3><ol>
<li><strong>提升服务可用性</strong>：避免因进程假死导致服务长时间不可用，K8s 可以自动修复问题。  </li>
<li><strong>降低运维成本</strong>：无需人工干预，系统可以自动发现并处理异常。  </li>
<li><strong>优化负载均衡</strong>：结合就绪探针，确保负载均衡器只将流量分发到健康的 Pod。  </li>
<li><strong>加快故障恢复</strong>：当探针检测到故障时，可快速触发自愈机制（如 Pod 重启）。</li>
</ol>
<hr>
<h2 id="Kubernetes-的整体系统设计思想"><a href="#Kubernetes-的整体系统设计思想" class="headerlink" title="Kubernetes 的整体系统设计思想"></a><strong>Kubernetes 的整体系统设计思想</strong></h2><p>Kubernetes 作为一个分布式容器编排系统，其设计思想来源于<strong>分布式系统、面向声明式 API 设计、自愈架构、可扩展架构</strong>等核心理念。以下是 K8s 关键设计思想：</p>
<table>
<thead>
<tr>
<th><strong>设计思想</strong></th>
<th><strong>描述</strong></th>
<th><strong>解决的问题</strong></th>
<th><strong>对应的 K8s 组件或功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>声明式 API（Declarative API）</strong></td>
<td>用户描述期望的最终状态，K8s 负责调和</td>
<td>解决复杂系统管理难题，减少人为干预</td>
<td><code>kubectl apply -f</code>，Deployment、Service</td>
</tr>
<tr>
<td><strong>状态调谐（State Reconciliation）</strong></td>
<td>控制器循环检查实际状态，并不断向期望状态收敛</td>
<td>解决节点故障、Pod 丢失等问题，实现高可用</td>
<td><code>kube-controller-manager</code> 负责管理状态</td>
</tr>
<tr>
<td><strong>自愈机制（Self-Healing）</strong></td>
<td>系统自动检测并修复异常</td>
<td>解决容器崩溃、网络异常，提高可靠性</td>
<td>Liveness&#x2F;Readiness Probe, ReplicaSet</td>
</tr>
<tr>
<td><strong>可扩展架构（Extensible Architecture）</strong></td>
<td>允许用户自定义资源和控制逻辑</td>
<td>解决不同行业场景下的定制需求</td>
<td>CRD（CustomResourceDefinition）、Operator</td>
</tr>
<tr>
<td><strong>负载均衡（Load Balancing）</strong></td>
<td>自动分配请求流量到健康 Pod</td>
<td>解决应用高并发问题，提高系统稳定性</td>
<td>Service、Ingress Controller</td>
</tr>
<tr>
<td><strong>分布式调度（Distributed Scheduling）</strong></td>
<td>根据资源情况自动调度 Pod</td>
<td>解决资源利用率问题，提高计算效率</td>
<td><code>kube-scheduler</code></td>
</tr>
<tr>
<td><strong>服务发现（Service Discovery）</strong></td>
<td>Pod 动态变化时，服务能自动发现</td>
<td>解决容器弹性扩缩容带来的服务地址变化问题</td>
<td>DNS 解析（CoreDNS）</td>
</tr>
<tr>
<td><strong>滚动更新（Rolling Updates）</strong></td>
<td>在不中断业务的情况下升级应用</td>
<td>解决应用升级期间的可用性问题</td>
<td>Deployment 的 <code>RollingUpdate</code></td>
</tr>
<tr>
<td><strong>水平扩展（Horizontal Scaling）</strong></td>
<td>根据负载情况自动扩容或缩容</td>
<td>解决资源利用率问题，降低成本</td>
<td>HPA（Horizontal Pod Autoscaler）</td>
</tr>
<tr>
<td><strong>不可变基础设施（Immutable Infrastructure）</strong></td>
<td>通过声明式配置管理系统，避免人工干预</td>
<td>解决手动配置带来的不可预测性</td>
<td>GitOps、Helm、ArgoCD</td>
</tr>
</tbody></table>
<hr>
<h2 id="Kubernetes-解决问题的思维方式"><a href="#Kubernetes-解决问题的思维方式" class="headerlink" title="Kubernetes 解决问题的思维方式"></a><strong>Kubernetes 解决问题的思维方式</strong></h2><h3 id="1-声明式-vs-命令式"><a href="#1-声明式-vs-命令式" class="headerlink" title="1. 声明式 vs. 命令式"></a><strong>1. 声明式 vs. 命令式</strong></h3><ul>
<li><strong>命令式（Imperative）</strong>：运维人员告诉系统“<strong>怎么做</strong>”，如 <code>kubectl create pod</code>。  </li>
<li><strong>声明式（Declarative）</strong>：运维人员告诉系统“<strong>最终目标是什么</strong>”，K8s 自行调和，如 <code>kubectl apply -f deployment.yaml</code>。  </li>
<li><strong>K8s 采用声明式管理</strong>，自动调和，降低人工维护成本，提高系统稳定性。</li>
</ul>
<h3 id="2-以控制环（Control-Loop）构建自治系统"><a href="#2-以控制环（Control-Loop）构建自治系统" class="headerlink" title="2. 以控制环（Control Loop）构建自治系统"></a><strong>2. 以控制环（Control Loop）构建自治系统</strong></h3><p>K8s 采用“<strong>观察-决策-执行</strong>”控制循环来管理系统：</p>
<ul>
<li><strong>观察（Observe）</strong>：监控当前集群状态（<code>kubelet</code>、Controller、Prometheus）  </li>
<li><strong>决策（Decide）</strong>：判断当前状态与目标状态的偏差（<code>kube-controller-manager</code>）  </li>
<li><strong>执行（Act）</strong>：采取措施纠正偏差（调度 Pod、重启 Pod、扩容等）</li>
</ul>
<p>这一设计<strong>确保了系统的自愈能力和高可用性</strong>。</p>
<h3 id="3-以组件化和可扩展性降低复杂度"><a href="#3-以组件化和可扩展性降低复杂度" class="headerlink" title="3. 以组件化和可扩展性降低复杂度"></a><strong>3. 以组件化和可扩展性降低复杂度</strong></h3><p>K8s 采用<strong>组件化架构</strong>，核心组件职责分明：</p>
<ul>
<li><code>etcd</code>：存储集群状态</li>
<li><code>kube-apiserver</code>：唯一入口，所有组件通过 API Server 交互</li>
<li><code>kube-scheduler</code>：调度 Pod</li>
<li><code>kubelet</code>：管理节点上的容器</li>
<li><code>kube-proxy</code>：管理 Service 之间的流量</li>
</ul>
<p>这种分层架构使得 K8s 易于扩展（如 CRD、Operator）并适应不同业务需求。</p>
<h3 id="4-通过不可变基础设施减少人为干预"><a href="#4-通过不可变基础设施减少人为干预" class="headerlink" title="4. 通过不可变基础设施减少人为干预"></a><strong>4. 通过不可变基础设施减少人为干预</strong></h3><ul>
<li>K8s 采用“<strong>不可变基础设施</strong>”原则，所有部署都是<strong>通过声明式 YAML 定义</strong>，并使用 GitOps 进行管理，避免手动修改引起的不一致性。  </li>
<li><strong>示例：</strong><ul>
<li><strong>传统方式</strong>：SSH 进服务器手动改配置 -&gt; 易出错、难追踪  </li>
<li><strong>K8s 方式</strong>：<code>kubectl apply -f my-deployment.yaml</code> -&gt; 可回滚、可审计、可追踪</li>
</ul>
</li>
</ul>
<h3 id="5-通过幂等性提升系统稳定性"><a href="#5-通过幂等性提升系统稳定性" class="headerlink" title="5. 通过幂等性提升系统稳定性"></a><strong>5. 通过幂等性提升系统稳定性</strong></h3><ul>
<li><strong>幂等性（Idempotency）</strong>：多次执行同一操作，系统最终状态不变。  </li>
<li><strong>在 K8s 中的应用：</strong><ul>
<li><code>kubectl apply -f</code>：无论执行多少次，状态都保持一致。</li>
<li><code>kube-controller-manager</code> 反复检查资源状态，直到达到期望状态。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Kubernetes 通过<strong>声明式 API、自愈能力、可扩展架构、分布式调度、不可变基础设施</strong>等核心设计，解决了<strong>资源管理复杂、系统不稳定、手动运维高成本、应用高可用性保障</strong>等问题。其整体架构和思维方式适用于<strong>大规模分布式系统管理</strong>，并提供了灵活的扩展能力，使其成为云原生时代的基础设施标准。</p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s节点扩缩组件autoscaler与externalgrpc模式的grpc调试</title>
    <url>/2025/03/25/k8s%E8%8A%82%E7%82%B9%E6%89%A9%E7%BC%A9%E7%BB%84%E4%BB%B6autoscaler%E4%B8%8Eexternalgrpc%E6%A8%A1%E5%BC%8F%E7%9A%84grpc%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="externalgrpc-proto文件"><a href="#externalgrpc-proto文件" class="headerlink" title="externalgrpc.proto文件"></a>externalgrpc.proto文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#文件路径</span><br><span class="line">/home/xxx/autoscaler/cluster-autoscaler/cloudprovider/externalgrpc/protos/externalgrpc.proto</span><br><span class="line"></span><br><span class="line">#涉及到的import</span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package clusterautoscaler.cloudprovider.v1.externalgrpc;</span><br><span class="line"></span><br><span class="line">import &quot;google/protobuf/descriptor.proto&quot;;</span><br><span class="line">import &quot;google/protobuf/any.proto&quot;;</span><br><span class="line">import &quot;k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto&quot;;</span><br><span class="line"></span><br><span class="line">import &quot;k8s.io/api/core/v1/generated.proto&quot;;</span><br><span class="line">option go_package = &quot;cluster-autoscaler/cloudprovider/externalgrpc/protos&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="grpc拼凑"><a href="#grpc拼凑" class="headerlink" title="grpc拼凑"></a>grpc拼凑</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cluster-autoscaler-cloud-provider是云厂商提供服务的域名，配置在证书里</span><br><span class="line">#11.31.213.234是cloud provider的服务端地址</span><br><span class="line"></span><br><span class="line">#验证TLS请求(单项请求)</span><br><span class="line">#openssl s_client -connect  11.31.213.234:65535</span><br><span class="line"></span><br><span class="line">#服务端证书名称：ca.cert.pem ，路径为：</span><br><span class="line">BASEDIR=/home/xxx/cloud-config</span><br><span class="line"></span><br><span class="line">#认证可以通过的请求</span><br><span class="line">grpcurl \</span><br><span class="line">    --cacert $BASEDIR/ca.cert.pem  \</span><br><span class="line">    -import-path /home/xxx/autoscaler/cluster-autoscaler/cloudprovider/externalgrpc/protos \</span><br><span class="line">    -import-path /home/xxx/autoscaler/cluster-autoscaler/vendor     \</span><br><span class="line">    -proto externalgrpc.proto     \</span><br><span class="line">    cluster-autoscaler-cloud-provider:65535    \</span><br><span class="line">    clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/NodeGroups  </span><br><span class="line"></span><br><span class="line">#11.31.213.234对应的cluster-autoscaler-cloud-provider服务podIP</span><br><span class="line">grpcurl -insecure \</span><br><span class="line">    -import-path /home/xxx/autoscaler/cluster-autoscaler/cloudprovider/externalgrpc/protos \</span><br><span class="line">    -import-path /home/xxx/autoscaler/cluster-autoscaler/vendor     \</span><br><span class="line">    -proto externalgrpc.proto     \</span><br><span class="line">    11.31.213.234:65535     \</span><br><span class="line">    clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/NodeGroups  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#无法通过的请求：Failed to dial target host &quot;11.31.213.234:65535&quot;: tls: failed to verify certificate: x509: certificate is valid for 127.0.0.1, not 11.31.213.234</span><br><span class="line">grpcurl \</span><br><span class="line">    --cacert $BASEDIR/ca.cert.pem  \</span><br><span class="line">    -import-path /home/xxx/autoscaler/cluster-autoscaler/cloudprovider/externalgrpc/protos \</span><br><span class="line">    -import-path /home/xxx/autoscaler/cluster-autoscaler/vendor  \</span><br><span class="line">    -proto externalgrpc.proto     \</span><br><span class="line">    11.31.213.234:65535     \</span><br><span class="line">    clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/NodeGroups</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="如果是tls双向认证情况请求"><a href="#如果是tls双向认证情况请求" class="headerlink" title="如果是tls双向认证情况请求"></a>如果是tls双向认证情况请求</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在路径配置客户端秘钥及证书</span><br><span class="line">grpcurl \</span><br><span class="line">    --cert $BASEDIR/client.cert.pem  \</span><br><span class="line">    --key $BASEDIR/client.key.pem \</span><br><span class="line">    --cacert $BASEDIR/ca.cert.pem  \</span><br><span class="line">    -import-path /home/xxx/autoscaler/cluster-autoscaler/cloudprovider/externalgrpc/protos \</span><br><span class="line">    -import-path /home/xxx/autoscaler/cluster-autoscaler/vendor     \</span><br><span class="line">    -proto externalgrpc.proto     \</span><br><span class="line">    cluster-autoscaler-cloud-provider:65535    \</span><br><span class="line">    clusterautoscaler.cloudprovider.v1.externalgrpc.CloudProvider/NodeGroups</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="openssl请求解析"><a href="#openssl请求解析" class="headerlink" title="openssl请求解析"></a>openssl请求解析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl s_client -connect cluster-autoscaler-backend:65535 -CAfile /home/xxx/cloud-config/dev-containerd/ca.cert.pem</span><br><span class="line">CONNECTED(00000003)</span><br><span class="line">Can&#x27;t use SSL_get_servername</span><br><span class="line">depth=1 C = CN, ST = Beijing, L = Chaoyang, O = Qihoo, CN = qihoo.net</span><br><span class="line">verify return:1</span><br><span class="line">depth=0 C = CN, ST = Beijing, L = Chaoyang, O = Qihoo, CN = cluster-autoscaler-cloud-provider</span><br><span class="line">verify return:1</span><br><span class="line">---</span><br><span class="line">Certificate chain</span><br><span class="line"> 0 s:C = CN, ST = Beijing, L = Chaoyang, O = Qihoo, CN = cluster-autoscaler-cloud-provider</span><br><span class="line">   i:C = CN, ST = Beijing, L = Chaoyang, O = Qihoo, CN = qihoo.net</span><br><span class="line">---</span><br><span class="line">Server certificate</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIICYDCCAgagAwIBAgIUcO+yQm6JNnr+ogeb...</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line">subject=C = CN, ST = Beijing, L = Chaoyang, O = Qihoo, CN = cluster-autoscaler-cloud-provider</span><br><span class="line"></span><br><span class="line">issuer=C = CN, ST = Beijing, L = Chaoyang, O = Qihoo, CN = qihoo.net</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">No client certificate CA names sent</span><br><span class="line">Peer signing digest: SHA256</span><br><span class="line">Peer signature type: ECDSA</span><br><span class="line">Server Temp Key: X25519, 253 bits</span><br><span class="line">---</span><br><span class="line">SSL handshake has read 916 bytes and written 369 bytes</span><br><span class="line">Verification: OK</span><br><span class="line">---</span><br><span class="line">New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384</span><br><span class="line">Server public key is 256 bit</span><br><span class="line">Secure Renegotiation IS NOT supported</span><br><span class="line">Compression: NONE</span><br><span class="line">Expansion: NONE</span><br><span class="line">No ALPN negotiated</span><br><span class="line">Early data was not sent</span><br><span class="line">Verify return code: 0 (ok)</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="📌-关键点解析"><a href="#📌-关键点解析" class="headerlink" title="📌 关键点解析"></a><strong>📌 关键点解析</strong></h2><h3 id="✅-1-TLS-连接成功"><a href="#✅-1-TLS-连接成功" class="headerlink" title="✅ 1. TLS 连接成功"></a><strong>✅ 1. TLS 连接成功</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONNECTED(00000003)</span><br></pre></td></tr></table></figure>
<ul>
<li>你的客户端 <code>openssl</code> 成功连接到了 <code>cluster-autoscaler-cloud-provider:65535</code> 端口，并完成了 TLS 握手。</li>
</ul>
<hr>
<h3 id="✅-2-证书验证通过"><a href="#✅-2-证书验证通过" class="headerlink" title="✅ 2. 证书验证通过"></a><strong>✅ 2. 证书验证通过</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">depth=1 C = CN, ST = Beijing, L = Chaoyang, O = Qihoo, CN = qihoo.net</span><br><span class="line">verify return:1</span><br><span class="line">depth=0 C = CN, ST = Beijing, L = Chaoyang, O = Qihoo, CN = cluster-autoscaler-cloud-provider</span><br><span class="line">verify return:1</span><br></pre></td></tr></table></figure>
<ul>
<li>你的 CA 证书 <code>/home/xxx/cloud-config/dev-containerd/ca.cert.pem</code> <strong>已经正确地验证了服务器证书</strong>。</li>
<li><code>verify return:1</code> 表示 <code>openssl</code> 在认证每一级证书时，返回成功。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Verify return code: 0 (ok)</span><br></pre></td></tr></table></figure>
<ul>
<li>这个 <code>0 (ok)</code> 说明 <strong>TLS 证书链已经正确验证</strong>，你不再遇到 <code>unable to verify the first certificate</code> 之类的错误。</li>
</ul>
<p><strong>说明你的 CA 证书是正确的，服务器证书也是可信的。</strong> 🎉</p>
<hr>
<h3 id="✅-3-服务器提供的证书链"><a href="#✅-3-服务器提供的证书链" class="headerlink" title="✅ 3. 服务器提供的证书链"></a><strong>✅ 3. 服务器提供的证书链</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Certificate chain</span><br><span class="line"> 0 s:C = CN, ST = Beijing, L = Chaoyang, O = Qihoo, CN = cluster-autoscaler-cloud-provider</span><br><span class="line">   i:C = CN, ST = Beijing, L = Chaoyang, O = Qihoo, CN = qihoo.net</span><br></pre></td></tr></table></figure>
<ul>
<li><code>s:</code> (<strong>subject</strong>) 表示服务器的证书 (<code>cluster-autoscaler-cloud-provider</code>)。</li>
<li><code>i:</code> (<strong>issuer</strong>) 表示这个证书是由 <code>qihoo.net</code> 这个 CA 颁发的。</li>
<li>你的 <code>CAfile</code> <strong>包含了 <code>qihoo.net</code> 的 CA 证书</strong>，所以能够正确验证服务器证书。</li>
</ul>
<hr>
<h3 id="✅-4-服务器没有要求客户端证书"><a href="#✅-4-服务器没有要求客户端证书" class="headerlink" title="✅ 4. 服务器没有要求客户端证书"></a><strong>✅ 4. 服务器没有要求客户端证书</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No client certificate CA names sent</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器 <strong>不要求客户端提供证书</strong>，也就是说没有启用 **双向 TLS (mTLS)**。</li>
<li>如果服务器需要 <strong>mTLS</strong>，你会看到 <code>Acceptable client certificate CA names</code>，并且 <code>openssl</code> 可能会要求 <code>-cert</code> 和 <code>-key</code>。</li>
</ul>
<hr>
<h3 id="✅-5-TLS-版本与加密算法"><a href="#✅-5-TLS-版本与加密算法" class="headerlink" title="✅ 5. TLS 版本与加密算法"></a><strong>✅ 5. TLS 版本与加密算法</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384</span><br><span class="line">Server public key is 256 bit</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>TLS 版本</strong>: <code>TLSv1.3</code>（最新的 TLS 版本，更安全）。</li>
<li><strong>加密算法</strong>: <code>AES_256_GCM_SHA384</code>（对称加密算法，安全性高）。</li>
<li><strong>服务器公钥长度</strong>: <code>256 bit</code>，符合现代安全标准。</li>
</ul>
<p>你使用的 <code>openssl</code> 版本支持 TLS 1.3，没有出现协议不兼容的问题。</p>
<hr>
<h2 id="📌-结论"><a href="#📌-结论" class="headerlink" title="📌 结论"></a><strong>📌 结论</strong></h2><p>✅ <strong>你已经正确配置了 CA 证书</strong>，服务器证书也成功验证。<br>✅ <strong>TLS 连接建立正常</strong>，服务器使用 TLS 1.3，安全性较高。<br>✅ <strong>服务器不要求客户端证书</strong>，所以是 <strong>单向 TLS 认证</strong>。<br>✅ <strong>没有任何 SSL&#x2F;TLS 相关错误</strong>，一切正常！🎉</p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>daemonset滚动升级</title>
    <url>/2025/04/14/daemonset%E6%BB%9A%E5%8A%A8%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="🚀-DaemonSet-的-updateStrategy-升级策略详解"><a href="#🚀-DaemonSet-的-updateStrategy-升级策略详解" class="headerlink" title="🚀 DaemonSet 的 updateStrategy 升级策略详解"></a>🚀 DaemonSet 的 <code>updateStrategy</code> 升级策略详解</h2><p>DaemonSet 的升级策略定义在 <code>spec.updateStrategy</code> 字段下，用来控制 <strong>Pod 的滚动升级行为</strong>。</p>
<p>目前支持两种类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>RollingUpdate</code></td>
<td>自动滚动升级，推荐的方式</td>
</tr>
<tr>
<td><code>OnDelete</code></td>
<td>手动删除后重建，不自动升级</td>
</tr>
</tbody></table>
<hr>
<h3 id="🔁-1-type-RollingUpdate-（自动滚动升级）"><a href="#🔁-1-type-RollingUpdate-（自动滚动升级）" class="headerlink" title="🔁 1. type: RollingUpdate （自动滚动升级）"></a>🔁 1. <code>type: RollingUpdate</code> （自动滚动升级）</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">updateStrategy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">  <span class="attr">rollingUpdate:</span></span><br><span class="line">    <span class="attr">maxUnavailable:</span> <span class="number">30</span><span class="string">%</span></span><br></pre></td></tr></table></figure>

<h4 id="🔸-含义："><a href="#🔸-含义：" class="headerlink" title="🔸 含义："></a>🔸 含义：</h4><ul>
<li>自动将老版本的 Pod 一个个替换为新版本，<strong>每次升级部分 Pod</strong>。</li>
<li>受 <code>maxUnavailable</code> 控制，表示 <strong>在任意时刻最多有多少 Pod 可以不可用</strong>。</li>
</ul>
<h4 id="📌-maxUnavailable-参数详解："><a href="#📌-maxUnavailable-参数详解：" class="headerlink" title="📌 maxUnavailable 参数详解："></a>📌 <code>maxUnavailable</code> 参数详解：</h4><ul>
<li>可以是整数（如 <code>1</code>）或百分比（如 <code>30%</code>）</li>
<li>表示 <strong>升级期间，允许的最大不可用 Pod 数量</strong></li>
</ul>
<h4 id="⛓️-升级过程（示例）："><a href="#⛓️-升级过程（示例）：" class="headerlink" title="⛓️ 升级过程（示例）："></a>⛓️ 升级过程（示例）：</h4><p>假设你在 10 个节点上部署了 DaemonSet，每个节点都有一个 Pod。</p>
<p>升级步骤：</p>
<ol>
<li>允许最多 3 个 Pod（30%）同时被删除并重建。</li>
<li>控制器会自动删除旧版本的 Pod 并创建新版本。</li>
<li>等新版本的 Pod 启动成功后，再继续替换下一批。</li>
</ol>
<h4 id="✅-优点："><a href="#✅-优点：" class="headerlink" title="✅ 优点："></a>✅ 优点：</h4><ul>
<li><strong>平滑升级</strong>，对服务影响最小</li>
<li>推荐用于生产环境</li>
</ul>
<hr>
<h3 id="🧍-2-type-OnDelete-（手动升级）"><a href="#🧍-2-type-OnDelete-（手动升级）" class="headerlink" title="🧍 2. type: OnDelete （手动升级）"></a>🧍 2. <code>type: OnDelete</code> （手动升级）</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">updateStrategy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">OnDelete</span></span><br></pre></td></tr></table></figure>

<h4 id="🔸-含义：-1"><a href="#🔸-含义：-1" class="headerlink" title="🔸 含义："></a>🔸 含义：</h4><ul>
<li>DaemonSet 控制器 <strong>不会主动删除旧版本 Pod</strong></li>
<li>只有当你手动 <code>kubectl delete pod xxx</code> 删除旧 Pod 时，DaemonSet 才会拉起新版本的 Pod</li>
</ul>
<h4 id="⛓️-升级过程："><a href="#⛓️-升级过程：" class="headerlink" title="⛓️ 升级过程："></a>⛓️ 升级过程：</h4><ol>
<li>你修改了 DaemonSet 的模板（如 image）</li>
<li>DaemonSet 检测到变更，但 <strong>不会更新任何 Pod</strong></li>
<li>你需要手动删除 Pod：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete pod ingress-nginx-controller-xxxxx -n ingress-nginx</span><br></pre></td></tr></table></figure></li>
<li>控制器自动基于新的模板重新创建 Pod</li>
</ol>
<h4 id="✅-适用场景："><a href="#✅-适用场景：" class="headerlink" title="✅ 适用场景："></a>✅ 适用场景：</h4><ul>
<li>你需要<strong>精确控制每个节点 Pod 的升级时机</strong></li>
<li>避免自动滚动升级带来的不确定性</li>
</ul>
<h4 id="❌-缺点："><a href="#❌-缺点：" class="headerlink" title="❌ 缺点："></a>❌ 缺点：</h4><ul>
<li>升级需要人工干预</li>
<li>不适合频繁迭代或高可用性要求场景</li>
</ul>
<hr>
<h3 id="🧠-总结对比"><a href="#🧠-总结对比" class="headerlink" title="🧠 总结对比"></a>🧠 总结对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>RollingUpdate</th>
<th>OnDelete</th>
</tr>
</thead>
<tbody><tr>
<td>是否自动升级</td>
<td>✅ 是</td>
<td>❌ 否，需要手动删除</td>
</tr>
<tr>
<td>可控性</td>
<td>中等</td>
<td>高</td>
</tr>
<tr>
<td>服务连续性</td>
<td>高（通过 <code>maxUnavailable</code> 控制）</td>
<td>高（完全受控）</td>
</tr>
<tr>
<td>推荐场景</td>
<td>生产环境通用升级</td>
<td>手动灰度升级、需精细控制时</td>
</tr>
<tr>
<td>运维复杂度</td>
<td>低</td>
<td>中-高</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>拆解复杂问题思路一</title>
    <url>/2025/04/21/%E6%8B%86%E8%A7%A3%E5%A4%8D%E6%9D%82%E9%97%AE%E9%A2%98%E6%80%9D%E8%B7%AF%E4%B8%80/</url>
    <content><![CDATA[<h2 id="🧠-一头雾水时，如何系统性梳理问题？"><a href="#🧠-一头雾水时，如何系统性梳理问题？" class="headerlink" title="🧠 一头雾水时，如何系统性梳理问题？"></a>🧠 一头雾水时，如何系统性梳理问题？</h2><hr>
<h2 id="✅-总体框架：「事前-事中-事后」问题梳理法"><a href="#✅-总体框架：「事前-事中-事后」问题梳理法" class="headerlink" title="✅ 总体框架：「事前-事中-事后」问题梳理法"></a>✅ 总体框架：<strong>「事前-事中-事后」问题梳理法</strong></h2><table>
<thead>
<tr>
<th>阶段</th>
<th>拆解维度</th>
<th>说明与典型问题</th>
<th>可用工具</th>
</tr>
</thead>
<tbody><tr>
<td>事前</td>
<td>背景</td>
<td>为什么现在做这件事？是谁提出的？与哪些事有关？</td>
<td>5W1H、背景调查</td>
</tr>
<tr>
<td></td>
<td>现状</td>
<td>当前的状态如何？有哪些数据&#x2F;现象&#x2F;资源？</td>
<td>状态对比、SWOT</td>
</tr>
<tr>
<td></td>
<td>目标</td>
<td>希望达到什么结果？是长期目标还是短期目标？</td>
<td>SMART 原则</td>
</tr>
<tr>
<td></td>
<td>路径&#x2F;方案</td>
<td>实现目标的可能路径有哪些？方案对比如何？</td>
<td>MECE拆解、方案矩阵</td>
</tr>
<tr>
<td>事中</td>
<td>已知问题解决</td>
<td>是否已有明确问题点？已知问题的影响和优先级如何？</td>
<td>优先级排序、鱼骨图</td>
</tr>
<tr>
<td></td>
<td>突发问题&#x2F;新问题应对</td>
<td>有无新暴露出的未知问题？是否影响整体目标？</td>
<td>快速响应、迭代思维</td>
</tr>
<tr>
<td></td>
<td>协调与资源分配</td>
<td>需要和谁配合？资源是否充足？瓶颈在哪里？</td>
<td>权责矩阵、沟通地图</td>
</tr>
<tr>
<td>事后</td>
<td>复盘与总结</td>
<td>是否达成预期？有哪些经验？哪些地方做得好&#x2F;不好？</td>
<td>PDCA、复盘四问</td>
</tr>
<tr>
<td></td>
<td>系统性改进</td>
<td>有哪些流程&#x2F;机制&#x2F;能力可以优化？是否可以形成 SOP？</td>
<td>5Whys、流程再造</td>
</tr>
<tr>
<td></td>
<td>创新与延伸</td>
<td>能否在已有基础上衍生出更多价值？</td>
<td>横向迁移、类比创新</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔧-附加拆解工具与方法建议："><a href="#🔧-附加拆解工具与方法建议：" class="headerlink" title="🔧 附加拆解工具与方法建议："></a>🔧 附加拆解工具与方法建议：</h2><table>
<thead>
<tr>
<th>工具&#x2F;方法</th>
<th>说明与用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>MECE原则</strong></td>
<td>拆解时做到不重不漏，尤其适合任务&#x2F;问题分类</td>
</tr>
<tr>
<td><strong>鱼骨图</strong></td>
<td>分析问题根因，适合事中已知问题的深入分析</td>
</tr>
<tr>
<td><strong>5W1H</strong></td>
<td>Who、What、When、Where、Why、How，适用于任何阶段</td>
</tr>
<tr>
<td><strong>SWOT分析</strong></td>
<td>优势、劣势、机会、威胁，适合战略与现状分析</td>
</tr>
<tr>
<td><strong>时间线法</strong></td>
<td>把事情按时间排序，清晰任务节奏与逻辑关系</td>
</tr>
<tr>
<td><strong>因果图</strong></td>
<td>复杂系统中帮助理解事件之间的因果联系</td>
</tr>
<tr>
<td><strong>PDCA循环</strong></td>
<td>Plan-Do-Check-Act，适合持续改进和复盘</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧭-应用建议："><a href="#🧭-应用建议：" class="headerlink" title="🧭 应用建议："></a>🧭 应用建议：</h2><ul>
<li>🌱 <strong>初级阶段</strong>：使用表格辅助写清楚“背景-目标-现状-问题”四项，就能把很多雾气拨开；</li>
<li>🛠 <strong>进阶阶段</strong>：掌握 MECE、PDCA、优先级管理等工具，可高效推进复杂事务；</li>
<li>🧠 <strong>专家阶段</strong>：在事后总结中寻找模式与方法，构建自己的“问题处理知识库”或“经验地图”。</li>
</ul>
]]></content>
      <tags>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title>ffmpeg处理视频tips</title>
    <url>/2025/04/22/ffmpeg%E5%A4%84%E7%90%86%E8%A7%86%E9%A2%91tips/</url>
    <content><![CDATA[<h3 id="查看视频总帧数"><a href="#查看视频总帧数" class="headerlink" title="查看视频总帧数"></a>查看视频总帧数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffprobe -v error -count_frames -select_streams v:0 -show_entries stream=nb_read_frames -of default=nokey=1:noprint_wrappers=1 your_video.mp4</span><br></pre></td></tr></table></figure>

<h3 id="导出视频的每一帧为图片"><a href="#导出视频的每一帧为图片" class="headerlink" title="导出视频的每一帧为图片"></a>导出视频的每一帧为图片</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i your_video.mp4 -q:v 1 output/frame_%05d.jpg</span><br><span class="line">参数含义</span><br><span class="line">-i your_video.mp4 : 输入文件</span><br><span class="line">-q:v 1 : 设置输出图像质量，1 是最高（1~31）</span><br><span class="line">output/frame_%05d.jpg : 输出路径和命名格式（5位数字序号）</span><br></pre></td></tr></table></figure>

<h3 id="制作正向视频"><a href="#制作正向视频" class="headerlink" title="制作正向视频"></a>制作正向视频</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; frames.txt</span><br><span class="line">file &#x27;frame_00076.jpg&#x27;</span><br><span class="line">file &#x27;frame_00077.jpg&#x27;</span><br><span class="line">file &#x27;frame_00078.jpg&#x27;</span><br><span class="line">file &#x27;frame_00079.jpg&#x27;</span><br><span class="line">file &#x27;frame_00080.jpg&#x27;</span><br><span class="line">file &#x27;frame_00081.jpg&#x27;</span><br><span class="line">file &#x27;frame_00082.jpg&#x27;</span><br><span class="line">file &#x27;frame_00083.jpg&#x27;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">ffmpeg -f concat -safe 0 -r 25 -i frames.txt -c:v libx264 -pix_fmt yuv420p forward.mp4</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">-framerate 25: 设置帧率为25（可按需调整）</span><br><span class="line">-i frame_%05d.jpg: 匹配 frame_00076.jpg 至 frame_00083.jpg（确保目录下这些帧是连续命名的）</span><br><span class="line">-vframes 8: 指定只使用8帧</span><br><span class="line">-c:v libx264: 使用 H.264 编码</span><br><span class="line">-pix_fmt yuv420p: 保证兼容性（尤其是网页或播放器）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="制作倒序视频"><a href="#制作倒序视频" class="headerlink" title="制作倒序视频"></a>制作倒序视频</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; reverse.txt</span><br><span class="line">file &#x27;frame_00082.jpg&#x27;</span><br><span class="line">file &#x27;frame_00081.jpg&#x27;</span><br><span class="line">file &#x27;frame_00080.jpg&#x27;</span><br><span class="line">file &#x27;frame_00079.jpg&#x27;</span><br><span class="line">file &#x27;frame_00078.jpg&#x27;</span><br><span class="line">file &#x27;frame_00077.jpg&#x27;</span><br><span class="line">file &#x27;frame_00076.jpg&#x27;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">ffmpeg -f concat -safe 0 -r 25 -i reverse.txt -c:v libx264 -pix_fmt yuv420p reverse.mp4</span><br></pre></td></tr></table></figure>
<h3 id="拼接正向-反向-视频"><a href="#拼接正向-反向-视频" class="headerlink" title="拼接正向 + 反向 视频"></a>拼接正向 + 反向 视频</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; concat.txt</span><br><span class="line">file &#x27;forward.mp4&#x27;</span><br><span class="line">file &#x27;reverse.mp4&#x27;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">ffmpeg -f concat -safe 0 -i concat.txt -r 25 -c:v libx264 -pix_fmt yuv420p looped.mp4</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="剔除视频片段"><a href="#剔除视频片段" class="headerlink" title="剔除视频片段"></a>剔除视频片段</h2><ul>
<li>1.确定要剔除的片段时间范围（比如从 00:01:30 到 00:02:10）</li>
<li>2.用 ffmpeg 将视频切成两段，然后拼接起来（中间那段就被“剔除”）</li>
</ul>
<h3 id="无损裁剪-拼接（推荐）"><a href="#无损裁剪-拼接（推荐）" class="headerlink" title="无损裁剪 + 拼接（推荐）"></a>无损裁剪 + 拼接（推荐）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 切出前半段（从开头到 1:30）</span><br><span class="line">ffmpeg -i input.mp4 -ss 00:00:00 -to 00:01:30 -c copy part1.mp4</span><br><span class="line"></span><br><span class="line"># 切出后半段（从 2:10 到结尾）</span><br><span class="line">ffmpeg -i input.mp4 -ss 00:02:10 -c copy part2.mp4</span><br><span class="line"></span><br><span class="line"># 生成文件列表</span><br><span class="line">echo -e &quot;file &#x27;part1.mp4&#x27;\nfile &#x27;part2.mp4&#x27;&quot; &gt; files.txt</span><br><span class="line"></span><br><span class="line"># 拼接两段</span><br><span class="line">ffmpeg -f concat -safe 0 -i files.txt -c copy output.mp4</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s资源相关统计</title>
    <url>/2025/04/23/k8s%E8%B5%84%E6%BA%90%E7%9B%B8%E5%85%B3%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="统计节点可分配的CPU-内存"><a href="#统计节点可分配的CPU-内存" class="headerlink" title="统计节点可分配的CPU&#x2F;内存"></a>统计节点可分配的CPU&#x2F;内存</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get nodes -o=jsonpath=&#x27;&#123;range .items[*]&#125;&#123;.metadata.name&#125;&#123;&quot;\t&quot;&#125;&#123;.status.allocatable.cpu&#125;&#123;&quot;\t&quot;&#125;&#123;.status.allocatable.memory&#125;&#123;&quot;\n&quot;&#125;&#123;end&#125;&#x27; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 颜色增强</span><br><span class="line">GREEN=&quot;\033[0;32m&quot;</span><br><span class="line">YELLOW=&quot;\033[1;33m&quot;</span><br><span class="line">RED=&quot;\033[0;31m&quot;</span><br><span class="line">NC=&quot;\033[0m&quot;</span><br><span class="line"></span><br><span class="line">echo -e &quot;$&#123;GREEN&#125;开始统计节点资源情况...$&#123;NC&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 获取所有节点</span><br><span class="line">nodes=$(kubectl get nodes -o jsonpath=&#x27;&#123;.items[*].metadata.name&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">for node in $nodes; do</span><br><span class="line">  echo -e &quot;\n$&#123;YELLOW&#125;节点：$node$&#123;NC&#125;&quot;</span><br><span class="line"></span><br><span class="line">  # 获取 Allocatable 资源</span><br><span class="line">  alloc_cpu=$(kubectl get node &quot;$node&quot; -o jsonpath=&#x27;&#123;.status.allocatable.cpu&#125;&#x27;)</span><br><span class="line">  alloc_mem=$(kubectl get node &quot;$node&quot; -o jsonpath=&#x27;&#123;.status.allocatable.memory&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">  # 将 CPU 转为 milliCPU</span><br><span class="line">  [[ $alloc_cpu =~ m$ ]] &amp;&amp; alloc_cpu_m=$&#123;alloc_cpu%m&#125; || alloc_cpu_m=$(echo &quot;$alloc_cpu * 1000&quot; | bc)</span><br><span class="line"></span><br><span class="line">  # Memory 转为 Mi</span><br><span class="line">  alloc_mem_mi=$(echo &quot;$alloc_mem&quot; | sed &#x27;s/Ki//&#x27; | awk &#x27;&#123;printf &quot;%.0f&quot;, $1 / 1024&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">  # 获取当前节点下所有 Pod 的 requests</span><br><span class="line">  pod_data=$(kubectl get pods --all-namespaces --field-selector spec.nodeName=&quot;$node&quot; -o json)</span><br><span class="line"></span><br><span class="line">  used_cpu_m=$(echo &quot;$pod_data&quot; | jq &#x27;[.items[].spec.containers[].resources.requests.cpu // &quot;0&quot;]</span><br><span class="line">    | map(if test(&quot;m$&quot;) then sub(&quot;m$&quot;;&quot;&quot;) | tonumber else (tonumber * 1000) end) | add&#x27;)</span><br><span class="line"></span><br><span class="line">  used_mem_mi=$(echo &quot;$pod_data&quot; | jq &#x27;[.items[].spec.containers[].resources.requests.memory // &quot;0&quot;]</span><br><span class="line">    | map(</span><br><span class="line">        if test(&quot;Mi$&quot;) then sub(&quot;Mi$&quot;;&quot;&quot;) | tonumber</span><br><span class="line">        elif test(&quot;Ki$&quot;) then sub(&quot;Ki$&quot;;&quot;&quot;) | tonumber / 1024</span><br><span class="line">        elif test(&quot;Gi$&quot;) then sub(&quot;Gi$&quot;;&quot;&quot;) | tonumber * 1024</span><br><span class="line">        else 0 end</span><br><span class="line">    ) | add&#x27;)</span><br><span class="line"></span><br><span class="line">  # 计算剩余</span><br><span class="line">  free_cpu_m=$(echo &quot;$alloc_cpu_m - $used_cpu_m&quot; | bc)</span><br><span class="line">  free_mem_mi=$(echo &quot;$alloc_mem_mi - $used_mem_mi&quot; | bc)</span><br><span class="line"></span><br><span class="line">  echo -e &quot;CPU:&quot;</span><br><span class="line">  echo -e &quot;  可分配CPU:      $&#123;alloc_cpu_m&#125;m&quot;</span><br><span class="line">  echo -e &quot;  已分配CPU:      $&#123;used_cpu_m&#125;m&quot;</span><br><span class="line">  echo -e &quot;  剩余可分配CPU:  $&#123;free_cpu_m&#125;m&quot;</span><br><span class="line">  echo -e &quot;内存:&quot;</span><br><span class="line">  echo -e &quot;  可分配内存:     $&#123;alloc_mem_mi&#125;Mi&quot;</span><br><span class="line">  echo -e &quot;  已分配内存:     $&#123;used_mem_mi&#125;Mi&quot;</span><br><span class="line">  echo -e &quot;  剩余可分配内存: $&#123;free_mem_mi&#125;Mi&quot;</span><br><span class="line"></span><br><span class="line">  # 检查是否有 &lt;none&gt; 请求</span><br><span class="line">  none_count=$(kubectl get pods --all-namespaces --field-selector spec.nodeName=&quot;$node&quot; \</span><br><span class="line">    -o jsonpath=&#x27;&#123;range .items[*]&#125;&#123;range .spec.containers[*]&#125;&#123;.resources.requests.cpu&#125;&#123;&quot;\n&quot;&#125;&#123;end&#125;&#123;end&#125;&#x27; | grep -c &#x27;^$&#x27;)</span><br><span class="line"></span><br><span class="line">  if [ &quot;$none_count&quot; -gt 0 ]; then</span><br><span class="line">    echo -e &quot;  $&#123;RED&#125;存在 $none_count 个容器未设置CPU requests$&#123;NC&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 集群汇总</span><br><span class="line">echo -e &quot;\n$&#123;GREEN&#125;汇总集群维度资源...$&#123;NC&#125;&quot;</span><br><span class="line"></span><br><span class="line">all_alloc_cpu_m=0</span><br><span class="line">all_alloc_mem_mi=0</span><br><span class="line">all_used_cpu_m=0</span><br><span class="line">all_used_mem_mi=0</span><br><span class="line"></span><br><span class="line">for node in $nodes; do</span><br><span class="line">  a_cpu=$(kubectl get node &quot;$node&quot; -o jsonpath=&#x27;&#123;.status.allocatable.cpu&#125;&#x27;)</span><br><span class="line">  a_mem=$(kubectl get node &quot;$node&quot; -o jsonpath=&#x27;&#123;.status.allocatable.memory&#125;&#x27;)</span><br><span class="line">  [[ $a_cpu =~ m$ ]] &amp;&amp; a_cpu_m=$&#123;a_cpu%m&#125; || a_cpu_m=$(echo &quot;$a_cpu * 1000&quot; | bc)</span><br><span class="line">  a_mem_mi=$(echo &quot;$a_mem&quot; | sed &#x27;s/Ki//&#x27; | awk &#x27;&#123;printf &quot;%.0f&quot;, $1 / 1024&#125;&#x27;)</span><br><span class="line">  all_alloc_cpu_m=$(echo &quot;$all_alloc_cpu_m + $a_cpu_m&quot; | bc)</span><br><span class="line">  all_alloc_mem_mi=$(echo &quot;$all_alloc_mem_mi + $a_mem_mi&quot; | bc)</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">all_pods=$(kubectl get pods --all-namespaces -o json)</span><br><span class="line"></span><br><span class="line">all_used_cpu_m=$(echo &quot;$all_pods&quot; | jq &#x27;[.items[].spec.containers[].resources.requests.cpu // &quot;0&quot;]</span><br><span class="line">  | map(if test(&quot;m$&quot;) then sub(&quot;m$&quot;;&quot;&quot;) | tonumber else (tonumber * 1000) end) | add&#x27;)</span><br><span class="line"></span><br><span class="line">all_used_mem_mi=$(echo &quot;$all_pods&quot; | jq &#x27;[.items[].spec.containers[].resources.requests.memory // &quot;0&quot;]</span><br><span class="line">  | map(</span><br><span class="line">      if test(&quot;Mi$&quot;) then sub(&quot;Mi$&quot;;&quot;&quot;) | tonumber</span><br><span class="line">      elif test(&quot;Ki$&quot;) then sub(&quot;Ki$&quot;;&quot;&quot;) | tonumber / 1024</span><br><span class="line">      elif test(&quot;Gi$&quot;) then sub(&quot;Gi$&quot;;&quot;&quot;) | tonumber * 1024</span><br><span class="line">      else 0 end</span><br><span class="line">  ) | add&#x27;)</span><br><span class="line"></span><br><span class="line">all_free_cpu_m=$(echo &quot;$all_alloc_cpu_m - $all_used_cpu_m&quot; | bc)</span><br><span class="line">all_free_mem_mi=$(echo &quot;$all_alloc_mem_mi - $all_used_mem_mi&quot; | bc)</span><br><span class="line"></span><br><span class="line">echo -e &quot;CPU:&quot;</span><br><span class="line">echo -e &quot;  集群可分配CPU:      $&#123;all_alloc_cpu_m&#125;m&quot;</span><br><span class="line">echo -e &quot;  集群已分配CPU:      $&#123;all_used_cpu_m&#125;m&quot;</span><br><span class="line">echo -e &quot;  集群剩余可分配CPU:  $&#123;all_free_cpu_m&#125;m&quot;</span><br><span class="line">echo -e &quot;内存:&quot;</span><br><span class="line">echo -e &quot;  集群可分配内存:     $&#123;all_alloc_mem_mi&#125;Mi&quot;</span><br><span class="line">echo -e &quot;  集群已分配内存:     $&#123;all_used_mem_mi&#125;Mi&quot;</span><br><span class="line">echo -e &quot;  集群剩余可分配内存: $&#123;all_free_mem_mi&#125;Mi&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="prometheus-统计（promql-demo）"><a href="#prometheus-统计（promql-demo）" class="headerlink" title="prometheus 统计（promql demo）"></a>prometheus 统计（promql demo）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#统计节点资源碎片能分配多少的2核的pod</span><br><span class="line">floor((sum(kube_node_status_allocatable&#123;cluster=~&quot;$cluster&quot;,node=~&quot;$node&quot;,resource=&quot;cpu&quot;&#125;) by (node) - </span><br><span class="line">       sum(kube_pod_container_resource_requests&#123;cluster=~&quot;$cluster&quot;, node=~&quot;$node&quot;,resource=&quot;cpu&quot;&#125;) by (node)) / 2) &gt; 0</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下openssl自签证书及证书链</title>
    <url>/2025/05/13/mac%E4%B8%8Bopenssl%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6%E5%8F%8A%E8%AF%81%E4%B9%A6%E9%93%BE/</url>
    <content><![CDATA[<h2 id="签名及证书链"><a href="#签名及证书链" class="headerlink" title="签名及证书链"></a>签名及证书链</h2><ul>
<li>证书签名<br><img src="https://raw.githubusercontent.com/shispring/picgo/master/sign-cert-1.png" alt="证书签名" title="Certificate"></li>
<li>证书链<br><img src="https://raw.githubusercontent.com/shispring/picgo/master/sign-cert.png" alt="证书链" title="Certificate Chain"></li>
</ul>
<hr>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#安装openssl</span><br><span class="line">brew install openssl</span><br><span class="line"></span><br><span class="line">#查看版本信息</span><br><span class="line">/opt/homebrew/bin/openssl version -a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#私钥生成</span><br><span class="line">openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:P-256 &gt; private_key.pem</span><br><span class="line">解释：</span><br><span class="line">genpkey ：生成私钥。openssl openssl 提供了 genrsa 和 gendsa 子命令来生成 RSA/DSA 私钥，但它们已被 genpkey 取代。</span><br><span class="line">-algorithm EC ：使用椭圆曲线算法。请注意，使用时 -algorithm 选项必须位于 -pkeyopt 选项之前。</span><br><span class="line">-pkeyopt ec_paramgen_curve:P-256 ：使用 P-256 曲线，这是椭圆曲线算法特有的参数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#私钥内容</span><br><span class="line">openssl pkey -text -noout -in private_key.pem</span><br><span class="line"></span><br><span class="line">#将密钥格式从 PEM 转换为 JWK （ RFC 7517 ）</span><br><span class="line">sudo npm install -g eckles</span><br><span class="line">eckles private_key.pem &gt; private_key.jwk</span><br><span class="line">cat private_key.jwk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#从 PEM 格式的私钥中提取公钥</span><br><span class="line">openssl pkey -pubout -in private_key.pem &gt; public_key.pem</span><br><span class="line"></span><br><span class="line">#将公钥格式从 PEM 转换为 JWK</span><br><span class="line">eckles public_key.pem &gt; public_key.jwk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#自签名证书</span><br><span class="line">openssl req -x509 -key private_key.pem -subj /CN=Client.example.com &gt; certificate.pem</span><br><span class="line">解释：</span><br><span class="line">req -x509 ：生成自签名的 X.509 证书。</span><br><span class="line">-key private_key.pem ：指定用于签名的私钥和目标公钥</span><br><span class="line">-subj /CN=client.example.com ：指定主体可分辨名称。如果未指定 -subj 选项， openssl 命令会提示您以交互方式输入主体可分辨名称。</span><br><span class="line">-days ：如果未指定有效期限，则使用 30 天作为默认值。可以使用 -days 选项指定有效期限（以天为单位）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#证书内容</span><br><span class="line">openssl x509 -text -noout -in certificate.pem</span><br><span class="line">解释：</span><br><span class="line">-text ：以纯文本形式显示信息。</span><br><span class="line">-text ：以纯文本形式显示信息。</span><br><span class="line">-noout ：抑制编码输出。</span><br><span class="line">-in certificate.pem ：指定输入文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#注意：</span><br><span class="line">自签名的证书：因此颁发者（Issuer）和主体(Subject)是相同的。目标公钥的信息包含在主体公钥信息块中。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p><a href="https://darutk.medium.com/illustrated-x-509-certificate-84aece2c5c2e">https://darutk.medium.com/illustrated-x-509-certificate-84aece2c5c2e</a></p>
</blockquote>
<hr>
<h2 id="证书信息"><a href="#证书信息" class="headerlink" title="证书信息"></a>证书信息</h2><ul>
<li>通过域名及ip查询证书情况<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 脚本参数</span><br><span class="line">IP=&quot;10.228.xxx.xxx&quot;</span><br><span class="line">DOMAIN=&quot;k8s.xxx.net&quot;</span><br><span class="line">PORT=443</span><br><span class="line"></span><br><span class="line"># 获取证书并输出</span><br><span class="line">echo &quot;获取证书信息 from $DOMAIN ($IP:$PORT)...&quot;</span><br><span class="line">CERT_INFO=$(openssl s_client -servername &quot;$DOMAIN&quot; -connect &quot;$IP:$PORT&quot; &lt; /dev/null 2&gt;/dev/null | openssl x509 -noout -text)</span><br><span class="line"></span><br><span class="line">if [[ -z &quot;$CERT_INFO&quot; ]]; then</span><br><span class="line">  echo &quot;❌ 获取证书失败，请检查 IP、端口 或 域名是否正确&quot;</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 提取关键信息</span><br><span class="line">ISSUER=$(echo &quot;$CERT_INFO&quot; | grep &quot;Issuer:&quot; | head -n 1 | sed &#x27;s/.*Issuer: //&#x27;)</span><br><span class="line">SUBJECT=$(echo &quot;$CERT_INFO&quot; | grep &quot;Subject:&quot; | head -n 1 | sed &#x27;s/.*Subject: //&#x27;)</span><br><span class="line">NOT_BEFORE=$(echo &quot;$CERT_INFO&quot; | grep &quot;Not Before&quot; | sed &#x27;s/ *Not Before: //&#x27;)</span><br><span class="line">NOT_AFTER=$(echo &quot;$CERT_INFO&quot; | grep &quot;Not After&quot; | sed &#x27;s/ *Not After : //&#x27;)</span><br><span class="line">SIGNATURE_ALG=$(echo &quot;$CERT_INFO&quot; | grep &quot;Signature Algorithm&quot; | head -n 1 | awk -F&#x27;: &#x27; &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">SAN=$(echo &quot;$CERT_INFO&quot; | grep -A1 &quot;Subject Alternative Name&quot; | tail -n1 | sed &#x27;s/ *DNS://g&#x27; | tr &#x27;,&#x27; &#x27;\n&#x27; | sed &#x27;s/^/    - /&#x27;)</span><br><span class="line"></span><br><span class="line"># 输出关键信息</span><br><span class="line">echo &quot;&quot;</span><br><span class="line">echo &quot;证书信息：&quot;</span><br><span class="line">echo &quot;Issuer       : $ISSUER&quot;</span><br><span class="line">echo &quot;Subject      : $SUBJECT&quot;</span><br><span class="line">echo &quot;Valid From   : $NOT_BEFORE&quot;</span><br><span class="line">echo &quot;Valid Until  : $NOT_AFTER&quot;</span><br><span class="line">echo &quot;Signature Alg: $SIGNATURE_ALG&quot;</span><br><span class="line">echo &quot;SAN List     :&quot;</span><br><span class="line">echo &quot;$SAN&quot;</span><br></pre></td></tr></table></figure></li>
<li>使用curl请求<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用 --resolve 伪造 DNS，把域名解析为指定 IP，同时请求的 URL 仍然是域名，证书验证正常：</span><br><span class="line">curl -v --resolve app.test.com:443:101.199.xxx.xxx https://app.test.com/</span><br><span class="line"></span><br><span class="line">#使用 --connect-to（等价替代）</span><br><span class="line">curl -v --connect-to app.test.com:443:101.199.xxx.xxx:443 https://app.test.com/</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>cursor</title>
    <url>/2025/05/14/cursor/</url>
    <content><![CDATA[<h2 id="续杯cursor"><a href="#续杯cursor" class="headerlink" title="续杯cursor"></a>续杯cursor</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">youtube教程地址：https://www.youtube.com/watch?v=qDLePOI9LI0</span><br><span class="line">1、退出Cursor IDE里账户</span><br><span class="line">2、删除Cursor官网： https://www.cursor.com/settings 里google账户</span><br><span class="line">Account --&gt; Advanced --&gt; Delete Account</span><br><span class="line">3、登录github运行go-cursor-help里脚本</span><br><span class="line">  https://github.com/yuaotian/go-cursor-help</span><br><span class="line">  # Method two</span><br><span class="line">  命令： curl -fsSL https://aizaozao.com/accelerate.php/https://raw.githubusercontent.com/yuaotian/go-cursor-help/refs/heads/master/scripts/run/cursor_mac_id_modifier.sh -o ./cursor_mac_id_modifier.sh &amp;&amp; sudo bash ./cursor_mac_id_modifier.sh &amp;&amp; rm ./cursor_mac_id_modifier.sh</span><br><span class="line">4、运行cursor-free-vip</span><br><span class="line">  github地址： https://github.com/yeongpin/cursor-free-vip</span><br><span class="line">  执行命令：curl -fsSL https://raw.githubusercontent.com/yeongpin/cursor-free-vip/main/scripts/install.sh -o install.sh &amp;&amp; chmod +x install.sh &amp;&amp; ./install.sh</span><br><span class="line">  #重置机器ID</span><br><span class="line">  请输入您的选择 (0-17): 1</span><br><span class="line">5、登录Cursor官网--&gt;sign up （google的无限邮箱模式）</span><br><span class="line">6、登录google账户输入验证码</span><br><span class="line">7、在Cursor IDE里登录</span><br><span class="line">  Cursor --&gt; Preferences --&gt; Cursor Settings --&gt; Account</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>自动选择部署测试job</title>
    <url>/2025/05/14/%E8%87%AA%E5%8A%A8%E9%80%89%E6%8B%A9%E9%83%A8%E7%BD%B2%E6%B5%8B%E8%AF%95job/</url>
    <content><![CDATA[<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># Color definitions</span><br><span class="line">RED=&#x27;\033[0;31m&#x27;</span><br><span class="line">GREEN=&#x27;\033[0;32m&#x27;</span><br><span class="line">YELLOW=&#x27;\033[0;33m&#x27;</span><br><span class="line">BLUE=&#x27;\033[0;34m&#x27;</span><br><span class="line">CYAN=&#x27;\033[0;36m&#x27;</span><br><span class="line">NC=&#x27;\033[0m&#x27; # No Color</span><br><span class="line"></span><br><span class="line"># ======================</span><br><span class="line"># 镜像菜单</span><br><span class="line"># 镜像加速： https://github.com/DaoCloud/public-image-mirror</span><br><span class="line"># ======================</span><br><span class="line"></span><br><span class="line">sleepTime=3600</span><br><span class="line"></span><br><span class="line">options=(</span><br><span class="line">    &quot;netshoot&quot;</span><br><span class="line">    &quot;busybox&quot;</span><br><span class="line">    &quot;dnstools&quot;</span><br><span class="line">    &quot;退出&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">context=`kubectl config current-context`</span><br><span class="line">namespace=`kubectl config view --minify --output &quot;jsonpath=&#123;..namespace&#125;&quot;`</span><br><span class="line">echo -e &quot;$&#123;YELLOW&#125;Notice: 当前集群为：$&#123;context&#125; $&#123;NC&#125;&quot;</span><br><span class="line">echo -e &quot;$&#123;YELLOW&#125;Notice: 当前namespace为：$&#123;namespace&#125; $&#123;NC&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo -e &quot;$&#123;CYAN&#125;ℹ️ 请选择要部署的测试 Job：$&#123;NC&#125;&quot;</span><br><span class="line"></span><br><span class="line">for i in &quot;$&#123;!options[@]&#125;&quot;; do</span><br><span class="line">    echo &quot;$((i+1)). $&#123;options[i]&#125;&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read -p &quot;请输入选项编号: &quot; choice</span><br><span class="line"></span><br><span class="line">case $choice in</span><br><span class="line">  1)</span><br><span class="line">    NAME=&quot;netshoot-test&quot;</span><br><span class="line">    IMAGE=&quot;docker.m.daocloud.io/docker.io/nicolaka/netshoot:latest&quot;</span><br><span class="line">    ;;</span><br><span class="line">  2)</span><br><span class="line">    NAME=&quot;dnstools-test&quot;</span><br><span class="line">    IMAGE=&quot;docker.m.daocloud.io/docker.io/infoblox/dnstools:latest&quot;</span><br><span class="line">    ;;</span><br><span class="line">  3)</span><br><span class="line">    NAME=&quot;busybox-test&quot;</span><br><span class="line">    IMAGE=&quot;docker.m.daocloud.io/docker.io/library/busybox:latest&quot;</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    echo -e &quot;$&#123;RED&#125;❌ 无效选项$&#123;NC&#125;&quot; ; exit 1;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ======================</span><br><span class="line"># 应用 Job YAML</span><br><span class="line"># ======================</span><br><span class="line">echo -e &quot;$&#123;GREEN&#125;正在创建 Job：$&#123;NAME&#125; $&#123;NC&#125;&quot;</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF | kubectl apply -f -</span><br><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: $&#123;NAME&#125;</span><br><span class="line">spec:</span><br><span class="line">  ttlSecondsAfterFinished: 300  # ✅ Job 成功后 5 分钟自动清理</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: $&#123;NAME&#125;</span><br><span class="line">        image: $&#123;IMAGE&#125;</span><br><span class="line">        command: [&quot;sh&quot;, &quot;-c&quot;, &quot;echo &#x27;Running $&#123;sleepTime&#125; seconds ...&#x27; &amp;&amp; sleep $&#123;sleepTime&#125; &quot;]</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            cpu: &quot;1&quot;</span><br><span class="line">            memory: 1Gi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 100Mi</span><br><span class="line">      restartPolicy: Never</span><br><span class="line">      dnsPolicy: ClusterFirst</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">echo -e &quot;$&#123;GREEN&#125;✅ Job 创建成功。当运行 $&#123;sleepTime&#125; 秒后，会在5分钟后自动清理 ... $&#123;NC&#125;&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>高质量shell脚本tips</title>
    <url>/2025/05/21/shell%E8%84%9A%E6%9C%AC%E5%8A%A0%E5%9B%BA%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h3 id="shell-目标"><a href="#shell-目标" class="headerlink" title="shell 目标"></a>shell 目标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">严谨、健壮、自检、自愈、可读</span><br></pre></td></tr></table></figure>
<h3 id="首行加固"><a href="#首行加固" class="headerlink" title="首行加固"></a>首行加固</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set -euo pipefail</span><br></pre></td></tr></table></figure>

<h3 id="安全读取变量"><a href="#安全读取变量" class="headerlink" title="安全读取变量"></a>安全读取变量</h3><table>
<thead>
<tr>
<th>${VAR:-}</th>
<th>如果未定义，返回空字符串</th>
</tr>
</thead>
<tbody><tr>
<td>${VAR:&#x3D;默认}</td>
<td>如果未定义，赋值为默认值</td>
</tr>
<tr>
<td>${VAR:+替代}</td>
<td>如果已定义，返回替代值</td>
</tr>
<tr>
<td>${VAR:?错误信息}</td>
<td>如果未定义，抛出指定错误</td>
</tr>
</tbody></table>
<h3 id="让路径永远基于脚本本身，无论哪里执行都正确"><a href="#让路径永远基于脚本本身，无论哪里执行都正确" class="headerlink" title="让路径永远基于脚本本身，无论哪里执行都正确"></a>让路径永远基于脚本本身，无论哪里执行都正确</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)&quot; &amp;&amp; pwd)&quot;</span><br><span class="line">cd &quot;$SCRIPT_DIR&quot;</span><br></pre></td></tr></table></figure>

<h3 id="检查命令执行结果"><a href="#检查命令执行结果" class="headerlink" title="检查命令执行结果"></a>检查命令执行结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#优雅的写法</span><br><span class="line">wget xxx || &#123; echo &quot;下载失败&quot;; exit 1; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="保持脚本输出清晰简洁，尤其是日志信息"><a href="#保持脚本输出清晰简洁，尤其是日志信息" class="headerlink" title="保持脚本输出清晰简洁，尤其是日志信息"></a>保持脚本输出清晰简洁，尤其是日志信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、打印正在做什么</span><br><span class="line">2、成功/失败都提示</span><br><span class="line">3、错误信息清晰</span><br></pre></td></tr></table></figure>

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p><a href="https://mp.weixin.qq.com/s/lBAsqOIB72FtawjckiVrDg">https://mp.weixin.qq.com/s/lBAsqOIB72FtawjckiVrDg</a> </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">set -euo pipefail</span><br><span class="line"></span><br><span class="line">SCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)&quot; &amp;&amp; pwd)&quot;</span><br><span class="line">cd &quot;$SCRIPT_DIR&quot;</span><br><span class="line"></span><br><span class="line"># 加载.env</span><br><span class="line">if [ -f &quot;.env&quot; ]; then</span><br><span class="line">    export $(grep -v &#x27;^#&#x27; .env | xargs)</span><br><span class="line">else</span><br><span class="line">    echo &quot;❌ .env文件不存在&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 示例逻辑</span><br><span class="line">echo &quot;🚀 开始任务...&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="颜色配置"><a href="#颜色配置" class="headerlink" title="颜色配置"></a>颜色配置</h3><ul>
<li>mac下兼容 Bash 3 的方式：用 case + if else 实现颜色映射<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">set -euo pipefail</span><br><span class="line"># 颜色定义</span><br><span class="line">readonly RED=&#x27;\033[0;31m&#x27;</span><br><span class="line">readonly GREEN=&#x27;\033[0;32m&#x27;</span><br><span class="line">readonly YELLOW=&#x27;\033[0;33m&#x27;</span><br><span class="line">readonly BLUE=&#x27;\033[0;34m&#x27;</span><br><span class="line">readonly NC=&#x27;\033[0m&#x27; # No Color</span><br><span class="line"></span><br><span class="line"># 日志函数</span><br><span class="line">log() &#123;</span><br><span class="line">    local level=$1</span><br><span class="line">    shift</span><br><span class="line">    local timestamp=$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">    local message=&quot;[$&#123;timestamp&#125;] [$&#123;level&#125;] $*&quot;</span><br><span class="line"></span><br><span class="line">    case &quot;$level&quot; in</span><br><span class="line">        &quot;ERROR&quot;) color=$RED ;;</span><br><span class="line">        &quot;WARNING&quot;) color=$YELLOW ;;</span><br><span class="line">        &quot;INFO&quot;) color=$BLUE ;;</span><br><span class="line">        &quot;SUCCESS&quot;) color=$GREEN ;;</span><br><span class="line">        *) color=$NC ;;</span><br><span class="line">    esac</span><br><span class="line"></span><br><span class="line">    echo -e &quot;$&#123;color&#125;$&#123;message&#125;$&#123;NC&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log &quot;SUCCESS&quot; &quot;✅ All done.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>linux下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">set -euo pipefail</span><br><span class="line"></span><br><span class="line"># 颜色定义</span><br><span class="line">readonly RED=&#x27;\033[0;31m&#x27;</span><br><span class="line">readonly GREEN=&#x27;\033[0;32m&#x27;</span><br><span class="line">readonly YELLOW=&#x27;\033[0;33m&#x27;</span><br><span class="line">readonly BLUE=&#x27;\033[0;34m&#x27;</span><br><span class="line">readonly NC=&#x27;\033[0m&#x27;</span><br><span class="line"></span><br><span class="line"># 日志级别颜色映射</span><br><span class="line">declare -A LOG_COLORS=(</span><br><span class="line">    [&quot;ERROR&quot;]=&quot;$&#123;RED&#125;&quot;</span><br><span class="line">    [&quot;WARNING&quot;]=&quot;$&#123;YELLOW&#125;&quot;</span><br><span class="line">    [&quot;INFO&quot;]=&quot;$&#123;BLUE&#125;&quot;</span><br><span class="line">    [&quot;SUCCESS&quot;]=&quot;$&#123;GREEN&#125;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 日志函数</span><br><span class="line">log() &#123;</span><br><span class="line">    local level=$1</span><br><span class="line">    shift</span><br><span class="line">    local color=$&#123;LOG_COLORS[$level]:-$NC&#125;</span><br><span class="line">    local timestamp=$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">    local message=&quot;[$&#123;timestamp&#125;] [$&#123;level&#125;] $*&quot;</span><br><span class="line">    echo -e &quot;$&#123;color&#125;$&#123;message&#125;$&#123;NC&#125;&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log INFO &quot;这是信息日志&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>controller工作机制</title>
    <url>/2025/05/26/controller%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Kubernetes-Controller-工作机制解析"><a href="#Kubernetes-Controller-工作机制解析" class="headerlink" title="Kubernetes Controller 工作机制解析"></a>Kubernetes Controller 工作机制解析</h1><blockquote>
<p><a href="https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go">https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go</a></p>
</blockquote>
<h2 id="控制器核心组件"><a href="#控制器核心组件" class="headerlink" title="控制器核心组件"></a>控制器核心组件</h2><h3 id="1-初始化配置-Configuration"><a href="#1-初始化配置-Configuration" class="headerlink" title="1. 初始化配置 (Configuration)"></a>1. 初始化配置 (Configuration)</h3><ul>
<li>通过kubeconfig文件或in-cluster配置初始化与API Server的连接</li>
<li>创建clientset用于与Kubernetes API交互</li>
</ul>
<h3 id="2-资源监听器设置-Resource-Watcher"><a href="#2-资源监听器设置-Resource-Watcher" class="headerlink" title="2. 资源监听器设置 (Resource Watcher)"></a>2. 资源监听器设置 (Resource Watcher)</h3><ul>
<li>创建ListWatch，指定要监听的资源类型(如Pod)和范围(如命名空间)</li>
<li>ListWatch负责与API Server建立连接，监听资源变化</li>
</ul>
<h3 id="3-工作队列创建-Workqueue"><a href="#3-工作队列创建-Workqueue" class="headerlink" title="3. 工作队列创建 (Workqueue)"></a>3. 工作队列创建 (Workqueue)</h3><ul>
<li>创建RateLimitingQueue作为工作队列</li>
<li>队列支持限速重试，防止资源过度消耗</li>
<li>确保并发安全的事件处理</li>
</ul>
<h3 id="4-缓存和事件处理器配置-Cache-Informer"><a href="#4-缓存和事件处理器配置-Cache-Informer" class="headerlink" title="4. 缓存和事件处理器配置 (Cache &amp; Informer)"></a>4. 缓存和事件处理器配置 (Cache &amp; Informer)</h3><ul>
<li>创建Indexer作为本地缓存，存储资源对象</li>
<li>创建Informer监听资源变化并更新本地缓存</li>
<li>设置事件处理函数(Add&#x2F;Update&#x2F;Delete)，将变化的资源键加入工作队列</li>
</ul>
<h3 id="5-控制器组装-Controller-Assembly"><a href="#5-控制器组装-Controller-Assembly" class="headerlink" title="5. 控制器组装 (Controller Assembly)"></a>5. 控制器组装 (Controller Assembly)</h3><ul>
<li>将队列(queue)、缓存(indexer)和监听器(informer)组装成控制器</li>
<li>形成完整的事件处理流水线</li>
<li>控制器负责协调这些组件的工作</li>
</ul>
<h3 id="6-业务逻辑处理-Business-Logic"><a href="#6-业务逻辑处理-Business-Logic" class="headerlink" title="6. 业务逻辑处理 (Business Logic)"></a>6. 业务逻辑处理 (Business Logic)</h3><ul>
<li>processNextItem不断从队列获取待处理项</li>
<li>通过indexer从本地缓存获取最新的资源状态</li>
<li>执行具体的业务逻辑(如本例中的打印资源信息)</li>
<li>处理完成后从队列中移除，失败则重新入队</li>
</ul>
<h2 id="详细工作流程"><a href="#详细工作流程" class="headerlink" title="详细工作流程"></a>详细工作流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                    ┌─── 1. List/Watch 请求 ───┐</span><br><span class="line">                    │                          ▼</span><br><span class="line">API Server ←──────► ListWatch ─────────► Informer</span><br><span class="line">                                          │</span><br><span class="line">                    ┌─────────────────────┘</span><br><span class="line">                    │</span><br><span class="line">                    ▼</span><br><span class="line">                2. 更新本地缓存</span><br><span class="line">                 Indexer</span><br><span class="line">                    │</span><br><span class="line">                    │                  4. 从缓存读取</span><br><span class="line">                    │                      ┌───────────────┐</span><br><span class="line">                    ▼                      │               │</span><br><span class="line">3. 触发 ────► EventHandler ────► Workqueue ────► Controller</span><br><span class="line">                                                Business Logic</span><br></pre></td></tr></table></figure>

<h3 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h3><ol>
<li><p><strong>Informer与API Server的交互</strong></p>
<ul>
<li>首先通过List获取资源的完整列表</li>
<li>然后通过Watch监听资源的变化事件</li>
</ul>
</li>
<li><p><strong>Informer更新本地缓存</strong></p>
<ul>
<li>收到List响应时，将资源列表存入Indexer</li>
<li>收到Watch事件时，相应更新Indexer中的数据</li>
<li>Indexer始终保持与服务器端数据的同步</li>
</ul>
</li>
<li><p><strong>事件处理流程</strong></p>
<ul>
<li>当收到事件时，调用相应的EventHandler(Add&#x2F;Update&#x2F;Delete)</li>
<li>EventHandler将资源的key放入WorkQueue</li>
<li>EventHandler不直接操作Indexer</li>
</ul>
</li>
<li><p><strong>控制器业务处理</strong></p>
<ul>
<li>从WorkQueue取出要处理的资源key</li>
<li>通过key从Indexer(本地缓存)中获取资源的最新状态</li>
<li>执行具体的业务逻辑</li>
</ul>
</li>
</ol>
<h2 id="设计优点"><a href="#设计优点" class="headerlink" title="设计优点"></a>设计优点</h2><ol>
<li><p><strong>数据一致性</strong></p>
<ul>
<li>Indexer的更新由Informer直接负责</li>
<li>确保缓存与服务器端的一致性</li>
</ul>
</li>
<li><p><strong>职责分离</strong></p>
<ul>
<li>EventHandler只负责将事件对应的key放入队列</li>
<li>各组件职责单一，界限清晰</li>
</ul>
</li>
<li><p><strong>性能优化</strong></p>
<ul>
<li>业务逻辑通过Indexer读取数据</li>
<li>避免频繁访问API Server</li>
</ul>
</li>
<li><p><strong>可靠性</strong></p>
<ul>
<li>支持失败重试和限速机制</li>
<li>确保资源状态的最终一致性</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>从main.go文件到部署k8s集群的步骤</title>
    <url>/2025/05/26/%E4%BB%8Emain-go%E6%96%87%E4%BB%B6%E5%88%B0%E9%83%A8%E7%BD%B2k8s%E9%9B%86%E7%BE%A4%E7%9A%84%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h2 id="1、初始化-Go-Modules"><a href="#1、初始化-Go-Modules" class="headerlink" title="1、初始化 Go Modules"></a>1、初始化 Go Modules</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go mod init myapp</span><br><span class="line">go mod tidy</span><br><span class="line"></span><br><span class="line">#注意</span><br><span class="line">.</span><br><span class="line">├── main.go</span><br><span class="line">├── go.mod      &lt;-- 必须有</span><br><span class="line">├── go.sum      &lt;-- 自动生成</span><br><span class="line">├── Dockerfile</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>go mod init myapp：初始化模块，生成 go.mod</li>
<li>go mod tidy：自动下载并写入依赖</li>
</ul>
<p>💡 如果你的 main.go 依赖了一些 k8s.io&#x2F;client-go 等模块，这个步骤会自动下载并记录这些依赖。</p>
<h2 id="2、最佳-Dockerfile（支持依赖构建）"><a href="#2、最佳-Dockerfile（支持依赖构建）" class="headerlink" title="2、最佳 Dockerfile（支持依赖构建）"></a>2、最佳 Dockerfile（支持依赖构建）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 第一阶段：构建 Go 应用</span><br><span class="line">FROM golang:1.24.0 as builder</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 复制 go.mod 和 go.sum，先下载依赖（避免每次构建都拉取）</span><br><span class="line">COPY go.mod go.sum ./</span><br><span class="line">RUN go mod download</span><br><span class="line"></span><br><span class="line"># 复制源码</span><br><span class="line">COPY main.go .</span><br><span class="line"></span><br><span class="line"># 构建静态二进制</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o app main.go</span><br><span class="line"></span><br><span class="line"># 第二阶段：构建最小运行镜像</span><br><span class="line">FROM alpine:latest</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=builder /app/app .</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./app&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="3、构建并推送镜像"><a href="#3、构建并推送镜像" class="headerlink" title="3、构建并推送镜像"></a>3、构建并推送镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t harbor.yourdomain.com/your-project/workqueue:latest .</span><br><span class="line"></span><br><span class="line">#注意替换变量</span><br><span class="line">echo &quot;$AUTH_PASS&quot; | docker login &quot;$DEST_REGISTRY&quot; -u &quot;$AUTH_USER&quot; --password-stdin || &#123; log &quot;登录失败&quot;; exit 1; &#125;</span><br><span class="line"></span><br><span class="line">docker push harbor.yourdomain.com/your-project/workqueue:latest</span><br></pre></td></tr></table></figure>
<h2 id="4、运行kubectl命令"><a href="#4、运行kubectl命令" class="headerlink" title="4、运行kubectl命令"></a>4、运行kubectl命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl run workqueue --rm -it --restart=Never --namespace=default --image=harbor.yourdomain.com/your-project/workqueue:latest</span><br><span class="line"></span><br><span class="line">✅ 使用场景说明</span><br><span class="line">•临时创建 Pod 来调试代码、API、网络连通性等</span><br><span class="line">•不需要 Deployment 或长期运行的 Pod</span><br><span class="line">•用完即删，保持集群整洁</span><br><span class="line">•常用于开发测试阶段、快速验证镜像是否能正常运行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">私有仓库：</span><br><span class="line">kubectl create secret docker-registry my-harbor-secret \</span><br><span class="line">  --docker-server=harborqa.xxx.xxx \</span><br><span class="line">  --docker-username=&lt;你的用户名&gt; \</span><br><span class="line">  --docker-password=&lt;你的密码&gt; </span><br><span class="line"></span><br><span class="line">kubectl run workqueue \</span><br><span class="line">  --rm -it \</span><br><span class="line">  --restart=Never \</span><br><span class="line">  --image=harbor.yourdomain.com/your-project/workqueue:latest \</span><br><span class="line">  --namespace=default \</span><br><span class="line">  --image-pull-secrets=my-harbor-secret</span><br></pre></td></tr></table></figure>

<h2 id="5、注意ServiceAccount权限-测试"><a href="#5、注意ServiceAccount权限-测试" class="headerlink" title="5、注意ServiceAccount权限(测试)"></a>5、注意ServiceAccount权限(测试)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  name: pod-reader</span><br><span class="line">  namespace: default</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;pods&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: read-pods-binding</span><br><span class="line">  namespace: default</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: default   # 就是报错里的 default</span><br><span class="line">  namespace: default</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: pod-reader</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure>
<ul>
<li>kubectl apply -f rbac.yaml</li>
</ul>
<h2 id="参看"><a href="#参看" class="headerlink" title="参看"></a>参看</h2><blockquote>
<p><a href="https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go">https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试</title>
    <url>/2025/06/09/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="单元测试的标准与最佳实践"><a href="#单元测试的标准与最佳实践" class="headerlink" title="单元测试的标准与最佳实践"></a>单元测试的标准与最佳实践</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. **函数命名规范**  </span><br><span class="line">   测试函数必须以 Test 开头，后跟要测试的函数名或功能点</span><br><span class="line">2. **测试用例覆盖**  </span><br><span class="line">   - 覆盖正常情况、边界情况、异常情况。</span><br><span class="line">   - 尽量覆盖所有分支和逻辑路径。</span><br><span class="line">3. **结构清晰**  </span><br><span class="line">   - 使用 table-driven 测试（表驱动测试），便于添加和维护用例。</span><br><span class="line">   - 测试用例结构体字段要表达清楚输入、期望输出。</span><br><span class="line">4. **断言明确**  </span><br><span class="line">   - 使用 t.Errorf 或 t.Fatalf 明确指出期望与实际的差异。</span><br><span class="line">   - 错误信息要有可读性，便于定位问题。</span><br><span class="line">5. **独立性**  </span><br><span class="line">   - 每个测试用例应相互独立，不能依赖其他测试的执行结果。</span><br><span class="line">   - 尽量避免全局变量或外部依赖。</span><br><span class="line">6. **可读性与可维护性**  </span><br><span class="line">   - 变量命名清晰，结构体字段含义明确。</span><br><span class="line">   - 适当注释复杂逻辑。</span><br><span class="line">7. **自动化**  </span><br><span class="line">   - 测试应能自动运行，且不需要人工干预。</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="测试模式分类"><a href="#测试模式分类" class="headerlink" title="测试模式分类"></a>测试模式分类</h2><h3 id="1-表驱动测试（table-driven-test）"><a href="#1-表驱动测试（table-driven-test）" class="headerlink" title="1. 表驱动测试（table-driven test）"></a>1. 表驱动测试（table-driven test）</h3><ul>
<li>是 Go 语言社区非常推崇的一种测试模式。它的核心思想是：  </li>
<li>把一组输入和期望输出写成一个“表”（通常是切片或数组），然后用循环依次执行每组用例。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这样做的好处是：  </span><br><span class="line">- 结构清晰，易于维护和扩展  </span><br><span class="line">- 新增用例只需加一行数据  </span><br><span class="line">- 代码更简洁，避免重复</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="表驱动测试的基本结构"><a href="#表驱动测试的基本结构" class="headerlink" title="表驱动测试的基本结构"></a>表驱动测试的基本结构</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义测试用例表</span></span><br><span class="line">    tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="type">string</span>    <span class="comment">// 用例名称</span></span><br><span class="line">        a, b <span class="type">int</span>       <span class="comment">// 输入参数</span></span><br><span class="line">        want <span class="type">int</span>       <span class="comment">// 期望输出</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;<span class="string">&quot;正数相加&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;负数相加&quot;</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;正负相加&quot;</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;零相加&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历表，逐个执行</span></span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            got := Add(tt.a, tt.b)</span><br><span class="line">            <span class="keyword">if</span> got != tt.want &#123;</span><br><span class="line">                t.Errorf(<span class="string">&quot;Add(%d, %d) = %d, want %d&quot;</span>, tt.a, tt.b, got, tt.want)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被测试的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>输入输出明确、参数组合多的函数</li>
<li>需要覆盖多种边界情况的逻辑</li>
</ul>
<hr>
<h3 id="2-子测试（Subtests）"><a href="#2-子测试（Subtests）" class="headerlink" title="2.子测试（Subtests）"></a>2.子测试（Subtests）</h3><ul>
<li><strong>简介</strong>：使用 <code>t.Run</code> 创建子测试，便于分组、并发和独立执行。</li>
<li><strong>优点</strong>：可以单独运行某个子测试，输出更清晰。</li>
<li><strong>示例</strong>：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSomething</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Run(<span class="string">&quot;case1&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 测试逻辑</span></span><br><span class="line">    &#125;)</span><br><span class="line">    t.Run(<span class="string">&quot;case2&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 测试逻辑</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-基准测试（Benchmark）"><a href="#3-基准测试（Benchmark）" class="headerlink" title="3.基准测试（Benchmark）"></a>3.基准测试（Benchmark）</h3><ul>
<li><strong>简介</strong>：以 <code>Benchmark</code> 开头的函数，用于性能测试。</li>
<li><strong>规范</strong>：函数签名为 <code>func(b *testing.B)</code>，通过循环多次执行被测代码。</li>
<li><strong>示例</strong>：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-并发测试（Parallel-Test）"><a href="#4-并发测试（Parallel-Test）" class="headerlink" title="4.并发测试（Parallel Test）"></a>4.并发测试（Parallel Test）</h3><ul>
<li><strong>简介</strong>：使用 <code>t.Parallel()</code> 让测试用例并发执行，检测并发安全问题。</li>
<li><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例</strong>：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestParallel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Parallel()</span><br><span class="line">    <span class="comment">// 并发相关测试逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2></li>
</ul>
<h3 id="5-测试覆盖率（Coverage）"><a href="#5-测试覆盖率（Coverage）" class="headerlink" title="5. 测试覆盖率（Coverage）"></a>5. 测试覆盖率（Coverage）</h3><ul>
<li><strong>简介</strong>：通过 <code>go test -cover</code> 查看测试覆盖率，确保代码质量。</li>
<li><strong>建议</strong>：覆盖率不是越高越好，但应覆盖核心逻辑和边界情况。</li>
</ul>
<hr>
<h3 id="6-断言库（Assertion-Library）"><a href="#6-断言库（Assertion-Library）" class="headerlink" title="6. 断言库（Assertion Library）"></a>6. 断言库（Assertion Library）</h3><ul>
<li><strong>简介</strong>：使用断言库简化判断和输出，如 <code>github.com/stretchr/testify/assert</code>。</li>
<li><strong>示例</strong>：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    assert.Equal(t, <span class="number">3</span>, Add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="7-Mock-和-Stub"><a href="#7-Mock-和-Stub" class="headerlink" title="7. Mock 和 Stub"></a>7. Mock 和 Stub</h3><ul>
<li><strong>简介</strong>：通过接口和自定义实现，模拟外部依赖（如数据库、网络等），实现隔离测试。</li>
<li><strong>常用库</strong>：<code>github.com/stretchr/testify/mock</code>、<code>golang/mock</code>。</li>
</ul>
<hr>
<h3 id="8-测试文件规范"><a href="#8-测试文件规范" class="headerlink" title="8. 测试文件规范"></a>8. 测试文件规范</h3><ul>
<li>测试文件以 <code>_test.go</code> 结尾。</li>
<li>测试函数以 <code>Test</code>、<code>Benchmark</code>、<code>Example</code> 开头。</li>
<li>测试代码和生产代码分离。</li>
</ul>
<hr>
<h2 id="官方文档与社区资源"><a href="#官方文档与社区资源" class="headerlink" title="官方文档与社区资源"></a>官方文档与社区资源</h2><ul>
<li>Go 官方测试文档：<br><a href="https://pkg.go.dev/testing">https://pkg.go.dev/testing</a></li>
<li>Go 官方标准库 testing 包：<br><a href="https://pkg.go.dev/testing">https://pkg.go.dev/testing</a></li>
<li>Go Blog: Table-driven Tests<br><a href="https://go.dev/wiki/TableDrivenTests">https://go.dev/wiki/TableDrivenTests</a></li>
<li>Go Blog: Subtests and Sub-benchmarks<br><a href="https://go.dev/blog/subtests">https://go.dev/blog/subtests</a></li>
<li>Testify 断言库<br><a href="https://github.com/stretchr/testify">https://github.com/stretchr/testify</a></li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose部署postgres测试</title>
    <url>/2025/06/09/docker-compose%E9%83%A8%E7%BD%B2postgres%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir postgres</span><br><span class="line">cd postgres</span><br><span class="line">docker-compose -f docker-compose.yml up -d</span><br><span class="line">docker ps</span><br><span class="line">#进入容器</span><br><span class="line">docker exec -it bf6c98a18b07 sh</span><br><span class="line">#连接</span><br><span class="line">psql -U admin -d admin</span><br></pre></td></tr></table></figure>
<h2 id="env配置"><a href="#env配置" class="headerlink" title=".env配置"></a>.env配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POSTGRES_USER=admin</span><br><span class="line">POSTGRES_PASSWORD=admin123</span><br><span class="line">POSTGRES_DB=admin</span><br><span class="line">POSTGRES_PORT=5432</span><br></pre></td></tr></table></figure>

<h2 id="docker-compose-yaml"><a href="#docker-compose-yaml" class="headerlink" title="docker-compose.yaml"></a>docker-compose.yaml</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3.5&#x27;</span><br><span class="line">services:</span><br><span class="line">  postgres:</span><br><span class="line">    container_name: postgresql</span><br><span class="line">    image: bitnami/postgresql:latest</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_USER: $&#123;POSTGRES_USER:-admin&#125;</span><br><span class="line">      POSTGRES_PASSWORD: $&#123;POSTGRES_PASSWORD:-admin123&#125;</span><br><span class="line">      POSTGRES_DB: $&#123;POSTGRES_DB:-admin&#125;</span><br><span class="line">      POSTGRES_INITDB_ARGS: &quot;--encoding=UTF8 --lc-collate=en_US.UTF-8 --lc-ctype=en_US.UTF-8&quot;</span><br><span class="line">      TZ: Asia/Shanghai</span><br><span class="line">      LANG: en_US.UTF-8</span><br><span class="line">    privileged: true</span><br><span class="line">    env_file:</span><br><span class="line">      - ./.env</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;$&#123;POSTGRES_PORT&#125;:5432&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - $&#123;PWD&#125;pgdata:/var/lib/postgresql/data:z</span><br><span class="line">      - /etc/localtime:/etc/localtime:ro</span><br><span class="line">      - $&#123;PWD&#125;/tablespace:/tablespace_location:z</span><br><span class="line">      - $&#123;PWD&#125;/log:/var/log/postgresql</span><br><span class="line">    networks:</span><br><span class="line">      - postgres</span><br><span class="line">    restart: always</span><br><span class="line">    hostname: postgresql</span><br><span class="line">networks:</span><br><span class="line">  postgres:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧭-PostgreSQL-与-MySQL-对比表（操作-概念）"><a href="#🧭-PostgreSQL-与-MySQL-对比表（操作-概念）" class="headerlink" title="🧭 PostgreSQL 与 MySQL 对比表（操作&#x2F;概念）"></a>🧭 PostgreSQL 与 MySQL 对比表（操作&#x2F;概念）</h2><table>
<thead>
<tr>
<th>类别</th>
<th>PostgreSQL</th>
<th>MySQL</th>
<th>差异说明</th>
</tr>
</thead>
<tbody><tr>
<td>CLI 工具</td>
<td><code>psql</code></td>
<td><code>mysql</code></td>
<td>使用方式相似，但命令格式略有不同</td>
</tr>
<tr>
<td>查看数据库</td>
<td><code>\l</code></td>
<td><code>SHOW DATABASES;</code></td>
<td>PostgreSQL 使用 <code>\</code> 开头的元命令</td>
</tr>
<tr>
<td>查看表</td>
<td><code>\dt</code></td>
<td><code>SHOW TABLES;</code></td>
<td>MySQL 更偏向 SQL 语句</td>
</tr>
<tr>
<td>查看建表语句</td>
<td><code>pg_dump -s -t 表名</code> 或 <code>\d+ 表名</code></td>
<td><code>SHOW CREATE TABLE 表名;</code></td>
<td>PostgreSQL 没有直接 <code>SHOW CREATE</code> 语法</td>
</tr>
<tr>
<td>切换数据库</td>
<td><code>\c</code></td>
<td><code>USE 数据库名;</code></td>
<td>语法不同</td>
</tr>
<tr>
<td>分隔符设置</td>
<td><code>\pset format</code></td>
<td>无等价命令</td>
<td>PostgreSQL CLI 更强大</td>
</tr>
<tr>
<td>默认字符集</td>
<td><code>UTF-8</code></td>
<td><code>latin1</code>（可改）</td>
<td>PostgreSQL 默认更现代</td>
</tr>
<tr>
<td>JSON 支持</td>
<td>强，原生 JSON、JSONB 类型</td>
<td>有 JSON 类型，但功能弱很多</td>
<td>PostgreSQL 更适合结构+非结构混合存储</td>
</tr>
<tr>
<td>权限模型</td>
<td>支持角色&#x2F;继承&#x2F;细粒度权限</td>
<td>用户权限简单</td>
<td>PostgreSQL 适合大型多租户</td>
</tr>
<tr>
<td>存储引擎</td>
<td>只有 <code>heap</code>（可选 WAL 日志）</td>
<td>多引擎（默认 InnoDB）</td>
<td>MySQL 更灵活但容易不一致</td>
</tr>
</tbody></table>
<hr>
<h2 id="📄-附加内容：PostgreSQL-SQL-模板速查"><a href="#📄-附加内容：PostgreSQL-SQL-模板速查" class="headerlink" title="📄 附加内容：PostgreSQL SQL 模板速查"></a>📄 附加内容：PostgreSQL SQL 模板速查</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    created_at TIMESTAMPTZ <span class="keyword">DEFAULT</span> now()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> example (name, age) <span class="keyword">VALUES</span> (<span class="string">&#x27;Alice&#x27;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新</span></span><br><span class="line"><span class="keyword">UPDATE</span> example <span class="keyword">SET</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> example <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> example <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">25</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JSON 查询</span></span><br><span class="line"><span class="keyword">SELECT</span> data<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;name&#x27;</span> <span class="keyword">FROM</span> json_table <span class="keyword">WHERE</span> data<span class="operator">-</span><span class="operator">&gt;&gt;</span><span class="string">&#x27;age&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;30&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- GIN 索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_json_data <span class="keyword">ON</span> json_table <span class="keyword">USING</span> GIN (data);</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>postgres</tag>
      </tags>
  </entry>
  <entry>
    <title>dlv调试</title>
    <url>/2025/06/12/dlv%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="编译调试"><a href="#编译调试" class="headerlink" title="编译调试"></a>编译调试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#编译二进制</span><br><span class="line">go build -gcflags &quot;all=-N -l&quot; -o main ./main.go</span><br><span class="line">#开启调试</span><br><span class="line">dlv exec ./main</span><br><span class="line">(dlv) break /home/xxx/xxx.go:206</span><br><span class="line">(dlv) continue</span><br><span class="line">(dlv) print ingress</span><br><span class="line">(dlv) locals</span><br><span class="line">(dlv) args</span><br><span class="line">(dlv) exit</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h2><p><img src="https://raw.githubusercontent.com/shispring/picgo/master/20250612160657.png" alt="这是图片" title="dlv"></p>
]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Controller-Runtime日志系统分析</title>
    <url>/2025/06/18/Controller-Runtime%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Controller-Runtime日志系统操作步骤总结"><a href="#Controller-Runtime日志系统操作步骤总结" class="headerlink" title="Controller-Runtime日志系统操作步骤总结"></a>Controller-Runtime日志系统操作步骤总结</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标准流程：</span><br><span class="line"></span><br><span class="line">创建选项 → zap.Options&#123;&#125;</span><br><span class="line">绑定标志 → opts.BindFlags(flag.CommandLine)</span><br><span class="line">解析参数 → flag.Parse()</span><br><span class="line">设置日志器 → ctrl.SetLogger(zap.New(...))</span><br><span class="line"></span><br><span class="line">这个流程的优势：</span><br><span class="line">统一管理：整个controller-runtime生态使用同一日志器</span><br><span class="line">灵活配置：支持命令行动态调整日志行为</span><br><span class="line">标准化：符合Kubernetes生态的日志标准</span><br><span class="line">可观测性：提供结构化日志便于监控和分析</span><br><span class="line"></span><br><span class="line">这是controller-runtime项目的固定写法和最佳实践，在生产环境中广泛使用。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><ul>
<li>统一日志管理：整个应用使用同一个日志器</li>
<li>命令行可配置：支持通过命令行参数调整日志行为</li>
<li>结构化日志：使用zap提供结构化日志输出</li>
<li>开发友好：Development模式提供更好的调试体验</li>
</ul>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">    &quot;sigs.k8s.io/controller-runtime/pkg/log/zap&quot;</span><br><span class="line">    ctrl &quot;sigs.k8s.io/controller-runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func setupLogging() &#123;</span><br><span class="line">    // 步骤1: 创建zap日志选项</span><br><span class="line">    opts := zap.Options&#123;</span><br><span class="line">        Development: true, // 开发模式，更详细的日志输出</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 步骤2: 将zap选项绑定到命令行标志</span><br><span class="line">    // 这允许通过命令行参数控制日志级别、格式等</span><br><span class="line">    opts.BindFlags(flag.CommandLine)</span><br><span class="line">    </span><br><span class="line">    // 步骤3: 解析命令行参数</span><br><span class="line">    // 必须在使用flag之前调用</span><br><span class="line">    flag.Parse()</span><br><span class="line">    </span><br><span class="line">    // 步骤4: 设置controller-runtime的全局日志器</span><br><span class="line">    // zap.New() 创建一个新的zap日志器</span><br><span class="line">    // zap.UseFlagOptions(&amp;opts) 使用命令行解析的选项</span><br><span class="line">    ctrl.SetLogger(zap.New(zap.UseFlagOptions(&amp;opts)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">func main() &#123;</span><br><span class="line">    setupLogging()</span><br><span class="line">    </span><br><span class="line">    // 获取日志器实例</span><br><span class="line">    log := ctrl.Log.WithName(&quot;main&quot;)</span><br><span class="line">    </span><br><span class="line">    // 使用日志</span><br><span class="line">    log.Info(&quot;应用启动&quot;, &quot;version&quot;, &quot;1.0.0&quot;)</span><br><span class="line">    log.Error(nil, &quot;这是一个错误日志&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">代码含义分析：</span><br><span class="line"></span><br><span class="line">1. opts := zap.Options&#123;Development: true&#125;</span><br><span class="line">   - 创建zap日志配置选项</span><br><span class="line">   - Development: true 表示开发模式</span><br><span class="line">   - 开发模式特征：更详细的日志、更易读的格式</span><br><span class="line"></span><br><span class="line">2. opts.BindFlags(flag.CommandLine)</span><br><span class="line">   - 将日志选项绑定到命令行标志</span><br><span class="line">   - 支持的常用标志：</span><br><span class="line">     --zap-log-level: 日志级别(debug, info, error)</span><br><span class="line">     --zap-development: 是否开发模式</span><br><span class="line">     --zap-encoder: 编码器类型(json, console)</span><br><span class="line">     --zap-time-encoding: 时间编码格式</span><br><span class="line"></span><br><span class="line">3. flag.Parse()</span><br><span class="line">   - 解析命令行参数</span><br><span class="line">   - 必须在使用任何flag之前调用</span><br><span class="line"></span><br><span class="line">4. ctrl.SetLogger(zap.New(zap.UseFlagOptions(&amp;opts)))</span><br><span class="line">   - 设置controller-runtime的全局日志器</span><br><span class="line">   - zap.New() 创建新的zap日志器实例</span><br><span class="line">   - zap.UseFlagOptions(&amp;opts) 应用命令行解析的选项</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="改进版本"><a href="#改进版本" class="headerlink" title="改进版本"></a>改进版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;sigs.k8s.io/controller-runtime/pkg/log/zap&quot;</span><br><span class="line">    ctrl &quot;sigs.k8s.io/controller-runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 改进版本的日志配置</span><br><span class="line">func setupLoggingBestPractice() &#123;</span><br><span class="line">    // 1. 根据环境变量决定开发模式</span><br><span class="line">    isDevelopment := os.Getenv(&quot;ENV&quot;) != &quot;production&quot;</span><br><span class="line">    </span><br><span class="line">    opts := zap.Options&#123;</span><br><span class="line">        Development: isDevelopment,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2. 添加错误处理</span><br><span class="line">    opts.BindFlags(flag.CommandLine)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    </span><br><span class="line">    // 3. 设置全局日志器</span><br><span class="line">    logger := zap.New(zap.UseFlagOptions(&amp;opts))</span><br><span class="line">    ctrl.SetLogger(logger)</span><br><span class="line">    </span><br><span class="line">    // 4. 记录日志配置信息</span><br><span class="line">    setupLog := logger.WithName(&quot;setup&quot;)</span><br><span class="line">    setupLog.Info(&quot;日志系统初始化完成&quot;, </span><br><span class="line">        &quot;development&quot;, isDevelopment,</span><br><span class="line">        &quot;level&quot;, &quot;info&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生产环境推荐配置</span><br><span class="line">func setupProductionLogging() &#123;</span><br><span class="line">    opts := zap.Options&#123;</span><br><span class="line">        Development: false,  // 生产模式</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 绑定命令行参数</span><br><span class="line">    opts.BindFlags(flag.CommandLine)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    </span><br><span class="line">    // 创建日志器</span><br><span class="line">    logger := zap.New(zap.UseFlagOptions(&amp;opts))</span><br><span class="line">    ctrl.SetLogger(logger)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 高级配置示例</span><br><span class="line">func setupAdvancedLogging() &#123;</span><br><span class="line">    // 自定义zap配置</span><br><span class="line">    opts := zap.Options&#123;</span><br><span class="line">        Development: false,</span><br><span class="line">        // 可以添加更多自定义选项</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    opts.BindFlags(flag.CommandLine)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    </span><br><span class="line">    // 使用自定义配置</span><br><span class="line">    logger := zap.New(zap.UseFlagOptions(&amp;opts))</span><br><span class="line">    ctrl.SetLogger(logger)</span><br><span class="line">    </span><br><span class="line">    // 设置不同组件的日志级别</span><br><span class="line">    ctrl.Log.WithName(&quot;controller&quot;).V(1).Info(&quot;控制器日志级别设置&quot;)</span><br><span class="line">    ctrl.Log.WithName(&quot;webhook&quot;).V(2).Info(&quot;webhook详细日志&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用示例</span><br><span class="line">func main() &#123;</span><br><span class="line">    // 选择适合的日志配置方式</span><br><span class="line">    setupLoggingBestPractice()</span><br><span class="line">    </span><br><span class="line">    // 获取日志器并使用</span><br><span class="line">    log := ctrl.Log.WithName(&quot;application&quot;)</span><br><span class="line">    log.Info(&quot;应用启动成功&quot;)</span><br><span class="line">    </span><br><span class="line">    // 结构化日志示例</span><br><span class="line">    log.Info(&quot;处理请求&quot;, </span><br><span class="line">        &quot;method&quot;, &quot;POST&quot;,</span><br><span class="line">        &quot;path&quot;, &quot;/api/v1/resource&quot;,</span><br><span class="line">        &quot;user_id&quot;, &quot;12345&quot;)</span><br><span class="line">    </span><br><span class="line">    // 错误日志示例</span><br><span class="line">    if err := someFunction(); err != nil &#123;</span><br><span class="line">        log.Error(err, &quot;函数执行失败&quot;, &quot;function&quot;, &quot;someFunction&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func someFunction() error &#123;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">最佳实践建议：</span><br><span class="line"></span><br><span class="line">1. 环境区分：</span><br><span class="line">   - 开发环境：Development: true，详细日志</span><br><span class="line">   - 生产环境：Development: false，JSON格式</span><br><span class="line"></span><br><span class="line">2. 命令行参数使用：</span><br><span class="line">   go run main.go --zap-log-level=debug</span><br><span class="line">   go run main.go --zap-development=false</span><br><span class="line">   go run main.go --zap-encoder=json</span><br><span class="line"></span><br><span class="line">3. 日志级别管理：</span><br><span class="line">   - Info: 一般信息</span><br><span class="line">   - Error: 错误信息</span><br><span class="line">   - V(1): 详细信息  </span><br><span class="line">   - V(2): 更详细信息</span><br><span class="line"></span><br><span class="line">4. 结构化日志：</span><br><span class="line">   使用键值对形式记录结构化信息</span><br><span class="line"></span><br><span class="line">5. 命名空间：</span><br><span class="line">   使用WithName()为不同组件创建专用日志器</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h2><ul>
<li>zap.Options 支持的 flag 参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 运行时可以使用这些参数</span><br><span class="line">./manager \</span><br><span class="line">  --zap-log-level=debug \           # 设置日志级别</span><br><span class="line">  --zap-development=true \          # 开发模式</span><br><span class="line">  --zap-encoder=console \           # 输出格式 (console/json)</span><br><span class="line">  --zap-time-encoding=iso8601 \     # 时间格式</span><br><span class="line">  --zap-stacktrace-level=error      # 堆栈跟踪级别</span><br></pre></td></tr></table></figure></li>
<li>flag 的常见用法总结<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置文件路径: --config=config.yaml</span><br><span class="line">服务地址配置: --metrics-bind-address=:8080</span><br><span class="line">功能开关: --enable-leader-election</span><br><span class="line">日志级别: --zap-log-level=debug</span><br><span class="line">并发控制: --max-concurrent-reconciles=5</span><br></pre></td></tr></table></figure></li>
<li>典型的 controller 启动代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 典型的 controller 启动代码</span><br><span class="line">func main() &#123;</span><br><span class="line">    var (</span><br><span class="line">        configFile = flag.String(&quot;config&quot;, &quot;&quot;, &quot;控制器配置文件&quot;)</span><br><span class="line">        metricsAddr = flag.String(&quot;metrics-bind-address&quot;, &quot;:8080&quot;, &quot;metrics 地址&quot;)</span><br><span class="line">        probeAddr = flag.String(&quot;health-probe-bind-address&quot;, &quot;:8081&quot;, &quot;健康检查地址&quot;)</span><br><span class="line">        enableLeaderElection = flag.Bool(&quot;leader-elect&quot;, false, &quot;启用 leader 选举&quot;)</span><br><span class="line">        maxConcurrentReconciles = flag.Int(&quot;max-concurrent-reconciles&quot;, 1, &quot;最大并发协调数&quot;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    opts := zap.Options&#123;Development: true&#125;</span><br><span class="line">    opts.BindFlags(flag.CommandLine)</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    ctrl.SetLogger(zap.New(zap.UseFlagOptions(&amp;opts)))</span><br><span class="line">    </span><br><span class="line">    // 使用解析的参数配置管理器...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd集群监控与运维完整指南</title>
    <url>/2025/06/18/etcd%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%BF%90%E7%BB%B4%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="一、健康状况检查命令"><a href="#一、健康状况检查命令" class="headerlink" title="一、健康状况检查命令"></a>一、健康状况检查命令</h2><h3 id="1-1-基础健康检查"><a href="#1-1-基础健康检查" class="headerlink" title="1.1 基础健康检查"></a>1.1 基础健康检查</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查集群整体健康状况</span></span><br><span class="line">etcdctl endpoint health --cluster</span><br><span class="line">etcdctl endpoint health --endpoints=10.10.10.100:2379,10.10.10.101:2379,10.10.10.102:2379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查集群状态详情</span></span><br><span class="line">etcdctl endpoint status --cluster --write-out=table</span><br><span class="line">etcdctl endpoint status --endpoints=10.10.10.100:2379,10.10.10.101:2379,10.10.10.102:2379 --write-out=table</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查成员列表</span></span><br><span class="line">etcdctl member list --write-out=table</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查Leader信息</span></span><br><span class="line">etcdctl endpoint status --cluster --write-out=json | jq <span class="string">&#x27;.[] | select(.Status.leader != &quot;&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-性能检查命令"><a href="#1-2-性能检查命令" class="headerlink" title="1.2 性能检查命令"></a>1.2 性能检查命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查网络延迟和吞吐量</span></span><br><span class="line">etcdctl check perf --endpoints=10.10.10.100:2379,10.10.10.101:2379,10.10.10.102:2379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查数据一致性</span></span><br><span class="line">etcdctl check datascale --endpoints=10.10.10.100:2379,10.10.10.101:2379,10.10.10.102:2379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压力测试</span></span><br><span class="line">etcdctl check perf --load=<span class="string">&quot;s&quot;</span> --prefix=<span class="string">&quot;/test/&quot;</span> --endpoints=10.10.10.100:2379</span><br></pre></td></tr></table></figure>

<h2 id="二、关键监控指标"><a href="#二、关键监控指标" class="headerlink" title="二、关键监控指标"></a>二、关键监控指标</h2><h3 id="2-1-集群健康指标"><a href="#2-1-集群健康指标" class="headerlink" title="2.1 集群健康指标"></a>2.1 集群健康指标</h3><h4 id="Raft相关指标"><a href="#Raft相关指标" class="headerlink" title="Raft相关指标"></a>Raft相关指标</h4><ul>
<li><strong>etcd_server_has_leader</strong>: 是否有Leader (0&#x2F;1)</li>
<li><strong>etcd_server_leader_changes_seen_total</strong>: Leader变更次数</li>
<li><strong>etcd_server_proposals_committed_total</strong>: 已提交的提案数</li>
<li><strong>etcd_server_proposals_applied_total</strong>: 已应用的提案数</li>
<li><strong>etcd_server_proposals_pending</strong>: 待处理的提案数</li>
<li><strong>etcd_server_proposals_failed_total</strong>: 失败的提案数</li>
</ul>
<h4 id="数据库指标"><a href="#数据库指标" class="headerlink" title="数据库指标"></a>数据库指标</h4><ul>
<li><strong>etcd_mvcc_db_total_size_in_bytes</strong>: 数据库总大小</li>
<li><strong>etcd_mvcc_db_total_size_in_use_in_bytes</strong>: 实际使用的数据库大小</li>
<li><strong>etcd_server_quota_backend_bytes</strong>: 后端存储配额</li>
<li><strong>etcd_mvcc_delete_total</strong>: 删除操作总数</li>
<li><strong>etcd_mvcc_put_total</strong>: 写入操作总数</li>
<li><strong>etcd_mvcc_range_total</strong>: 读取操作总数</li>
</ul>
<h3 id="2-2-性能指标"><a href="#2-2-性能指标" class="headerlink" title="2.2 性能指标"></a>2.2 性能指标</h3><h4 id="延迟指标"><a href="#延迟指标" class="headerlink" title="延迟指标"></a>延迟指标</h4><ul>
<li><strong>etcd_disk_wal_fsync_duration_seconds</strong>: WAL fsync延迟</li>
<li><strong>etcd_disk_backend_commit_duration_seconds</strong>: 后端提交延迟</li>
<li><strong>etcd_network_peer_round_trip_time_seconds</strong>: 节点间网络延迟</li>
<li><strong>etcd_server_read_indexes_failed_total</strong>: 读索引失败次数</li>
</ul>
<h4 id="网络指标"><a href="#网络指标" class="headerlink" title="网络指标"></a>网络指标</h4><ul>
<li><strong>etcd_network_client_grpc_received_bytes_total</strong>: 客户端接收字节数</li>
<li><strong>etcd_network_client_grpc_sent_bytes_total</strong>: 客户端发送字节数</li>
<li><strong>etcd_network_peer_received_bytes_total</strong>: 节点间接收字节数</li>
<li><strong>etcd_network_peer_sent_bytes_total</strong>: 节点间发送字节数</li>
</ul>
<h3 id="2-3-资源使用指标"><a href="#2-3-资源使用指标" class="headerlink" title="2.3 资源使用指标"></a>2.3 资源使用指标</h3><ul>
<li><strong>process_resident_memory_bytes</strong>: 内存使用量</li>
<li><strong>process_cpu_seconds_total</strong>: CPU使用时间</li>
<li><strong>etcd_server_slow_apply_total</strong>: 慢应用次数</li>
<li><strong>etcd_server_slow_read_indexes_total</strong>: 慢读索引次数</li>
</ul>
<h2 id="三、告警规则建议"><a href="#三、告警规则建议" class="headerlink" title="三、告警规则建议"></a>三、告警规则建议</h2><h3 id="3-1-关键告警"><a href="#3-1-关键告警" class="headerlink" title="3.1 关键告警"></a>3.1 关键告警</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># etcd集群无Leader</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">EtcdNoLeader</span></span><br><span class="line">  <span class="attr">expr:</span> <span class="string">etcd_server_has_leader</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">for:</span> <span class="string">1m</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">severity:</span> <span class="string">critical</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">summary:</span> <span class="string">&quot;etcd集群无Leader&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># etcd数据库大小接近配额</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">EtcdDatabaseQuotaLowSpace</span></span><br><span class="line">  <span class="attr">expr:</span> <span class="string">(etcd_mvcc_db_total_size_in_bytes</span> <span class="string">/</span> <span class="string">etcd_server_quota_backend_bytes)</span> <span class="string">&gt;</span> <span class="number">0.8</span></span><br><span class="line">  <span class="attr">for:</span> <span class="string">5m</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">severity:</span> <span class="string">warning</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">summary:</span> <span class="string">&quot;etcd数据库使用量超过80%&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># etcd成员通信失败</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">EtcdMemberCommunicationSlow</span></span><br><span class="line">  <span class="attr">expr:</span> <span class="string">histogram_quantile(0.99,</span> <span class="string">etcd_network_peer_round_trip_time_seconds_bucket)</span> <span class="string">&gt;</span> <span class="number">0.15</span></span><br><span class="line">  <span class="attr">for:</span> <span class="string">10m</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">severity:</span> <span class="string">warning</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-性能告警"><a href="#3-2-性能告警" class="headerlink" title="3.2 性能告警"></a>3.2 性能告警</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 磁盘I/O延迟过高</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">EtcdDiskSlow</span></span><br><span class="line">  <span class="attr">expr:</span> <span class="string">histogram_quantile(0.99,</span> <span class="string">etcd_disk_wal_fsync_duration_seconds_bucket)</span> <span class="string">&gt;</span> <span class="number">0.5</span></span><br><span class="line">  <span class="attr">for:</span> <span class="string">10m</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">severity:</span> <span class="string">warning</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Leader变更频繁</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">EtcdLeaderChanges</span></span><br><span class="line">  <span class="attr">expr:</span> <span class="string">increase(etcd_server_leader_changes_seen_total[1h])</span> <span class="string">&gt;</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">for:</span> <span class="string">5m</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">severity:</span> <span class="string">warning</span></span><br></pre></td></tr></table></figure>

<h2 id="四、备份策略"><a href="#四、备份策略" class="headerlink" title="四、备份策略"></a>四、备份策略</h2><h3 id="4-1-快照备份"><a href="#4-1-快照备份" class="headerlink" title="4.1 快照备份"></a>4.1 快照备份</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建快照</span></span><br><span class="line">etcdctl snapshot save backup-$(<span class="built_in">date</span> +%Y%m%d-%H%M%S).db \</span><br><span class="line">  --endpoints=https://10.10.10.102:2379 \</span><br><span class="line">  --cacert=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">  --cert=/etc/kubernetes/pki/etcd/server.crt \</span><br><span class="line">  --key=/etc/kubernetes/pki/etcd/server.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证快照</span></span><br><span class="line">etcdctl snapshot status backup-20250613-120000.db --write-out=table</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动化备份脚本</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">BACKUP_DIR=<span class="string">&quot;/backup/etcd&quot;</span></span><br><span class="line">DATE=$(<span class="built_in">date</span> +%Y%m%d-%H%M%S)</span><br><span class="line">ENDPOINTS=<span class="string">&quot;https://10.10.10.100:2379,https://10.10.10.101:2379,https://10.10.10.102:2379&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$BACKUP_DIR</span></span><br><span class="line">etcdctl snapshot save <span class="variable">$BACKUP_DIR</span>/etcd-backup-<span class="variable">$DATE</span>.db \</span><br><span class="line">  --endpoints=<span class="variable">$ENDPOINTS</span> \</span><br><span class="line">  --cacert=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">  --cert=/etc/kubernetes/pki/etcd/server.crt \</span><br><span class="line">  --key=/etc/kubernetes/pki/etcd/server.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留最近7天的备份</span></span><br><span class="line">find <span class="variable">$BACKUP_DIR</span> -name <span class="string">&quot;etcd-backup-*.db&quot;</span> -mtime +7 -delete</span><br></pre></td></tr></table></figure>

<h3 id="4-2-备份策略建议"><a href="#4-2-备份策略建议" class="headerlink" title="4.2 备份策略建议"></a>4.2 备份策略建议</h3><ul>
<li><strong>频率</strong>: 每天至少一次完整备份</li>
<li><strong>保留</strong>: 保留7天内的每日备份，4周内的每周备份</li>
<li><strong>存储</strong>: 备份文件应存储在不同的物理位置</li>
<li><strong>验证</strong>: 定期验证备份文件的完整性</li>
</ul>
<h2 id="五、故障恢复"><a href="#五、故障恢复" class="headerlink" title="五、故障恢复"></a>五、故障恢复</h2><h3 id="5-1-从快照恢复"><a href="#5-1-从快照恢复" class="headerlink" title="5.1 从快照恢复"></a>5.1 从快照恢复</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止etcd服务</span></span><br><span class="line">systemctl stop etcd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除现有数据目录</span></span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/etcd/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从快照恢复</span></span><br><span class="line">etcdctl snapshot restore backup-20250613-120000.db \</span><br><span class="line">  --name etcd-1 \</span><br><span class="line">  --initial-cluster etcd-1=https://10.10.10.100:2380,etcd-2=https://10.10.10.101:2380,etcd-3=https://10.10.10.102:2380 \</span><br><span class="line">  --initial-cluster-token etcd-cluster-1 \</span><br><span class="line">  --initial-advertise-peer-urls https://10.10.10.100:2380 \</span><br><span class="line">  --data-dir /var/lib/etcd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启etcd服务</span></span><br><span class="line">systemctl start etcd</span><br></pre></td></tr></table></figure>

<h3 id="5-2-成员替换"><a href="#5-2-成员替换" class="headerlink" title="5.2 成员替换"></a>5.2 成员替换</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加新成员</span></span><br><span class="line">etcdctl member add etcd-new --peer-urls=https://10.236.100.100:2380</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除故障成员</span></span><br><span class="line">etcdctl member remove &lt;member-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看成员状态</span></span><br><span class="line">etcdctl member list --write-out=table</span><br></pre></td></tr></table></figure>

<h2 id="六、性能优化"><a href="#六、性能优化" class="headerlink" title="六、性能优化"></a>六、性能优化</h2><h3 id="6-1-配置优化"><a href="#6-1-配置优化" class="headerlink" title="6.1 配置优化"></a>6.1 配置优化</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># etcd配置文件优化</span></span><br><span class="line"><span class="attr">data-dir:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line"><span class="attr">wal-dir:</span> <span class="string">/var/lib/etcd/wal</span>  <span class="comment"># 将WAL放在单独的SSD上</span></span><br><span class="line"><span class="attr">max-snapshots:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">max-wals:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">quota-backend-bytes:</span> <span class="number">8589934592</span>  <span class="comment"># 8GB</span></span><br><span class="line"><span class="attr">auto-compaction-retention:</span> <span class="string">&quot;1h&quot;</span></span><br><span class="line"><span class="attr">auto-compaction-mode:</span> <span class="string">periodic</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-系统优化"><a href="#6-2-系统优化" class="headerlink" title="6.2 系统优化"></a>6.2 系统优化</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件描述符限制</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* soft nofile 65536&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* hard nofile 65536&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络优化</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;net.core.rmem_max = 16777216&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;net.core.wmem_max = 16777216&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h2 id="七、数据维护"><a href="#七、数据维护" class="headerlink" title="七、数据维护"></a>七、数据维护</h2><h3 id="7-1-压缩和碎片整理"><a href="#7-1-压缩和碎片整理" class="headerlink" title="7.1 压缩和碎片整理"></a>7.1 压缩和碎片整理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手动压缩</span></span><br><span class="line">etcdctl compact $(etcdctl endpoint status --write-out=<span class="string">&quot;json&quot;</span> | jq -r <span class="string">&#x27;.[0].Status.header.revision&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 碎片整理</span></span><br><span class="line">etcdctl defrag --endpoints=https://10.10.10.100:2379,https://10.10.10.101:2379,https://10.10.10.102:2379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查碎片整理效果</span></span><br><span class="line">etcdctl endpoint status --endpoints=https://10.10.10.100:2379,https://10.10.10.101:2379,https://10.10.10.102:2379 --write-out=table</span><br></pre></td></tr></table></figure>

<h3 id="7-2-定期维护任务"><a href="#7-2-定期维护任务" class="headerlink" title="7.2 定期维护任务"></a>7.2 定期维护任务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 每周维护脚本</span></span><br><span class="line"><span class="comment"># 1. 压缩历史版本</span></span><br><span class="line">etcdctl compact $(etcdctl endpoint status --write-out=<span class="string">&quot;json&quot;</span> | jq -r <span class="string">&#x27;.[0].Status.header.revision&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 碎片整理</span></span><br><span class="line">etcdctl defrag --cluster</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 检查集群健康</span></span><br><span class="line">etcdctl endpoint health --cluster</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 创建备份</span></span><br><span class="line">etcdctl snapshot save /backup/etcd/weekly-backup-$(<span class="built_in">date</span> +%Y%m%d).db</span><br></pre></td></tr></table></figure>

<h2 id="八、安全加固"><a href="#八、安全加固" class="headerlink" title="八、安全加固"></a>八、安全加固</h2><h3 id="8-1-认证配置"><a href="#8-1-认证配置" class="headerlink" title="8.1 认证配置"></a>8.1 认证配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用认证</span></span><br><span class="line">etcdctl auth <span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建root用户</span></span><br><span class="line">etcdctl user add root --interactive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建角色</span></span><br><span class="line">etcdctl role add admin</span><br><span class="line">etcdctl role grant-permission admin readwrite /*</span><br></pre></td></tr></table></figure>

<h3 id="8-2-TLS配置"><a href="#8-2-TLS配置" class="headerlink" title="8.2 TLS配置"></a>8.2 TLS配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用客户端TLS</span></span><br><span class="line"><span class="attr">client-cert-auth:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">trusted-ca-file:</span> <span class="string">/etc/ssl/certs/etcd-ca.pem</span></span><br><span class="line"><span class="attr">cert-file:</span> <span class="string">/etc/ssl/certs/etcd-server.pem</span></span><br><span class="line"><span class="attr">key-file:</span> <span class="string">/etc/ssl/private/etcd-server-key.pem</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用peer TLS</span></span><br><span class="line"><span class="attr">peer-client-cert-auth:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">peer-trusted-ca-file:</span> <span class="string">/etc/ssl/certs/etcd-ca.pem</span></span><br><span class="line"><span class="attr">peer-cert-file:</span> <span class="string">/etc/ssl/certs/etcd-peer.pem</span></span><br><span class="line"><span class="attr">peer-key-file:</span> <span class="string">/etc/ssl/private/etcd-peer-key.pem</span></span><br></pre></td></tr></table></figure>

<h2 id="九、故障排查"><a href="#九、故障排查" class="headerlink" title="九、故障排查"></a>九、故障排查</h2><h3 id="9-1-常见问题诊断"><a href="#9-1-常见问题诊断" class="headerlink" title="9.1 常见问题诊断"></a>9.1 常见问题诊断</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查etcd进程</span></span><br><span class="line">ps aux | grep etcd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查端口监听</span></span><br><span class="line">netstat -tlnp | grep :2379</span><br><span class="line">netstat -tlnp | grep :2380</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查日志</span></span><br><span class="line">journalctl -u etcd -f</span><br><span class="line"><span class="built_in">tail</span> -f /var/log/etcd/etcd.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查网络连通性</span></span><br><span class="line">curl -k https://10.10.10.100:2379/health</span><br></pre></td></tr></table></figure>

<h3 id="9-2-性能分析"><a href="#9-2-性能分析" class="headerlink" title="9.2 性能分析"></a>9.2 性能分析</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分析慢查询</span></span><br><span class="line">etcdctl get --prefix / --keys-only | <span class="built_in">wc</span> -l  <span class="comment"># 检查key数量</span></span><br><span class="line">etcdctl compaction $(etcdctl endpoint status --write-out=<span class="string">&quot;json&quot;</span> | jq -r <span class="string">&#x27;.[0].Status.header.revision&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析网络延迟</span></span><br><span class="line">ping 10.10.10.100</span><br><span class="line">ping 10.10.10.101  </span><br><span class="line">ping 10.10.10.102</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>https工作流程</title>
    <url>/2025/06/18/https%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h2><p><img src="https://raw.githubusercontent.com/shispring/picgo/master/20250618151317.png" alt="https" title="https works"></p>
<h2 id="HTTPS-工作流程详解"><a href="#HTTPS-工作流程详解" class="headerlink" title="HTTPS 工作流程详解"></a>HTTPS 工作流程详解</h2><h3 id="1-TCP-握手阶段"><a href="#1-TCP-握手阶段" class="headerlink" title="1. TCP 握手阶段"></a>1. TCP 握手阶段</h3><ul>
<li><strong>TCP SYN</strong>: 客户端向服务器发送同步请求，请求建立连接</li>
<li><strong>TCP SYN + ACK</strong>: 服务器响应并确认连接请求</li>
<li><strong>TCP ACK</strong>: 客户端确认，TCP 连接建立完成</li>
</ul>
<p>这是标准的 TCP 三次握手，为后续的 TLS&#x2F;SSL 通信建立可靠的传输层连接。</p>
<h3 id="2-证书验证阶段"><a href="#2-证书验证阶段" class="headerlink" title="2. 证书验证阶段"></a>2. 证书验证阶段</h3><ul>
<li><strong>Client Hello</strong>: 客户端发送支持的 TLS 版本、加密套件列表等信息</li>
<li><strong>Server Hello</strong>: 服务器选择 TLS 版本和加密套件</li>
<li><strong>Certificate</strong>: 服务器发送数字证书（包含公钥）</li>
<li><strong>Server Hello Done</strong>: 服务器表示握手信息发送完毕</li>
</ul>
<p>在这个阶段，客户端会验证服务器证书的有效性，包括：</p>
<ul>
<li>证书是否由可信 CA 签发</li>
<li>证书是否在有效期内</li>
<li>证书中的域名是否与访问的域名匹配</li>
</ul>
<h3 id="3-密钥交换阶段"><a href="#3-密钥交换阶段" class="headerlink" title="3. 密钥交换阶段"></a>3. 密钥交换阶段</h3><p>这是 HTTPS 安全性的核心部分：</p>
<p><strong>非对称加密过程</strong>：</p>
<ul>
<li>客户端生成一个随机的 <strong>session key</strong>（会话密钥）</li>
<li>使用服务器证书中的 <strong>公钥</strong> 对 session key 进行加密</li>
<li>发送 <strong>Client Key Exchange</strong> 消息，包含加密后的 session key</li>
<li>服务器使用自己的 <strong>私钥</strong> 解密获得 session key</li>
</ul>
<p><strong>握手完成</strong>：</p>
<ul>
<li><strong>Change Cipher Spec</strong>: 双方通知对方后续通信将使用协商好的加密参数</li>
<li><strong>Finished</strong>: 使用新的加密参数发送握手完成消息</li>
</ul>
<h3 id="4-数据传输阶段"><a href="#4-数据传输阶段" class="headerlink" title="4. 数据传输阶段"></a>4. 数据传输阶段</h3><p><strong>对称加密通信</strong>：</p>
<ul>
<li>双方都拥有相同的 session key</li>
<li>使用对称加密算法（如 AES）对数据进行加密&#x2F;解密</li>
<li>所有 HTTP 数据都通过这个加密通道传输</li>
</ul>
<h2 id="加密机制说明"><a href="#加密机制说明" class="headerlink" title="加密机制说明"></a>加密机制说明</h2><h3 id="为什么使用混合加密？"><a href="#为什么使用混合加密？" class="headerlink" title="为什么使用混合加密？"></a>为什么使用混合加密？</h3><ol>
<li><p><strong>非对称加密</strong>（RSA&#x2F;ECDH）：</p>
<ul>
<li>优点：密钥分发安全，无需预共享密钥</li>
<li>缺点：计算开销大，速度慢</li>
</ul>
</li>
<li><p><strong>对称加密</strong>（AES）：</p>
<ul>
<li>优点：加密速度快，效率高</li>
<li>缺点：密钥分发困难</li>
</ul>
</li>
</ol>
<p><strong>HTTPS 的巧妙之处</strong>：</p>
<ul>
<li>用非对称加密安全地交换对称密钥</li>
<li>用对称加密进行实际的数据传输</li>
<li>既保证了安全性，又保证了效率</li>
</ul>
<h2 id="HTTPS-最佳实践总结"><a href="#HTTPS-最佳实践总结" class="headerlink" title="HTTPS 最佳实践总结"></a>HTTPS 最佳实践总结</h2><h3 id="1-证书管理"><a href="#1-证书管理" class="headerlink" title="1. 证书管理"></a>1. 证书管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用权威 CA 签发的证书</span></span><br><span class="line"><span class="comment"># 推荐 Let&#x27;s Encrypt 免费证书</span></span><br><span class="line">certbot --nginx -d yourdomain.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定期更新证书</span></span><br><span class="line">0 3 * * * /usr/bin/certbot renew --quiet</span><br></pre></td></tr></table></figure>

<h3 id="2-TLS-版本配置"><a href="#2-TLS-版本配置" class="headerlink" title="2. TLS 版本配置"></a>2. TLS 版本配置</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Nginx 配置示例</span></span><br><span class="line"><span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;  <span class="comment"># 只使用安全版本</span></span><br><span class="line"><span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;</span><br><span class="line"><span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">off</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-安全头配置"><a href="#3-安全头配置" class="headerlink" title="3. 安全头配置"></a>3. 安全头配置</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 强制 HTTPS</span></span><br><span class="line"><span class="attribute">add_header</span> Strict-Transport-Security <span class="string">&quot;max-age=31536000; includeSubDomains&quot;</span> always;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 防止降级攻击</span></span><br><span class="line"><span class="attribute">add_header</span> X-Content-Type-Options nosniff;</span><br><span class="line"><span class="attribute">add_header</span> X-Frame-Options DENY;</span><br><span class="line"><span class="attribute">add_header</span> X-XSS-Protection <span class="string">&quot;1; mode=block&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4. 性能优化"></a>4. 性能优化</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用 HTTP/2</span></span><br><span class="line"><span class="attribute">listen</span> <span class="number">443</span> ssl http2;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会话复用</span></span><br><span class="line"><span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line"><span class="attribute">ssl_session_timeout</span> <span class="number">10m</span>;</span><br><span class="line"><span class="attribute">ssl_session_tickets</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># OCSP Stapling</span></span><br><span class="line"><span class="attribute">ssl_stapling</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">ssl_stapling_verify</span> <span class="literal">on</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-开发环境配置"><a href="#5-开发环境配置" class="headerlink" title="5. 开发环境配置"></a>5. 开发环境配置</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node.js Express 示例</span></span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">key</span>: fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;private-key.pem&#x27;</span>),</span><br><span class="line">  <span class="attr">cert</span>: fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;certificate.pem&#x27;</span>),</span><br><span class="line">  <span class="comment">// 强制 TLS 1.2+</span></span><br><span class="line">  <span class="attr">secureProtocol</span>: <span class="string">&#x27;TLSv1_2_method&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">https.<span class="title function_">createServer</span>(options, app).<span class="title function_">listen</span>(<span class="number">443</span>);</span><br></pre></td></tr></table></figure>

<h3 id="6-监控和维护"><a href="#6-监控和维护" class="headerlink" title="6. 监控和维护"></a>6. 监控和维护</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查证书有效期</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> certificate.crt -text -noout | grep <span class="string">&quot;Not After&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试 SSL 配置</span></span><br><span class="line">curl -I https://yourdomain.com</span><br><span class="line">openssl s_client -connect yourdomain.com:443 -servername yourdomain.com</span><br></pre></td></tr></table></figure>

<h3 id="7-安全检查清单"><a href="#7-安全检查清单" class="headerlink" title="7. 安全检查清单"></a>7. 安全检查清单</h3><ul>
<li>✅ 使用 TLS 1.2 或更高版本</li>
<li>✅ 禁用不安全的加密套件</li>
<li>✅ 启用 HSTS</li>
<li>✅ 配置正确的证书链</li>
<li>✅ 定期更新证书</li>
<li>✅ 监控证书过期时间</li>
<li>✅ 使用强加密算法（AES-256）</li>
<li>✅ 启用 Perfect Forward Secrecy</li>
</ul>
<p>这个流程图很好地展示了 HTTPS 如何通过非对称加密保证密钥交换的安全性，再通过对称加密保证数据传输的效率，是现代网络安全通信的标准实现。</p>
]]></content>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>curl网络请求耗时</title>
    <url>/2025/06/19/curl%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%80%97%E6%97%B6/</url>
    <content><![CDATA[<h2 id="配置输出格式"><a href="#配置输出格式" class="headerlink" title="配置输出格式"></a>配置输出格式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#步骤1配置参数</span><br><span class="line">cat &gt; curl-format.txt &lt;&lt; &#x27;EOF&#x27;</span><br><span class="line">=============== HTTPS 性能分析报告 ===============\n</span><br><span class="line">请求 URL（url_effective）      : %&#123;url_effective&#125;\n</span><br><span class="line">HTTP 状态码（http_code）       : %&#123;http_code&#125;\n</span><br><span class="line">Content-Type（content_type）   : %&#123;content_type&#125;\n</span><br><span class="line">\n</span><br><span class="line">========== 时间分析（单位: 秒） ==========\n</span><br><span class="line">DNS 解析时间（time_namelookup）      : %&#123;time_namelookup&#125;\n</span><br><span class="line">TCP 连接建立（time_connect）         : %&#123;time_connect&#125;\n</span><br><span class="line">TLS/SSL 握手（time_appconnect）      : %&#123;time_appconnect&#125;\n</span><br><span class="line">传输准备完成（time_pretransfer）     : %&#123;time_pretransfer&#125;\n</span><br><span class="line">重定向耗时（time_redirect）          : %&#123;time_redirect&#125;\n</span><br><span class="line">首字节接收 TTFB（time_starttransfer）: %&#123;time_starttransfer&#125;\n</span><br><span class="line">总请求时间（time_total）             : %&#123;time_total&#125;\n</span><br><span class="line">\n</span><br><span class="line">========== 数据传输分析 ==========\n</span><br><span class="line">下载数据大小（size_download）      : %&#123;size_download&#125; bytes\n</span><br><span class="line">上传数据大小（size_upload）        : %&#123;size_upload&#125; bytes\n</span><br><span class="line">请求大小（size_request）           : %&#123;size_request&#125; bytes\n</span><br><span class="line">响应头大小（size_header）          : %&#123;size_header&#125; bytes\n</span><br><span class="line">平均下载速度（speed_download）     : %&#123;speed_download&#125; bytes/sec\n</span><br><span class="line">平均上传速度（speed_upload）       : %&#123;speed_upload&#125; bytes/sec\n</span><br><span class="line">\n</span><br><span class="line">========== 连接信息 ==========\n</span><br><span class="line">远程 IP（remote_ip）               : %&#123;remote_ip&#125;\n</span><br><span class="line">远程端口（remote_port）            : %&#123;remote_port&#125;\n</span><br><span class="line">本地 IP（local_ip）                : %&#123;local_ip&#125;\n</span><br><span class="line">本地端口（local_port）             : %&#123;local_port&#125;\n</span><br><span class="line">\n</span><br><span class="line">========== SSL 相关 ==========\n</span><br><span class="line">SSL 验证结果（ssl_verify_result） : %&#123;ssl_verify_result&#125;\n</span><br><span class="line">==================================================\n</span><br><span class="line">EOF</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -w &quot;@curl-format.txt&quot; -o /dev/null -s http://baidu.com</span><br><span class="line"></span><br><span class="line">#curl -w &quot;@curl-format.txt&quot; -o /dev/null -s -k -H &quot;Host: test.xxx.net&quot; https://10.100.100.100:443</span><br></pre></td></tr></table></figure>

<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul>
<li>ssl_verify_result: SSL&#x2F;TLS 证书验证的结果代码（return code）<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td>✅ <strong>验证通过（OK）</strong>：证书合法、链条完整、受信任</td>
</tr>
<tr>
<td>非 0</td>
<td>❌ <strong>验证失败</strong>：证书不合法、不受信、链不完整等原因</td>
</tr>
</tbody></table>
</li>
<li>常见非零错误代码<table>
<thead>
<tr>
<th>错误码</th>
<th>含义（简述）</th>
</tr>
</thead>
<tbody><tr>
<td><code>2</code></td>
<td>无法获取发行者证书（链不完整）</td>
</tr>
<tr>
<td><code>10</code></td>
<td>证书过期</td>
</tr>
<tr>
<td><code>18</code></td>
<td>无法验证证书链</td>
</tr>
<tr>
<td><code>19</code></td>
<td>自签名证书</td>
</tr>
<tr>
<td><code>20</code></td>
<td>无法解析本地证书</td>
</tr>
<tr>
<td><code>21</code></td>
<td>无法验证根证书</td>
</tr>
<tr>
<td><code>27</code></td>
<td>主体和颁发者不匹配</td>
</tr>
<tr>
<td><code>62</code></td>
<td>主机名不匹配（证书 CN&#x2F;SAN 与域名不同）</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="验证证书链是否完整"><a href="#验证证书链是否完整" class="headerlink" title="验证证书链是否完整"></a>验证证书链是否完整</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方法1</span><br><span class="line">curl -v https://baidu.com</span><br><span class="line">成功：SSL certificate verify ok.</span><br><span class="line">如果失败返回：SSL certificate problem: unable to verify the first certificate</span><br><span class="line"></span><br><span class="line">#方法2</span><br><span class="line">openssl s_client -connect baidu.com:443 -showcerts</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>最佳实践建议</li>
</ul>
<table>
<thead>
<tr>
<th>目标</th>
<th>建议命令</th>
</tr>
</thead>
<tbody><tr>
<td>证书域名是否正确 + 证书链是否完整</td>
<td><code>curl -v --resolve your.domain.com:443:IP https://your.domain.com/</code></td>
</tr>
<tr>
<td>服务端返回的证书详情</td>
<td><code>openssl s_client -connect IP:443 -servername your.domain.com -showcerts</code></td>
</tr>
<tr>
<td>临时跳过验证测试 HTTP 响应</td>
<td><code>curl -k -H &quot;Host: ...&quot; https://IP:443</code>（调试专用）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>场景</th>
<th>是否验证证书</th>
<th>是否验证链完整性</th>
<th>SNI 正确</th>
<th>推荐用于生产验证？</th>
</tr>
</thead>
<tbody><tr>
<td><code>curl --resolve</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅ 强烈推荐</td>
</tr>
<tr>
<td><code>curl -H &quot;Host:...&quot;</code></td>
<td>✅（但会失败）</td>
<td>❌（因证书链不完整）</td>
<td>❌</td>
<td>❌ 不建议</td>
</tr>
<tr>
<td><code>curl -H &quot;Host:...&quot; -k</code></td>
<td>❌（跳过验证）</td>
<td>❌</td>
<td>❌</td>
<td>🚫 不推荐，仅调试用</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>cAdvisor初探</title>
    <url>/2025/06/19/cAdvisor%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="cgroup-namespace"><a href="#cgroup-namespace" class="headerlink" title="cgroup &amp; namespace"></a>cgroup &amp; namespace</h2><table>
<thead>
<tr>
<th>概念</th>
<th>含义</th>
<th>示例作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>cgroup</code></td>
<td>控制组，限制容器的 CPU、内存等</td>
<td><code>cpu.shares</code>, <code>memory.limit_in_bytes</code></td>
</tr>
<tr>
<td><code>namespace</code></td>
<td>名字空间，隔离容器运行环境</td>
<td><code>net</code>, <code>pid</code>, <code>mnt</code>, <code>ipc</code>, <code>uts</code>, <code>user</code></td>
</tr>
</tbody></table>
<h2 id="cAdvisor"><a href="#cAdvisor" class="headerlink" title="cAdvisor"></a>cAdvisor</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cAdvisor 直接读取:</span><br><span class="line">• /sys/fs/cgroup（CPU、memory、blkio）</span><br><span class="line">• /proc/&lt;pid&gt;/net/dev（网络）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="cAdvisor-读取磁盘-I-O-指标的原理"><a href="#cAdvisor-读取磁盘-I-O-指标的原理" class="headerlink" title="cAdvisor 读取磁盘 I&#x2F;O 指标的原理"></a>cAdvisor 读取磁盘 I&#x2F;O 指标的原理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从 cgroup blkio 子系统读取 I/O 限制与统计数据</span><br><span class="line">/sys/fs/cgroup/blkio/docker/&lt;container-id&gt;/</span><br><span class="line"></span><br><span class="line">2. 通过 /proc/&lt;pid&gt;/io 读取进程级磁盘数据</span><br><span class="line">/proc/&lt;container-pid&gt;/io</span><br><span class="line"></span><br><span class="line">cAdvisor 会汇总属于某个容器所有进程的 /proc/&lt;pid&gt;/io 统计。</span><br></pre></td></tr></table></figure>

<h2 id="模拟-cAdvisor-的行为"><a href="#模拟-cAdvisor-的行为" class="headerlink" title="模拟 cAdvisor 的行为"></a>模拟 cAdvisor 的行为</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps | grep kubelet</span><br><span class="line"></span><br><span class="line">docker inspect f965002cb995 | grep -w &quot;Id&quot;</span><br><span class="line">或</span><br><span class="line">docker inspect f965002cb995 | jq &#x27;.[].Id&#x27;</span><br><span class="line"></span><br><span class="line">#查看容器 blkio 数据</span><br><span class="line">cat /sys/fs/cgroup/blkio/docker/f965002cb995390b763ab8abacd86cc987d223101ace612a9e16c3bac9767a80/blkio.throttle.io_service_bytes</span><br><span class="line"></span><br><span class="line">查看某容器主进程的 PID：</span><br><span class="line">docker inspect f965002cb995 | grep -w &quot;Pid&quot;</span><br><span class="line">或</span><br><span class="line">docker inspect f965002cb995 | jq &#x27;.[].State.Pid&#x27;</span><br><span class="line"></span><br><span class="line">cat /proc/6687/io</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>常见runtime socket</title>
    <url>/2025/07/01/%E5%B8%B8%E8%A7%81runtime-socket/</url>
    <content><![CDATA[<h2 id="常见-runtime-socket-路径"><a href="#常见-runtime-socket-路径" class="headerlink" title="常见 runtime socket 路径"></a>常见 runtime socket 路径</h2><table>
<thead>
<tr>
<th>CRI 实现</th>
<th>Socket 路径</th>
</tr>
</thead>
<tbody><tr>
<td>containerd（K3s）</td>
<td><code>/run/k3s/containerd/containerd.sock</code></td>
</tr>
<tr>
<td>containerd（非 K3s）</td>
<td><code>/run/containerd/containerd.sock</code></td>
</tr>
<tr>
<td>cri-o</td>
<td><code>/run/crio/crio.sock</code></td>
</tr>
<tr>
<td>Docker + cri-dockerd</td>
<td><code>/var/run/cri-dockerd.sock</code></td>
</tr>
<tr>
<td>Dockershim</td>
<td><code>/var/run/dockershim.sock</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="crictl-WARN-解决办法"><a href="#crictl-WARN-解决办法" class="headerlink" title="crictl WARN 解决办法"></a>crictl WARN 解决办法</h2><ul>
<li>显式指定 –runtime-endpoint 参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#命令中指定 --runtime-endpoint,使用 K3s 时 containerd 的默认 socket 路径</span><br><span class="line">crictl --runtime-endpoint unix:///run/k3s/containerd/containerd.sock images</span><br></pre></td></tr></table></figure></li>
<li>设置配置文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt; EOF</span><br><span class="line">runtime-endpoint: unix:///run/k3s/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///run/k3s/containerd/containerd.sock</span><br><span class="line">timeout: 10</span><br><span class="line">debug: false</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">crictl images</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>关于FQDN</title>
    <url>/2025/07/07/%E5%85%B3%E4%BA%8EFQDN/</url>
    <content><![CDATA[<p>这是个很有技术深度的问题。在 Kubernetes 的网络架构中，<strong>FQDN（Fully Qualified Domain Name，完全限定域名）</strong> 是集群内部和外部通信中非常关键的一环。你提到的 <code>FQDN</code> 和 <code>RQDN</code>（可能是 Relative Qualified Domain Name 的意思，见下文）概念，都可以围绕 DNS 来系统理解。</p>
<hr>
<h2 id="✅-一、什么是-FQDN？"><a href="#✅-一、什么是-FQDN？" class="headerlink" title="✅ 一、什么是 FQDN？"></a>✅ 一、什么是 FQDN？</h2><p><strong>FQDN（Fully Qualified Domain Name）</strong> 是指一个完全的、绝对的 DNS 名字，它<strong>从主机名开始，一直到根域（<code>.</code>）结束</strong>。</p>
<h3 id="🔹-举例："><a href="#🔹-举例：" class="headerlink" title="🔹 举例："></a>🔹 举例：</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>my-service.default.svc.cluster.local.</code></td>
<td>✅ FQDN，在 K8s 中完整的 service 解析域名</td>
</tr>
<tr>
<td><code>my-service.default.svc.cluster.local</code></td>
<td>✅ 几乎等价（根 <code>.</code> 可省略）</td>
</tr>
<tr>
<td><code>my-service</code></td>
<td>❌ 不是 FQDN，属于相对域名（可解析依赖 search 域）</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-二、Kubernetes-中的-FQDN-使用场景"><a href="#✅-二、Kubernetes-中的-FQDN-使用场景" class="headerlink" title="✅ 二、Kubernetes 中的 FQDN 使用场景"></a>✅ 二、Kubernetes 中的 FQDN 使用场景</h2><p>在 Kubernetes 内部，所有服务、Pod 都可以通过 DNS 名称访问，而 <strong>KubeDNS&#x2F;CoreDNS</strong> 按如下规则拼接域名：</p>
<h3 id="🚀-Service-默认-FQDN："><a href="#🚀-Service-默认-FQDN：" class="headerlink" title="🚀 Service 默认 FQDN："></a>🚀 Service 默认 FQDN：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;service-name&gt;.&lt;namespace&gt;.svc.cluster.local</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>svc.cluster.local</code> 是 service 的默认 DNS 域名后缀，定义在 kubelet 或 CoreDNS 配置中。</p>
</blockquote>
<p>比如你有一个 service 叫 <code>nginx</code> 在 <code>prod</code> 命名空间，那么它的 FQDN 是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx.prod.svc.cluster.local</span><br></pre></td></tr></table></figure>

<p>可以从任何命名空间使用这个 FQDN 访问该服务。</p>
<hr>
<h2 id="✅-三、FQDN-与非-FQDN-的区别"><a href="#✅-三、FQDN-与非-FQDN-的区别" class="headerlink" title="✅ 三、FQDN 与非 FQDN 的区别"></a>✅ 三、FQDN 与非 FQDN 的区别</h2><table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
<th>是否全局唯一</th>
<th>是否依赖 search 域</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody><tr>
<td>FQDN</td>
<td><code>nginx.prod.svc.cluster.local</code></td>
<td>✅ 是</td>
<td>❌ 不依赖</td>
<td>✅ 推荐</td>
</tr>
<tr>
<td>非 FQDN（短域名）</td>
<td><code>nginx</code> 或 <code>nginx.prod</code></td>
<td>❌ 可能冲突</td>
<td>✅ 依赖</td>
<td>❌ 不推荐跨命名空间</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-四、使用-FQDN-的好处"><a href="#✅-四、使用-FQDN-的好处" class="headerlink" title="✅ 四、使用 FQDN 的好处"></a>✅ 四、使用 FQDN 的好处</h2><ol>
<li><p><strong>跨命名空间通信稳定</strong></p>
<ul>
<li>使用完整域名 <code>svc.ns.svc.cluster.local</code> 不依赖 DNS search path</li>
</ul>
</li>
<li><p><strong>更高的安全性和确定性</strong></p>
<ul>
<li>避免访问到其他命名空间中重名的 service（比如 <code>nginx</code>）</li>
</ul>
</li>
<li><p><strong>跨集群 DNS 联通（例如 Service Mesh、多集群）</strong></p>
<ul>
<li>多集群环境中可以借助 FQDN 显式指定服务源</li>
</ul>
</li>
<li><p><strong>自动证书绑定（如 Istio、cert-manager）</strong></p>
<ul>
<li>证书签发常用 FQDN 作为 <code>CommonName</code> 或 <code>SAN</code></li>
</ul>
</li>
</ol>
<hr>
<h2 id="✅-五、K8s-真实案例"><a href="#✅-五、K8s-真实案例" class="headerlink" title="✅ 五、K8s 真实案例"></a>✅ 五、K8s 真实案例</h2><h3 id="🔸-kubectl-exec-调试时："><a href="#🔸-kubectl-exec-调试时：" class="headerlink" title="🔸 kubectl exec 调试时："></a>🔸 <code>kubectl exec</code> 调试时：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl nginx.default.svc.cluster.local:80</span><br></pre></td></tr></table></figure>

<h3 id="🔸-Ingress、Istio-中配置主机名路由："><a href="#🔸-Ingress、Istio-中配置主机名路由：" class="headerlink" title="🔸 Ingress、Istio 中配置主机名路由："></a>🔸 Ingress、Istio 中配置主机名路由：</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">host:</span> <span class="string">my-app.dev.svc.cluster.local</span></span><br></pre></td></tr></table></figure>

<h3 id="🔸-cert-manager-Issuer-中的-DNS-SAN-配置："><a href="#🔸-cert-manager-Issuer-中的-DNS-SAN-配置：" class="headerlink" title="🔸 cert-manager Issuer 中的 DNS SAN 配置："></a>🔸 cert-manager Issuer 中的 DNS SAN 配置：</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dnsNames:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">rancher.qihoo.net</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">harbor.qa.qihoo.net</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-六、如何查看当前集群-FQDN-后缀？"><a href="#✅-六、如何查看当前集群-FQDN-后缀？" class="headerlink" title="✅ 六、如何查看当前集群 FQDN 后缀？"></a>✅ 六、如何查看当前集群 FQDN 后缀？</h2><p>你可以查看 kubelet 或 CoreDNS 的 DNS 配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/resolv.conf</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search default.svc.cluster.local svc.cluster.local cluster.local</span><br><span class="line">nameserver 10.43.0.10</span><br></pre></td></tr></table></figure>

<p>这表示你在 <code>default</code> 命名空间时，短域名会自动补齐成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;name&gt;.default.svc.cluster.local</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-总结表格"><a href="#✅-总结表格" class="headerlink" title="✅ 总结表格"></a>✅ 总结表格</h2><table>
<thead>
<tr>
<th>概念</th>
<th>描述</th>
<th>典型示例</th>
</tr>
</thead>
<tbody><tr>
<td>FQDN</td>
<td>完全限定域名，从主机名到根域的全路径</td>
<td><code>svc.ns.svc.cluster.local</code></td>
</tr>
<tr>
<td>简短域名</td>
<td>极简写法，仅用于当前 namespace 内</td>
<td><code>svc</code></td>
</tr>
<tr>
<td>推荐场景</td>
<td>跨命名空间访问 &#x2F; TLS 绑定 &#x2F; 多集群 &#x2F; Istio 等</td>
<td>必须使用 FQDN</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>SSE 与 WebSocket 示例项目</title>
    <url>/2025/07/29/SSE-%E4%B8%8E-WebSocket-%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>本项目演示：</p>
<ul>
<li>使用 Go 构建 SSE（Server-Sent Events）服务</li>
<li>使用 Go 构建 WebSocket 服务</li>
<li>客户端如何接收消息</li>
<li>与 nginx 配置整合测试</li>
</ul>
<hr>
<h2 id="🧱-项目结构"><a href="#🧱-项目结构" class="headerlink" title="🧱 项目结构"></a>🧱 项目结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── client</span><br><span class="line">│  ├── sse.go</span><br><span class="line">│  └── ws.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── nginx</span><br><span class="line">│  └── nginx.conf</span><br><span class="line">└── server</span><br><span class="line">    └── main.go</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📘-SSE-服务端（支持-id、event）"><a href="#📘-SSE-服务端（支持-id、event）" class="headerlink" title="📘 SSE 服务端（支持 id、event）"></a>📘 SSE 服务端（支持 id、event）</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 文件: server/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;github.com/gorilla/websocket&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> upgrader = websocket.Upgrader&#123;</span><br><span class="line">  CheckOrigin: <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wsHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  upgrader := websocket.Upgrader&#123;</span><br><span class="line">    CheckOrigin: <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  conn, err := upgrader.Upgrade(w, r, <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(<span class="string">&quot;Upgrade failed:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    msg := fmt.Sprintf(<span class="string">&quot;WebSocket message %d&quot;</span>, i)</span><br><span class="line">    conn.WriteMessage(websocket.TextMessage, []<span class="type">byte</span>(msg))</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SSE 服务端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sseHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  flusher, ok := w.(http.Flusher)</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    http.Error(w, <span class="string">&quot;Streaming unsupported!&quot;</span>, http.StatusInternalServerError)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SSE 使用 text/event-stream 类型</span></span><br><span class="line">  w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/event-stream&quot;</span>)</span><br><span class="line">  <span class="comment">// 不缓存</span></span><br><span class="line">  w.Header().Set(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>)</span><br><span class="line">  <span class="comment">// 保持连接  </span></span><br><span class="line">  w.Header().Set(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;keep-alive&quot;</span>)</span><br><span class="line">  w.WriteHeader(http.StatusOK)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;id: %d\n&quot;</span>, i)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;event: message\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SSE 格式，每条 event 必须以空行结尾,data: 是标准前缀，表示数据内容</span></span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;data: SSE message %d\n\n&quot;</span>, i)</span><br><span class="line">    <span class="comment">// 强制刷新，立即发送给客户端</span></span><br><span class="line">    flusher.Flush()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/sse&quot;</span>, sseHandler)</span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/ws&quot;</span>, wsHandler)</span><br><span class="line">  log.Println(<span class="string">&quot;Listening on :8080...&quot;</span>)</span><br><span class="line">  http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="🧪-SSE-客户端（Go-示例）"><a href="#🧪-SSE-客户端（Go-示例）" class="headerlink" title="🧪 SSE 客户端（Go 示例）"></a>🧪 SSE 客户端（Go 示例）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">#文件client/sse.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;bufio&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  resp, err := http.Get(<span class="string">&quot;http://localhost:8081/sse&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;Client request failed: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">  scanner := bufio.NewScanner(resp.Body)</span><br><span class="line">  <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">    line := scanner.Text()</span><br><span class="line">    <span class="keyword">if</span> strings.HasPrefix(line, <span class="string">&quot;data: &quot;</span>) &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Received:&quot;</span>, strings.TrimPrefix(line, <span class="string">&quot;data: &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🧪-Websocket-客户端（Go-示例）"><a href="#🧪-Websocket-客户端（Go-示例）" class="headerlink" title="🧪 Websocket 客户端（Go 示例）"></a>🧪 Websocket 客户端（Go 示例）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#文件client/ws.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;log&quot;</span><br><span class="line">  &quot;net/url&quot;</span><br><span class="line">  &quot;os&quot;</span><br><span class="line">  &quot;os/signal&quot;</span><br><span class="line">  &quot;time&quot;</span><br><span class="line"></span><br><span class="line">  &quot;github.com/gorilla/websocket&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  interrupt := make(chan os.Signal, 1)</span><br><span class="line">  signal.Notify(interrupt, os.Interrupt)</span><br><span class="line"></span><br><span class="line">  u := url.URL&#123;Scheme: &quot;ws&quot;, Host: &quot;localhost:8081&quot;, Path: &quot;/ws&quot;&#125;</span><br><span class="line">  log.Printf(&quot;connecting to %s&quot;, u.String())</span><br><span class="line"></span><br><span class="line">  c, _, err := websocket.DefaultDialer.Dial(u.String(), nil)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    log.Fatal(&quot;dial error:&quot;, err)</span><br><span class="line">  &#125;</span><br><span class="line">  defer c.Close()</span><br><span class="line"></span><br><span class="line">  done := make(chan struct&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  go func() &#123;</span><br><span class="line">    defer close(done)</span><br><span class="line">    for &#123;</span><br><span class="line">      _, message, err := c.ReadMessage()</span><br><span class="line">      if err != nil &#123;</span><br><span class="line">        log.Println(&quot;read error:&quot;, err)</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      log.Printf(&quot;recv: %s&quot;, message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  // 发送一条消息</span><br><span class="line">  err = c.WriteMessage(websocket.TextMessage, []byte(&quot;hello websocket&quot;))</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    log.Println(&quot;write error:&quot;, err)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 等待或者中断</span><br><span class="line">  select &#123;</span><br><span class="line">  case &lt;-time.After(time.Second * 10):</span><br><span class="line">  case &lt;-interrupt:</span><br><span class="line">    log.Println(&quot;interrupt&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 优雅关闭</span><br><span class="line">  err = c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, &quot;&quot;))</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">    log.Println(&quot;close error:&quot;, err)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="⚙️-Nginx-配置（nginx-nginx-conf）"><a href="#⚙️-Nginx-配置（nginx-nginx-conf）" class="headerlink" title="⚙️ Nginx 配置（nginx&#x2F;nginx.conf）"></a>⚙️ Nginx 配置（nginx&#x2F;nginx.conf）</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#NGINX 代理 WebSocket</span></span><br><span class="line"><span class="comment">#确保 NGINX 配置了 proxy_http_version 1.1 和 Upgrade 头</span></span><br><span class="line"><span class="comment">#如果你要支持 wss://，需要配置 TLS 证书或通过 NGINX termination</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">upstream</span> backend &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">172.17.0.1:8080</span>; //或者使用宿主机的<span class="attribute">ip</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /sse &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend/sse;</span><br><span class="line">            <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Connection <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">chunked_transfer_encoding</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">proxy_buffering</span> <span class="literal">off</span>;   <span class="comment"># &lt;-- 关闭缓冲，对 SSE 非常重要</span></span><br><span class="line">            <span class="attribute">proxy_cache</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">proxy_read_timeout</span> <span class="number">3600s</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /ws &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend/ws;</span><br><span class="line">            <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;Upgrade&quot;</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">	    <span class="attribute">proxy_read_timeout</span> <span class="number">3600s</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🚀-启动测试"><a href="#🚀-启动测试" class="headerlink" title="🚀 启动测试"></a>🚀 启动测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#容器启动nginx</span><br><span class="line">docker run --rm -v $(pwd)/nginx.conf:/etc/nginx/nginx.conf:ro -p 8081:8081 nginx</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔬-WebSocket-客户端测试（使用-wscat-或浏览器）"><a href="#🔬-WebSocket-客户端测试（使用-wscat-或浏览器）" class="headerlink" title="🔬 WebSocket 客户端测试（使用 wscat 或浏览器）"></a>🔬 WebSocket 客户端测试（使用 wscat 或浏览器）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在 Linux 上运行 Docker 时，如果服务运行在宿主机，可以让 NGINX 容器通过 宿主 IP 访问服务。</span></span><br><span class="line"><span class="comment">#ip addr show docker0</span></span><br><span class="line">5: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default</span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:06:96:79:9e brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:6ff:fe96:799e/64 scope <span class="built_in">link</span></span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#访问方式</span></span><br><span class="line">SSE:</span><br><span class="line">①非代理</span><br><span class="line">curl http://localhost:8080/sse</span><br><span class="line">②使用代理</span><br><span class="line">curl http://localhost:8081/sse</span><br><span class="line"></span><br><span class="line">WebSocket:</span><br><span class="line">①使用npm插件wscat</span><br><span class="line"><span class="comment">#npm安装地址：https://nodejs.org/en/download</span></span><br><span class="line"><span class="comment">#升级：npm install -g npm@11.5.1</span></span><br><span class="line">npm install -g wscat</span><br><span class="line"><span class="comment">#普通明文连接，服务端监听的是 非加密 的 WebSocket</span></span><br><span class="line">wscat -c ws://localhost:8081/ws</span><br><span class="line"></span><br><span class="line"><span class="comment">#wss://...</span></span><br><span class="line">加密连接（TLS），客户端期待服务端提供 有效的 HTTPS 证书 和支持 TLS 握手。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">②在线访问</span><br><span class="line">https://www.piesocket.com/websocket-tester</span><br><span class="line">chrome插件请求：PieSocket WebSocket Tester</span><br><span class="line">ws://10.16.217.194:8080/ws</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<hr>
<h2 id="📑-SSE-与-WebSocket-对比"><a href="#📑-SSE-与-WebSocket-对比" class="headerlink" title="📑 SSE 与 WebSocket 对比"></a>📑 SSE 与 WebSocket 对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>SSE</th>
<th>WebSocket</th>
</tr>
</thead>
<tbody><tr>
<td>协议</td>
<td>HTTP 单向</td>
<td>TCP 双向</td>
</tr>
<tr>
<td>通信方向</td>
<td>服务端 → 客户端</td>
<td>双向</td>
</tr>
<tr>
<td>使用场景</td>
<td>实时数据推送（如日志&#x2F;股价）</td>
<td>聊天室、在线游戏等交互应用</td>
</tr>
<tr>
<td>浏览器支持</td>
<td>较好（但不支持 IE）</td>
<td>广泛支持</td>
</tr>
<tr>
<td>连接数量</td>
<td>多 tab 共用连接</td>
<td>每 tab 独立连接</td>
</tr>
<tr>
<td>中间件兼容性</td>
<td>支持传统代理（如 nginx）</td>
<td>需显式支持升级</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> +--------------------+</span><br><span class="line"> |     WebSocket      | &lt;-- 双向、长连接、低延迟</span><br><span class="line"> +--------------------+</span><br><span class="line">            ↑</span><br><span class="line">    实时性强、互动性强</span><br><span class="line">            ↓</span><br><span class="line">+---------------------+</span><br><span class="line">|  HTTP Stream / SSE  | &lt;-- 单向、长连接、简单</span><br><span class="line">+---------------------+</span><br><span class="line">            ↑</span><br><span class="line">   仅服务推送数据、轻实时</span><br><span class="line">            ↓</span><br><span class="line">   +------------------+</span><br><span class="line">   | HTTP Keep-Alive  | &lt;-- 短连接的改进版</span><br><span class="line">   +------------------+</span><br><span class="line">            ↑</span><br><span class="line">    常规请求，非实时</span><br><span class="line">            ↓</span><br><span class="line">   +------------------+</span><br><span class="line">   |   短连接（HTTP） | &lt;-- 最原始的方式</span><br><span class="line">   +------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>长连接</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump抓包指南</title>
    <url>/2025/07/31/tcpdump%E6%8A%93%E5%8C%85%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="tcpdump-网络问题排查完整指南"><a href="#tcpdump-网络问题排查完整指南" class="headerlink" title="tcpdump 网络问题排查完整指南"></a>tcpdump 网络问题排查完整指南</h1><h2 id="🎯-目录"><a href="#🎯-目录" class="headerlink" title="🎯 目录"></a>🎯 目录</h2><ul>
<li><a href="#%E6%8A%93%E5%8C%85%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">抓包前的准备工作</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF">常见网络问题场景</a></li>
<li><a href="#tcpdump-%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3">tcpdump 命令参数详解</a></li>
<li><a href="#%E5%AE%9E%E6%88%98%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%91%BD%E4%BB%A4">实战场景与命令</a></li>
<li><a href="#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95">结果分析方法</a></li>
<li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">最佳实践与注意事项</a></li>
</ul>
<hr>
<h2 id="抓包前的准备工作"><a href="#抓包前的准备工作" class="headerlink" title="抓包前的准备工作"></a>抓包前的准备工作</h2><h3 id="1-问题定义阶段"><a href="#1-问题定义阶段" class="headerlink" title="1. 问题定义阶段"></a>1. 问题定义阶段</h3><p><strong>在开始抓包前，必须明确以下问题：</strong></p>
<ul>
<li>🔍 <strong>具体现象</strong>：连接超时？响应慢？数据包丢失？</li>
<li>📍 <strong>问题范围</strong>：客户端？服务端？中间网络设备？</li>
<li>⏰ <strong>发生时间</strong>：持续发生？间歇性？特定时间段？</li>
<li>🌐 <strong>网络拓扑</strong>：了解数据包的完整传输路径</li>
<li>📊 <strong>基线数据</strong>：正常情况下的网络表现如何？</li>
</ul>
<h3 id="2-环境信息收集"><a href="#2-环境信息收集" class="headerlink" title="2. 环境信息收集"></a>2. 环境信息收集</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查网络接口</span></span><br><span class="line">ip addr show</span><br><span class="line">ifconfig -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查路由表</span></span><br><span class="line">ip route show</span><br><span class="line">route -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查网络连接状态</span></span><br><span class="line">ss -tuln</span><br><span class="line">netstat -tuln</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查系统资源</span></span><br><span class="line">free -h</span><br><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure>

<h3 id="3-权限和工具准备"><a href="#3-权限和工具准备" class="headerlink" title="3. 权限和工具准备"></a>3. 权限和工具准备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确保有足够权限</span></span><br><span class="line"><span class="built_in">sudo</span> -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 tcpdump 版本</span></span><br><span class="line">tcpdump --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查磁盘空间（抓包文件可能很大）</span></span><br><span class="line"><span class="built_in">df</span> -h /tmp</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="常见网络问题场景"><a href="#常见网络问题场景" class="headerlink" title="常见网络问题场景"></a>常见网络问题场景</h2><h3 id="🚨-场景分类表"><a href="#🚨-场景分类表" class="headerlink" title="🚨 场景分类表"></a>🚨 场景分类表</h3><table>
<thead>
<tr>
<th>场景类型</th>
<th>典型问题</th>
<th>关注重点</th>
<th>预期结果</th>
</tr>
</thead>
<tbody><tr>
<td><strong>连接建立问题</strong></td>
<td>连接超时、拒绝连接</td>
<td>TCP 三次握手</td>
<td>SYN, SYN-ACK, ACK</td>
</tr>
<tr>
<td><strong>性能问题</strong></td>
<td>响应慢、吞吐量低</td>
<td>延迟、重传、窗口大小</td>
<td>RTT, 重传率</td>
</tr>
<tr>
<td><strong>DNS 解析问题</strong></td>
<td>域名无法解析</td>
<td>DNS 查询和响应</td>
<td>Query&#x2F;Response 匹配</td>
</tr>
<tr>
<td><strong>HTTP&#x2F;HTTPS 问题</strong></td>
<td>4xx&#x2F;5xx 错误、SSL 握手失败</td>
<td>应用层协议</td>
<td>HTTP 状态码、TLS 握手</td>
</tr>
<tr>
<td><strong>防火墙&#x2F;安全问题</strong></td>
<td>包被丢弃、端口不通</td>
<td>ICMP 消息、RST 包</td>
<td>拒绝原因分析</td>
</tr>
<tr>
<td><strong>负载均衡问题</strong></td>
<td>请求分布不均、健康检查失败</td>
<td>多目标流量分析</td>
<td>负载分布模式</td>
</tr>
</tbody></table>
<hr>
<h2 id="tcpdump-命令参数详解"><a href="#tcpdump-命令参数详解" class="headerlink" title="tcpdump 命令参数详解"></a>tcpdump 命令参数详解</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump [选项] [过滤表达式]</span><br></pre></td></tr></table></figure>

<h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-i</code></td>
<td>指定网络接口</td>
<td><code>-i eth0</code>, <code>-i any</code></td>
</tr>
<tr>
<td><code>-w</code></td>
<td>写入文件</td>
<td><code>-w capture.pcap</code></td>
</tr>
<tr>
<td><code>-r</code></td>
<td>读取文件</td>
<td><code>-r capture.pcap</code></td>
</tr>
<tr>
<td><code>-c</code></td>
<td>捕获包数量</td>
<td><code>-c 1000</code></td>
</tr>
<tr>
<td><code>-n</code></td>
<td>不解析主机名</td>
<td><code>-n</code></td>
</tr>
<tr>
<td><code>-nn</code></td>
<td>不解析主机名和端口名</td>
<td><code>-nn</code></td>
</tr>
<tr>
<td><code>-v/-vv/-vvv</code></td>
<td>详细程度</td>
<td><code>-vv</code></td>
</tr>
<tr>
<td><code>-s</code></td>
<td>每个包的捕获长度</td>
<td><code>-s 65535</code> (完整包)</td>
</tr>
<tr>
<td><code>-X</code></td>
<td>十六进制和ASCII显示</td>
<td><code>-X</code></td>
</tr>
<tr>
<td><code>-A</code></td>
<td>ASCII 显示</td>
<td><code>-A</code></td>
</tr>
<tr>
<td><code>-t</code></td>
<td>不显示时间戳</td>
<td><code>-t</code></td>
</tr>
<tr>
<td><code>-tt</code></td>
<td>显示精确时间戳</td>
<td><code>-tt</code></td>
</tr>
</tbody></table>
<h3 id="过滤表达式"><a href="#过滤表达式" class="headerlink" title="过滤表达式"></a>过滤表达式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机过滤</span></span><br><span class="line">host 192.168.1.100</span><br><span class="line">src host 192.168.1.100</span><br><span class="line">dst host 192.168.1.100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口过滤</span></span><br><span class="line">port 80</span><br><span class="line">src port 8080</span><br><span class="line">dst port 443</span><br><span class="line">portrange 8000-8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 协议过滤</span></span><br><span class="line">tcp</span><br><span class="line">udp</span><br><span class="line">icmp</span><br><span class="line">arp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络过滤</span></span><br><span class="line">net 192.168.1.0/24</span><br><span class="line">src net 10.0.0.0/8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逻辑操作符</span></span><br><span class="line">and, or, not</span><br><span class="line"><span class="comment"># 示例：tcp and port 80 and host 192.168.1.100</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="实战场景与命令"><a href="#实战场景与命令" class="headerlink" title="实战场景与命令"></a>实战场景与命令</h2><h3 id="场景1：TCP-连接问题排查"><a href="#场景1：TCP-连接问题排查" class="headerlink" title="场景1：TCP 连接问题排查"></a>场景1：TCP 连接问题排查</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>应用连接数据库超时，需要确认是网络问题还是应用问题。</p>
<h4 id="定位思路"><a href="#定位思路" class="headerlink" title="定位思路"></a>定位思路</h4><ol>
<li>确认 TCP 三次握手是否正常</li>
<li>检查是否有 RST 包</li>
<li>分析连接建立时间</li>
</ol>
<h4 id="抓包命令"><a href="#抓包命令" class="headerlink" title="抓包命令"></a>抓包命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 抓取特定主机和端口的 TCP 连接</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -vv -s 65535 \</span><br><span class="line">  -w tcp_connection_$(<span class="built_in">date</span> +%Y%m%d_%H%M%S).pcap \</span><br><span class="line">  <span class="string">&quot;host 192.168.1.100 and port 3306 and tcp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时查看 TCP 握手过程</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -vv <span class="string">&quot;tcp[tcpflags] &amp; (tcp-syn|tcp-ack) != 0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只看 SYN 包</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn <span class="string">&quot;tcp[tcpflags] &amp; tcp-syn != 0&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常的 TCP 握手应该看到：</span></span><br><span class="line"><span class="comment"># 1. Client -&gt; Server: SYN</span></span><br><span class="line"><span class="comment"># 2. Server -&gt; Client: SYN, ACK  </span></span><br><span class="line"><span class="comment"># 3. Client -&gt; Server: ACK</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 异常情况：</span></span><br><span class="line"><span class="comment"># - 只有 SYN，没有 SYN-ACK：服务端未响应</span></span><br><span class="line"><span class="comment"># - SYN-ACK 后有 RST：连接被重置</span></span><br><span class="line"><span class="comment"># - 重复的 SYN：网络延迟或丢包</span></span><br></pre></td></tr></table></figure>

<h3 id="场景2：HTTP-HTTPS-问题排查"><a href="#场景2：HTTP-HTTPS-问题排查" class="headerlink" title="场景2：HTTP&#x2F;HTTPS 问题排查"></a>场景2：HTTP&#x2F;HTTPS 问题排查</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>Web 应用响应慢，用户反馈页面加载时间长。</p>
<h4 id="定位思路-1"><a href="#定位思路-1" class="headerlink" title="定位思路"></a>定位思路</h4><ol>
<li>分析 HTTP 请求和响应时间</li>
<li>检查 HTTP 状态码</li>
<li>分析 SSL&#x2F;TLS 握手时间</li>
</ol>
<h4 id="抓包命令-1"><a href="#抓包命令-1" class="headerlink" title="抓包命令"></a>抓包命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 抓取 HTTP 流量</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -A -s 65535 \</span><br><span class="line">  -w http_debug_$(<span class="built_in">date</span> +%Y%m%d_%H%M%S).pcap \</span><br><span class="line">  <span class="string">&quot;port 80 or port 8080&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取 HTTPS 流量（包含 TLS 握手）</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -vv -s 65535 \</span><br><span class="line">  -w https_debug_$(<span class="built_in">date</span> +%Y%m%d_%H%M%S).pcap \</span><br><span class="line">  <span class="string">&quot;port 443&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时查看 HTTP 请求</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -A <span class="string">&quot;port 80 and tcp and host 192.168.1.100&quot;</span> \</span><br><span class="line">  | grep -E <span class="string">&quot;(GET|POST|PUT|DELETE|HTTP)&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HTTP 请求分析要点：</span></span><br><span class="line"><span class="comment"># 1. 请求方法和 URL</span></span><br><span class="line"><span class="comment"># 2. User-Agent 和其他头信息</span></span><br><span class="line"><span class="comment"># 3. 响应状态码（200, 404, 500 等）</span></span><br><span class="line"><span class="comment"># 4. Content-Length 和传输时间</span></span><br><span class="line"><span class="comment"># 5. Keep-Alive 连接复用情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTPS 分析要点：</span></span><br><span class="line"><span class="comment"># 1. TLS 握手时间</span></span><br><span class="line"><span class="comment"># 2. 证书交换过程</span></span><br><span class="line"><span class="comment"># 3. 加密后的数据传输量</span></span><br></pre></td></tr></table></figure>

<h3 id="场景3：DNS-解析问题"><a href="#场景3：DNS-解析问题" class="headerlink" title="场景3：DNS 解析问题"></a>场景3：DNS 解析问题</h3><h4 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h4><p>域名解析失败或解析慢，影响应用启动。</p>
<h4 id="定位思路-2"><a href="#定位思路-2" class="headerlink" title="定位思路"></a>定位思路</h4><ol>
<li>捕获 DNS 查询和响应</li>
<li>分析解析时间</li>
<li>检查 DNS 服务器响应</li>
</ol>
<h4 id="抓包命令-2"><a href="#抓包命令-2" class="headerlink" title="抓包命令"></a>抓包命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 抓取 DNS 查询</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -vv -s 65535 \</span><br><span class="line">  -w dns_debug_$(<span class="built_in">date</span> +%Y%m%d_%H%M%S).pcap \</span><br><span class="line">  <span class="string">&quot;port 53&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时查看 DNS 查询</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn <span class="string">&quot;port 53&quot;</span> | \</span><br><span class="line">  <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[<span class="subst">$(date &#x27;+%H:%M:%S&#x27;)</span>] <span class="variable">$line</span>&quot;</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取特定域名的 DNS 查询</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -vv <span class="string">&quot;port 53 and host 8.8.8.8&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="结果分析-2"><a href="#结果分析-2" class="headerlink" title="结果分析"></a>结果分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DNS 分析要点：</span></span><br><span class="line"><span class="comment"># 1. 查询类型（A, AAAA, CNAME, MX 等）</span></span><br><span class="line"><span class="comment"># 2. 查询域名和响应 IP</span></span><br><span class="line"><span class="comment"># 3. 响应时间（Query -&gt; Response 间隔）</span></span><br><span class="line"><span class="comment"># 4. DNS 服务器是否响应</span></span><br><span class="line"><span class="comment"># 5. NXDOMAIN 错误（域名不存在）</span></span><br></pre></td></tr></table></figure>

<h3 id="场景4：网络延迟和丢包分析"><a href="#场景4：网络延迟和丢包分析" class="headerlink" title="场景4：网络延迟和丢包分析"></a>场景4：网络延迟和丢包分析</h3><h4 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h4><p>网络传输慢，怀疑有丢包或高延迟。</p>
<h4 id="定位思路-3"><a href="#定位思路-3" class="headerlink" title="定位思路"></a>定位思路</h4><ol>
<li>分析 RTT（往返时间）</li>
<li>检测重传包</li>
<li>分析 TCP 窗口大小</li>
</ol>
<h4 id="抓包命令-3"><a href="#抓包命令-3" class="headerlink" title="抓包命令"></a>抓包命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 抓取 ICMP ping 包分析延迟</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -vv \</span><br><span class="line">  -w ping_analysis_$(<span class="built_in">date</span> +%Y%m%d_%H%M%S).pcap \</span><br><span class="line">  <span class="string">&quot;icmp and host 192.168.1.100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取 TCP 重传包</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -vv \</span><br><span class="line">  <span class="string">&quot;tcp and host 192.168.1.100&quot;</span> | \</span><br><span class="line">  grep -E <span class="string">&quot;(retransmission|duplicate)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取所有流量分析窗口大小</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -vv -s 96 \</span><br><span class="line">  -w network_performance_$(<span class="built_in">date</span> +%Y%m%d_%H%M%S).pcap \</span><br><span class="line">  <span class="string">&quot;tcp and host 192.168.1.100&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="结果分析-3"><a href="#结果分析-3" class="headerlink" title="结果分析"></a>结果分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 延迟分析：</span></span><br><span class="line"><span class="comment"># 1. ICMP ping 的往返时间</span></span><br><span class="line"><span class="comment"># 2. TCP SYN -&gt; SYN-ACK 的时间间隔</span></span><br><span class="line"><span class="comment"># 3. HTTP 请求 -&gt; 响应的时间间隔</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 丢包分析：</span></span><br><span class="line"><span class="comment"># 1. 重复的 ACK 包</span></span><br><span class="line"><span class="comment"># 2. TCP 重传</span></span><br><span class="line"><span class="comment"># 3. 窗口大小变化</span></span><br></pre></td></tr></table></figure>

<h3 id="场景5：容器网络问题"><a href="#场景5：容器网络问题" class="headerlink" title="场景5：容器网络问题"></a>场景5：容器网络问题</h3><h4 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h4><p>Kubernetes 集群中 Pod 间通信异常。</p>
<h4 id="定位思路-4"><a href="#定位思路-4" class="headerlink" title="定位思路"></a>定位思路</h4><ol>
<li>在不同网络层面抓包</li>
<li>分析容器网络接口</li>
<li>检查 iptables 规则影响</li>
</ol>
<h4 id="抓包命令-4"><a href="#抓包命令-4" class="headerlink" title="抓包命令"></a>抓包命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在宿主机抓取所有容器流量</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i docker0 -nn -vv \</span><br><span class="line">  -w container_network_$(<span class="built_in">date</span> +%Y%m%d_%H%M%S).pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取特定 Pod IP 的流量</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -vv \</span><br><span class="line">  <span class="string">&quot;host 10.244.1.100&quot;</span> \</span><br><span class="line">  -w pod_communication_$(<span class="built_in">date</span> +%Y%m%d_%H%M%S).pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器内抓包</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it pod-name -c container-name -- \</span><br><span class="line">  tcpdump -i eth0 -nn -vv -w - &gt; container_internal.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取 CNI 网络接口流量</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i cni0 -nn -vv \</span><br><span class="line">  -w cni_traffic_$(<span class="built_in">date</span> +%Y%m%d_%H%M%S).pcap</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="结果分析方法"><a href="#结果分析方法" class="headerlink" title="结果分析方法"></a>结果分析方法</h2><h3 id="1-使用-Wireshark-图形化分析"><a href="#1-使用-Wireshark-图形化分析" class="headerlink" title="1. 使用 Wireshark 图形化分析"></a>1. 使用 Wireshark 图形化分析</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 pcap 文件导入 Wireshark</span></span><br><span class="line">wireshark capture.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用 Wireshark 过滤器</span></span><br><span class="line">tcp.analysis.flags</span><br><span class="line">http.response.code != 200</span><br><span class="line">dns.flags.response == 0</span><br><span class="line">tcp.analysis.retransmission</span><br></pre></td></tr></table></figure>

<h3 id="2-命令行快速分析"><a href="#2-命令行快速分析" class="headerlink" title="2. 命令行快速分析"></a>2. 命令行快速分析</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计协议分布</span></span><br><span class="line">tcpdump -r capture.pcap -nn | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计目标 IP</span></span><br><span class="line">tcpdump -r capture.pcap -nn | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> | <span class="built_in">cut</span> -d: -f1 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找特定错误</span></span><br><span class="line">tcpdump -r capture.pcap -nn -A | grep -i <span class="string">&quot;error\|timeout\|refused&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析连接时间</span></span><br><span class="line">tcpdump -r capture.pcap -nn -tt | grep -E <span class="string">&quot;SYN|ACK&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-数据包分析清单"><a href="#3-数据包分析清单" class="headerlink" title="3. 数据包分析清单"></a>3. 数据包分析清单</h3><h4 id="TCP-连接分析"><a href="#TCP-连接分析" class="headerlink" title="TCP 连接分析"></a>TCP 连接分析</h4><ul>
<li><input disabled="" type="checkbox"> SYN, SYN-ACK, ACK 三次握手完整</li>
<li><input disabled="" type="checkbox"> 序列号和确认号正确递增</li>
<li><input disabled="" type="checkbox"> 无异常 RST 包</li>
<li><input disabled="" type="checkbox"> 窗口大小合理</li>
<li><input disabled="" type="checkbox"> 无频繁重传</li>
</ul>
<h4 id="HTTP-分析"><a href="#HTTP-分析" class="headerlink" title="HTTP 分析"></a>HTTP 分析</h4><ul>
<li><input disabled="" type="checkbox"> 请求方法和 URL 正确</li>
<li><input disabled="" type="checkbox"> HTTP 状态码符合预期</li>
<li><input disabled="" type="checkbox"> 响应时间在合理范围</li>
<li><input disabled="" type="checkbox"> Content-Length 与实际内容匹配</li>
<li><input disabled="" type="checkbox"> 无异常重定向</li>
</ul>
<h4 id="DNS-分析"><a href="#DNS-分析" class="headerlink" title="DNS 分析"></a>DNS 分析</h4><ul>
<li><input disabled="" type="checkbox"> 查询和响应配对正确</li>
<li><input disabled="" type="checkbox"> 响应时间 &lt; 100ms</li>
<li><input disabled="" type="checkbox"> 无 NXDOMAIN 错误</li>
<li><input disabled="" type="checkbox"> DNS 服务器可达</li>
</ul>
<hr>
<h2 id="最佳实践与注意事项"><a href="#最佳实践与注意事项" class="headerlink" title="最佳实践与注意事项"></a>最佳实践与注意事项</h2><h3 id="✅-最佳实践"><a href="#✅-最佳实践" class="headerlink" title="✅ 最佳实践"></a>✅ 最佳实践</h3><h4 id="1-抓包策略"><a href="#1-抓包策略" class="headerlink" title="1. 抓包策略"></a>1. 抓包策略</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 始终使用时间戳和详细信息</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -vv -tt -s 65535</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大流量环境下限制抓包大小</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -c 10000 -s 128</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用轮转文件避免单文件过大</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -w capture.pcap -C 100 -W 5</span><br></pre></td></tr></table></figure>

<h4 id="2-过滤器优化"><a href="#2-过滤器优化" class="headerlink" title="2. 过滤器优化"></a>2. 过滤器优化</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 精确过滤减少无关流量</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn \</span><br><span class="line">  <span class="string">&quot;host 192.168.1.100 and port 80 and tcp[tcpflags] &amp; tcp-syn != 0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 BPF 过滤器提高性能</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn <span class="string">&quot;tcp and dst port 443&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建专门的抓包目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /tmp/tcpdump/$(<span class="built_in">date</span> +%Y%m%d)</span><br><span class="line"><span class="built_in">cd</span> /tmp/tcpdump/$(<span class="built_in">date</span> +%Y%m%d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用描述性文件名</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn -w <span class="string">&quot;<span class="subst">$(hostname)</span>_<span class="subst">$(date +%Y%m%d_%H%M%S)</span>_issue_description.pcap&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="⚠️-注意事项"><a href="#⚠️-注意事项" class="headerlink" title="⚠️ 注意事项"></a>⚠️ 注意事项</h3><h4 id="1-性能影响"><a href="#1-性能影响" class="headerlink" title="1. 性能影响"></a>1. 性能影响</h4><ul>
<li>大流量环境下抓包会消耗 CPU 和内存</li>
<li>使用适当的过滤器减少数据量</li>
<li>监控磁盘空间，避免写满系统盘</li>
</ul>
<h4 id="2-安全考虑"><a href="#2-安全考虑" class="headerlink" title="2. 安全考虑"></a>2. 安全考虑</h4><ul>
<li>抓包文件可能包含敏感信息</li>
<li>及时删除不需要的抓包文件</li>
<li>在生产环境抓包需要额外审批</li>
</ul>
<h4 id="3-法律合规"><a href="#3-法律合规" class="headerlink" title="3. 法律合规"></a>3. 法律合规</h4><ul>
<li>确保有权限抓取网络流量</li>
<li>遵守公司网络监控政策</li>
<li>不要抓取他人隐私数据</li>
</ul>
<h3 id="🔧-常用脚本模板"><a href="#🔧-常用脚本模板" class="headerlink" title="🔧 常用脚本模板"></a>🔧 常用脚本模板</h3><h4 id="自动化抓包脚本"><a href="#自动化抓包脚本" class="headerlink" title="自动化抓包脚本"></a>自动化抓包脚本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># tcpdump_auto.sh</span></span><br><span class="line"></span><br><span class="line">INTERFACE=<span class="variable">$&#123;1:-any&#125;</span></span><br><span class="line">FILTER=<span class="variable">$&#123;2:-&quot;&quot;&#125;</span></span><br><span class="line">DURATION=<span class="variable">$&#123;3:-60&#125;</span></span><br><span class="line">OUTPUT_DIR=<span class="string">&quot;/tmp/tcpdump&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$OUTPUT_DIR</span></span><br><span class="line">FILENAME=<span class="string">&quot;<span class="variable">$OUTPUT_DIR</span>/capture_<span class="subst">$(hostname)</span>_<span class="subst">$(date +%Y%m%d_%H%M%S)</span>.pcap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;开始抓包: <span class="variable">$DURATION</span> 秒&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;接口: <span class="variable">$INTERFACE</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;过滤器: <span class="variable">$FILTER</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;输出文件: <span class="variable">$FILENAME</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">timeout</span> <span class="variable">$DURATION</span> <span class="built_in">sudo</span> tcpdump -i <span class="variable">$INTERFACE</span> -nn -vv -s 65535 -w <span class="variable">$FILENAME</span> <span class="string">&quot;<span class="variable">$FILTER</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;抓包完成，文件大小: <span class="subst">$(du -h $FILENAME | cut -f1)</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;使用以下命令分析:&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;tcpdump -r <span class="variable">$FILENAME</span> -nn -vv | less&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;wireshark <span class="variable">$FILENAME</span> &amp;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="问题诊断检查清单"><a href="#问题诊断检查清单" class="headerlink" title="问题诊断检查清单"></a>问题诊断检查清单</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># network_check.sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=== 网络问题诊断检查清单 ===&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1. 基础连通性测试&quot;</span></span><br><span class="line">ping -c 4 <span class="variable">$1</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;✅ Ping 成功&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;❌ Ping 失败&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2. 端口连通性测试&quot;</span>  </span><br><span class="line">nc -zv <span class="variable">$1</span> <span class="variable">$2</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;✅ 端口 <span class="variable">$2</span> 可达&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;❌ 端口 <span class="variable">$2</span> 不可达&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;3. DNS 解析测试&quot;</span></span><br><span class="line">nslookup <span class="variable">$1</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;✅ DNS 解析成功&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;❌ DNS 解析失败&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;4. 路由跟踪&quot;</span></span><br><span class="line">traceroute <span class="variable">$1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;5. 开始详细抓包分析...&quot;</span></span><br><span class="line"><span class="comment"># 调用抓包脚本</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📚-扩展阅读"><a href="#📚-扩展阅读" class="headerlink" title="📚 扩展阅读"></a>📚 扩展阅读</h2><ul>
<li><a href="https://www.tcpdump.org/manpages/tcpdump.1.html">tcpdump 官方文档</a></li>
<li><a href="https://www.wireshark.org/docs/wsug_html_chunked/">Wireshark 用户指南</a></li>
<li><a href="https://tools.ietf.org/rfc/">网络协议栈分析方法</a></li>
</ul>
<hr>
<p><strong>最后更新时间：</strong> $(date +%Y-%m-%d)<br><strong>版本：</strong> v1.0<br><strong>维护者：</strong> Network Team</p>
]]></content>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump解析及分析指南</title>
    <url>/2025/07/31/tcpdump%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%88%86%E6%9E%90%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="tcpdump-输出解析与网络分析指南"><a href="#tcpdump-输出解析与网络分析指南" class="headerlink" title="tcpdump 输出解析与网络分析指南"></a>tcpdump 输出解析与网络分析指南</h1><h2 id="🎯-目录"><a href="#🎯-目录" class="headerlink" title="🎯 目录"></a>🎯 目录</h2><ul>
<li><a href="#tcp-flags-%E8%AF%A6%E8%A7%A3">TCP Flags 详解</a></li>
<li><a href="#tcpdump-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90">tcpdump 输出格式解析</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E5%AD%97%E6%AE%B5%E5%88%86%E6%9E%90">关键字段分析</a></li>
<li><a href="#%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90">典型场景分析</a></li>
<li><a href="#4%E5%B1%827%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%88%86%E6%9E%90">4层&#x2F;7层负载均衡分析</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E7%9F%A5%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86">服务端开发必知网络知识</a></li>
</ul>
<hr>
<h2 id="TCP-Flags-详解"><a href="#TCP-Flags-详解" class="headerlink" title="TCP Flags 详解"></a>TCP Flags 详解</h2><h3 id="🏁-TCP-Flags-标志位"><a href="#🏁-TCP-Flags-标志位" class="headerlink" title="🏁 TCP Flags 标志位"></a>🏁 TCP Flags 标志位</h3><table>
<thead>
<tr>
<th>Flag</th>
<th>符号</th>
<th>含义</th>
<th>作用</th>
<th>关注度</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SYN</strong></td>
<td><code>[S]</code></td>
<td>Synchronize</td>
<td>发起连接请求</td>
<td>⭐⭐⭐</td>
</tr>
<tr>
<td><strong>ACK</strong></td>
<td><code>[.]</code></td>
<td>Acknowledge</td>
<td>确认收到数据</td>
<td>⭐⭐⭐</td>
</tr>
<tr>
<td><strong>FIN</strong></td>
<td><code>[F]</code></td>
<td>Finish</td>
<td>请求关闭连接</td>
<td>⭐⭐⭐</td>
</tr>
<tr>
<td><strong>RST</strong></td>
<td><code>[R]</code></td>
<td>Reset</td>
<td>强制重置连接</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>PSH</strong></td>
<td><code>[P]</code></td>
<td>Push</td>
<td>立即推送数据</td>
<td>⭐⭐</td>
</tr>
<tr>
<td><strong>URG</strong></td>
<td><code>[U]</code></td>
<td>Urgent</td>
<td>紧急数据指针</td>
<td>⭐</td>
</tr>
<tr>
<td><strong>ECE</strong></td>
<td><code>[E]</code></td>
<td>ECN Echo</td>
<td>拥塞通知回显</td>
<td>⭐</td>
</tr>
<tr>
<td><strong>CWR</strong></td>
<td><code>[W]</code></td>
<td>Congestion Window Reduced</td>
<td>拥塞窗口减少</td>
<td>⭐</td>
</tr>
</tbody></table>
<h3 id="🔍-组合标志位含义"><a href="#🔍-组合标志位含义" class="headerlink" title="🔍 组合标志位含义"></a>🔍 组合标志位含义</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常见组合及含义</span></span><br><span class="line">[S]      <span class="comment"># SYN：连接建立请求</span></span><br><span class="line">[S.]     <span class="comment"># SYN+ACK：连接建立响应  </span></span><br><span class="line">[.]      <span class="comment"># ACK：普通数据确认</span></span><br><span class="line">[P.]     <span class="comment"># PSH+ACK：数据推送并确认</span></span><br><span class="line">[F.]     <span class="comment"># FIN+ACK：连接关闭请求</span></span><br><span class="line">[R]      <span class="comment"># RST：连接重置</span></span><br><span class="line">[R.]     <span class="comment"># RST+ACK：重置并确认</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 异常组合</span></span><br><span class="line">[S.R]    <span class="comment"># SYN+ACK+RST：拒绝连接</span></span><br><span class="line">[F.R]    <span class="comment"># FIN+ACK+RST：强制关闭</span></span><br></pre></td></tr></table></figure>

<h3 id="⚠️-RST-标志位深度解析"><a href="#⚠️-RST-标志位深度解析" class="headerlink" title="⚠️ RST 标志位深度解析"></a>⚠️ RST 标志位深度解析</h3><p><strong>RST (Reset) 的含义：</strong></p>
<ul>
<li>立即终止 TCP 连接</li>
<li>释放连接占用的资源</li>
<li>不经过正常的四次挥手过程</li>
</ul>
<p><strong>RST 产生的常见原因：</strong></p>
<ol>
<li><p><strong>端口不可达</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 目标端口没有监听服务</span></span><br><span class="line">13:21:34.963769 IP client.12345 &gt; server.8080: Flags [S]</span><br><span class="line">13:21:34.963888 IP server.8080 &gt; client.12345: Flags [R.]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>防火墙拒绝</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 防火墙规则阻止连接</span></span><br><span class="line">13:21:34.963769 IP client.12345 &gt; server.80: Flags [S]</span><br><span class="line">13:21:34.964001 IP server.80 &gt; client.12345: Flags [R.]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>应用程序异常关闭</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用崩溃或强制关闭socket</span></span><br><span class="line">13:21:35.123456 IP client.12345 &gt; server.8080: Flags [P.]</span><br><span class="line">13:21:35.123567 IP server.8080 &gt; client.12345: Flags [R]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>超时重置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接超时，系统自动重置</span></span><br><span class="line">13:21:35.500000 IP client.12345 &gt; server.8080: Flags [S]</span><br><span class="line"><span class="comment"># ... 无响应 ...</span></span><br><span class="line">13:21:40.500000 IP client.12345 &gt; server.8080: Flags [R]</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="tcpdump-输出格式解析"><a href="#tcpdump-输出格式解析" class="headerlink" title="tcpdump 输出格式解析"></a>tcpdump 输出格式解析</h2><h3 id="📋-标准输出格式"><a href="#📋-标准输出格式" class="headerlink" title="📋 标准输出格式"></a>📋 标准输出格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时间戳 IP (IP头信息) 源地址.端口 &gt; 目标地址.端口: Flags [标志], 序列号信息, 长度信息</span><br></pre></td></tr></table></figure>

<h3 id="🔬-详细字段解析"><a href="#🔬-详细字段解析" class="headerlink" title="🔬 详细字段解析"></a>🔬 详细字段解析</h3><p>以这个例子为基准：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13:21:12.082154 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 172, bad cksum 0 (-&gt;3c4a)!) 10.18.60.15.54444 &gt; 106.63.103.83.443: Flags [S], seq 123456789, win 65535, options [mss 1460], length 0</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字段</th>
<th>值</th>
<th>含义</th>
<th>关注点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>时间戳</strong></td>
<td><code>13:21:12.082154</code></td>
<td>精确到微秒的时间</td>
<td>用于计算延迟和超时</td>
</tr>
<tr>
<td><strong>协议</strong></td>
<td><code>IP</code></td>
<td>网络层协议</td>
<td>通常是 IP</td>
</tr>
<tr>
<td><strong>TOS</strong></td>
<td><code>tos 0x0</code></td>
<td>服务类型</td>
<td>QoS 标记，影响优先级</td>
</tr>
<tr>
<td><strong>TTL</strong></td>
<td><code>ttl 64</code></td>
<td>生存时间</td>
<td>剩余跳数，用于诊断路由</td>
</tr>
<tr>
<td><strong>ID</strong></td>
<td><code>id 0</code></td>
<td>数据包标识</td>
<td>用于分片重组</td>
</tr>
<tr>
<td><strong>Flags</strong></td>
<td><code>flags [DF]</code></td>
<td>IP 标志</td>
<td>DF&#x3D;不分片，MF&#x3D;更多分片</td>
</tr>
<tr>
<td><strong>协议号</strong></td>
<td><code>proto TCP (6)</code></td>
<td>传输层协议</td>
<td>TCP&#x3D;6, UDP&#x3D;17, ICMP&#x3D;1</td>
</tr>
<tr>
<td><strong>长度</strong></td>
<td><code>length 172</code></td>
<td>IP 包总长度</td>
<td>包括头部和数据</td>
</tr>
<tr>
<td><strong>校验和</strong></td>
<td><code>bad cksum</code></td>
<td>校验和错误</td>
<td>⚠️ 数据包可能损坏</td>
</tr>
<tr>
<td><strong>源&#x2F;目标</strong></td>
<td><code>10.18.60.15.54444 &gt; 106.63.103.83.443</code></td>
<td>源IP.端口 &gt; 目标IP.端口</td>
<td>通信端点</td>
</tr>
<tr>
<td><strong>TCP标志</strong></td>
<td><code>Flags [S]</code></td>
<td>TCP 控制位</td>
<td>连接状态控制</td>
</tr>
<tr>
<td><strong>序列号</strong></td>
<td><code>seq 123456789</code></td>
<td>序列号</td>
<td>数据排序和去重</td>
</tr>
<tr>
<td><strong>窗口大小</strong></td>
<td><code>win 65535</code></td>
<td>接收窗口</td>
<td>流控制</td>
</tr>
<tr>
<td><strong>选项</strong></td>
<td><code>options [mss 1460]</code></td>
<td>TCP 选项</td>
<td>协商参数</td>
</tr>
<tr>
<td><strong>数据长度</strong></td>
<td><code>length 0</code></td>
<td>TCP 数据长度</td>
<td>实际载荷大小</td>
</tr>
</tbody></table>
<hr>
<h2 id="关键字段分析"><a href="#关键字段分析" class="headerlink" title="关键字段分析"></a>关键字段分析</h2><h3 id="🚨-需要重点关注的异常"><a href="#🚨-需要重点关注的异常" class="headerlink" title="🚨 需要重点关注的异常"></a>🚨 需要重点关注的异常</h3><h4 id="1-校验和错误"><a href="#1-校验和错误" class="headerlink" title="1. 校验和错误"></a>1. 校验和错误</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表示数据包在传输过程中被损坏</span></span><br><span class="line">bad <span class="built_in">cksum</span> 0 (-&gt;3c4a)!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可能原因：</span></span><br><span class="line"><span class="comment"># - 网络硬件故障</span></span><br><span class="line"><span class="comment"># - 网卡驱动问题  </span></span><br><span class="line"><span class="comment"># - 传输过程中的干扰</span></span><br></pre></td></tr></table></figure>

<h4 id="2-TTL-异常"><a href="#2-TTL-异常" class="headerlink" title="2. TTL 异常"></a>2. TTL 异常</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TTL 过小，可能经过太多路由器</span></span><br><span class="line">ttl 1    <span class="comment"># 即将被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TTL 异常大，可能是伪造包</span></span><br><span class="line">ttl 255  <span class="comment"># 可疑的最大值</span></span><br></pre></td></tr></table></figure>

<h4 id="3-序列号异常"><a href="#3-序列号异常" class="headerlink" title="3. 序列号异常"></a>3. 序列号异常</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 序列号不连续，可能有丢包</span></span><br><span class="line"><span class="built_in">seq</span> 1000:1500, ack 2000</span><br><span class="line"><span class="built_in">seq</span> 2000:2500, ack 2000  <span class="comment"># 跳过了 1500-2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复的序列号，表示重传</span></span><br><span class="line"><span class="built_in">seq</span> 1000:1500, ack 2000</span><br><span class="line"><span class="built_in">seq</span> 1000:1500, ack 2000  <span class="comment"># 重传</span></span><br></pre></td></tr></table></figure>

<h4 id="4-窗口大小异常"><a href="#4-窗口大小异常" class="headerlink" title="4. 窗口大小异常"></a>4. 窗口大小异常</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">win 0     <span class="comment"># 接收方缓冲区满，发送方应该停止发送</span></span><br><span class="line">win 65535 <span class="comment"># 最大窗口，正常</span></span><br><span class="line">win 1     <span class="comment"># 窗口很小，可能有流控问题</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="典型场景分析"><a href="#典型场景分析" class="headerlink" title="典型场景分析"></a>典型场景分析</h2><h3 id="场景1：正常-HTTP-连接建立"><a href="#场景1：正常-HTTP-连接建立" class="headerlink" title="场景1：正常 HTTP 连接建立"></a>场景1：正常 HTTP 连接建立</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 客户端发起连接</span></span><br><span class="line">13:21:34.100000 IP client.54321 &gt; server.80: Flags [S], <span class="built_in">seq</span> 1000, win 65535, options [mss 1460], length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 服务器响应连接</span></span><br><span class="line">13:21:34.100500 IP server.80 &gt; client.54321: Flags [S.], <span class="built_in">seq</span> 2000, ack 1001, win 65535, options [mss 1460], length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 客户端确认连接</span></span><br><span class="line">13:21:34.100600 IP client.54321 &gt; server.80: Flags [.], ack 2001, win 65535, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 客户端发送 HTTP 请求</span></span><br><span class="line">13:21:34.100700 IP client.54321 &gt; server.80: Flags [P.], <span class="built_in">seq</span> 1001:1200, ack 2001, win 65535, length 199</span><br></pre></td></tr></table></figure>

<p><strong>分析要点：</strong></p>
<ul>
<li>✅ 三次握手完整 (SYN → SYN+ACK → ACK)</li>
<li>✅ 序列号正确递增 (1000 → 1001, 2000 → 2001)</li>
<li>✅ 响应时间正常 (0.5ms)</li>
</ul>
<h3 id="场景2：连接被拒绝"><a href="#场景2：连接被拒绝" class="headerlink" title="场景2：连接被拒绝"></a>场景2：连接被拒绝</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 客户端发起连接</span></span><br><span class="line">13:21:34.100000 IP client.54321 &gt; server.8080: Flags [S], <span class="built_in">seq</span> 1000, win 65535, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 服务器立即拒绝 (端口未监听)</span></span><br><span class="line">13:21:34.100100 IP server.8080 &gt; client.54321: Flags [R.], <span class="built_in">seq</span> 0, ack 1001, win 0, length 0</span><br></pre></td></tr></table></figure>

<p><strong>分析要点：</strong></p>
<ul>
<li>❌ 收到 RST 标志，连接被拒绝</li>
<li>🔍 可能原因：端口未监听、防火墙阻止、服务未启动</li>
</ul>
<h3 id="场景3：连接超时重传"><a href="#场景3：连接超时重传" class="headerlink" title="场景3：连接超时重传"></a>场景3：连接超时重传</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 客户端发起连接</span></span><br><span class="line">13:21:34.100000 IP client.54321 &gt; server.80: Flags [S], <span class="built_in">seq</span> 1000, win 65535, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 无响应，客户端重传 (通常 1 秒后)</span></span><br><span class="line">13:21:35.100000 IP client.54321 &gt; server.80: Flags [S], <span class="built_in">seq</span> 1000, win 65535, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 继续重传 (通常 2 秒后)</span></span><br><span class="line">13:21:37.100000 IP client.54321 &gt; server.80: Flags [S], <span class="built_in">seq</span> 1000, win 65535, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 最终放弃或收到 RST</span></span><br><span class="line">13:21:41.100000 IP client.54321 &gt; server.80: Flags [R], <span class="built_in">seq</span> 1001, win 0, length 0</span><br></pre></td></tr></table></figure>

<p><strong>分析要点：</strong></p>
<ul>
<li>⚠️ 重复的 SYN 包表示重传</li>
<li>🔍 可能原因：网络延迟、服务器负载高、丢包</li>
</ul>
<h3 id="场景4：数据传输中的重传"><a href="#场景4：数据传输中的重传" class="headerlink" title="场景4：数据传输中的重传"></a>场景4：数据传输中的重传</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 正常数据传输</span></span><br><span class="line">13:21:34.100000 IP client.54321 &gt; server.80: Flags [.], <span class="built_in">seq</span> 1001:2001, ack 2001, win 65535, length 1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 服务器确认</span></span><br><span class="line">13:21:34.100500 IP server.80 &gt; client.54321: Flags [.], ack 2001, win 65535, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 下一个数据包</span></span><br><span class="line">13:21:34.101000 IP client.54321 &gt; server.80: Flags [.], <span class="built_in">seq</span> 2001:3001, ack 2001, win 65535, length 1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 服务器没有确认，客户端重传</span></span><br><span class="line">13:21:34.200000 IP client.54321 &gt; server.80: Flags [.], <span class="built_in">seq</span> 2001:3001, ack 2001, win 65535, length 1000</span><br></pre></td></tr></table></figure>

<p><strong>分析要点：</strong></p>
<ul>
<li>⚠️ 相同序列号的重复包表示重传</li>
<li>🔍 可能原因：ACK 丢失、网络拥塞、接收方处理慢</li>
</ul>
<h3 id="场景5：异常连接终止"><a href="#场景5：异常连接终止" class="headerlink" title="场景5：异常连接终止"></a>场景5：异常连接终止</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 正常连接中</span></span><br><span class="line">13:21:34.100000 IP client.54321 &gt; server.80: Flags [P.], <span class="built_in">seq</span> 1001:1200, ack 2001, win 65535, length 199</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 服务器突然发送 RST (应用异常)</span></span><br><span class="line">13:21:34.100500 IP server.80 &gt; client.54321: Flags [R], <span class="built_in">seq</span> 2001, win 0, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 客户端可能还会尝试发送数据</span></span><br><span class="line">13:21:34.101000 IP client.54321 &gt; server.80: Flags [P.], <span class="built_in">seq</span> 1200:1400, ack 2001, win 65535, length 200</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 服务器继续发送 RST</span></span><br><span class="line">13:21:34.101100 IP server.80 &gt; client.54321: Flags [R], <span class="built_in">seq</span> 2001, win 0, length 0</span><br></pre></td></tr></table></figure>

<p><strong>分析要点：</strong></p>
<ul>
<li>💥 服务器主动 RST，应用层问题</li>
<li>🔍 可能原因：程序崩溃、资源耗尽、业务逻辑错误</li>
</ul>
<hr>
<h2 id="4层-7层负载均衡分析"><a href="#4层-7层负载均衡分析" class="headerlink" title="4层&#x2F;7层负载均衡分析"></a>4层&#x2F;7层负载均衡分析</h2><h3 id="🏗️-4层负载均衡（传输层）"><a href="#🏗️-4层负载均衡（传输层）" class="headerlink" title="🏗️ 4层负载均衡（传输层）"></a>🏗️ 4层负载均衡（传输层）</h3><h4 id="特征分析"><a href="#特征分析" class="headerlink" title="特征分析"></a>特征分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 客户端连接到负载均衡器</span></span><br><span class="line">13:21:34.100000 IP client.12345 &gt; lb.80: Flags [S], <span class="built_in">seq</span> 1000, win 65535, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 负载均衡器转发到后端服务器 (源IP可能变化)</span></span><br><span class="line">13:21:34.100100 IP lb.54321 &gt; backend1.80: Flags [S], <span class="built_in">seq</span> 2000, win 65535, length 0</span><br><span class="line"><span class="comment"># 或者保持源IP (DSR模式)</span></span><br><span class="line">13:21:34.100100 IP client.12345 &gt; backend1.80: Flags [S], <span class="built_in">seq</span> 1000, win 65535, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后端服务器响应</span></span><br><span class="line">13:21:34.100200 IP backend1.80 &gt; client.12345: Flags [S.], <span class="built_in">seq</span> 3000, ack 1001, win 65535, length 0</span><br></pre></td></tr></table></figure>

<h4 id="关键观察点"><a href="#关键观察点" class="headerlink" title="关键观察点"></a>关键观察点</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 连接分布 - 检查负载均衡效果</span></span><br><span class="line">tcpdump -nn <span class="string">&quot;port 80&quot;</span> | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 健康检查流量 - 通常是短连接</span></span><br><span class="line">13:21:34.100000 IP lb.12345 &gt; backend1.80: Flags [S], <span class="built_in">seq</span> 1000, win 65535, length 0</span><br><span class="line">13:21:34.100100 IP backend1.80 &gt; lb.12345: Flags [S.], <span class="built_in">seq</span> 2000, ack 1001, win 65535, length 0</span><br><span class="line">13:21:34.100200 IP lb.12345 &gt; backend1.80: Flags [.], ack 2001, win 65535, length 0</span><br><span class="line">13:21:34.100300 IP lb.12345 &gt; backend1.80: Flags [F.], <span class="built_in">seq</span> 1001, ack 2001, win 65535, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 会话保持 - 同一客户端IP总是连接同一后端</span></span><br><span class="line">client.12345 -&gt; backend1.80  <span class="comment"># 第一次连接</span></span><br><span class="line">client.12345 -&gt; backend1.80  <span class="comment"># 后续连接保持一致</span></span><br></pre></td></tr></table></figure>

<h3 id="🌐-7层负载均衡（应用层）"><a href="#🌐-7层负载均衡（应用层）" class="headerlink" title="🌐 7层负载均衡（应用层）"></a>🌐 7层负载均衡（应用层）</h3><h4 id="特征分析-1"><a href="#特征分析-1" class="headerlink" title="特征分析"></a>特征分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 客户端连接到负载均衡器</span></span><br><span class="line">13:21:34.100000 IP client.12345 &gt; lb.80: Flags [S], <span class="built_in">seq</span> 1000, win 65535, length 0</span><br><span class="line">13:21:34.100100 IP lb.80 &gt; client.12345: Flags [S.], <span class="built_in">seq</span> 2000, ack 1001, win 65535, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端发送 HTTP 请求到负载均衡器</span></span><br><span class="line">13:21:34.100200 IP client.12345 &gt; lb.80: Flags [P.], <span class="built_in">seq</span> 1001:1200, ack 2001, win 65535, length 199</span><br><span class="line"><span class="comment"># HTTP 内容: GET /api/users HTTP/1.1\r\nHost: example.com\r\n...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 负载均衡器新建连接到后端 (基于 HTTP 内容决策)</span></span><br><span class="line">13:21:34.100300 IP lb.54321 &gt; backend2.8080: Flags [S], <span class="built_in">seq</span> 3000, win 65535, length 0</span><br><span class="line">13:21:34.100400 IP backend2.8080 &gt; lb.54321: Flags [S.], <span class="built_in">seq</span> 4000, ack 3001, win 65535, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 负载均衡器转发修改后的 HTTP 请求</span></span><br><span class="line">13:21:34.100500 IP lb.54321 &gt; backend2.8080: Flags [P.], <span class="built_in">seq</span> 3001:3250, ack 4001, win 65535, length 249</span><br><span class="line"><span class="comment"># HTTP 内容可能被修改: GET /api/users HTTP/1.1\r\nHost: backend2.internal\r\nX-Forwarded-For: client_ip\r\n...</span></span><br></pre></td></tr></table></figure>

<h4 id="HTTP-请求路由分析"><a href="#HTTP-请求路由分析" class="headerlink" title="HTTP 请求路由分析"></a>HTTP 请求路由分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据 URL 路径路由</span></span><br><span class="line">GET /api/v1/users    -&gt; backend-api.8080</span><br><span class="line">GET /static/css/     -&gt; backend-static.80</span><br><span class="line">GET /admin/          -&gt; backend-admin.8081</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 Host 头路由  </span></span><br><span class="line">Host: api.example.com    -&gt; backend-api.8080</span><br><span class="line">Host: www.example.com    -&gt; backend-web.80</span><br><span class="line">Host: admin.example.com  -&gt; backend-admin.8081</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据请求头路由</span></span><br><span class="line">User-Agent: Mobile*      -&gt; backend-mobile.8080</span><br><span class="line">User-Agent: Desktop*     -&gt; backend-web.80</span><br></pre></td></tr></table></figure>

<h3 id="🔍-负载均衡问题诊断"><a href="#🔍-负载均衡问题诊断" class="headerlink" title="🔍 负载均衡问题诊断"></a>🔍 负载均衡问题诊断</h3><h4 id="常见问题模式"><a href="#常见问题模式" class="headerlink" title="常见问题模式"></a>常见问题模式</h4><ol>
<li><p><strong>后端服务器故障</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 负载均衡器检测到后端故障</span></span><br><span class="line">13:21:34.100000 IP lb.12345 &gt; backend1.8080: Flags [S], <span class="built_in">seq</span> 1000, win 65535, length 0</span><br><span class="line">13:21:34.100100 IP backend1.8080 &gt; lb.12345: Flags [R.], <span class="built_in">seq</span> 0, ack 1001, win 0, length 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 负载均衡器切换到健康的后端</span></span><br><span class="line">13:21:34.100200 IP lb.12346 &gt; backend2.8080: Flags [S], <span class="built_in">seq</span> 2000, win 65535, length 0</span><br><span class="line">13:21:34.100300 IP backend2.8080 &gt; lb.12346: Flags [S.], <span class="built_in">seq</span> 3000, ack 2001, win 65535, length 0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>会话保持失效</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户第一次请求到 backend1</span></span><br><span class="line">client.12345 -&gt; lb.80 -&gt; backend1.8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户第二次请求错误地到了 backend2 (会话丢失)</span></span><br><span class="line">client.12345 -&gt; lb.80 -&gt; backend2.8080</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>健康检查过于频繁</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每秒多次健康检查，影响后端性能</span></span><br><span class="line">13:21:34.100 IP lb &gt; backend1.80: GET /health</span><br><span class="line">13:21:34.200 IP lb &gt; backend1.80: GET /health  </span><br><span class="line">13:21:34.300 IP lb &gt; backend1.80: GET /health</span><br><span class="line"><span class="comment"># ... 频率过高</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="服务端开发必知网络知识"><a href="#服务端开发必知网络知识" class="headerlink" title="服务端开发必知网络知识"></a>服务端开发必知网络知识</h2><h3 id="🚀-TCP-连接池优化"><a href="#🚀-TCP-连接池优化" class="headerlink" title="🚀 TCP 连接池优化"></a>🚀 TCP 连接池优化</h3><h4 id="连接复用分析"><a href="#连接复用分析" class="headerlink" title="连接复用分析"></a>连接复用分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 良好的连接复用模式</span></span><br><span class="line">13:21:34.100 IP app.12345 &gt; db.5432: Flags [S]      <span class="comment"># 建立连接</span></span><br><span class="line">13:21:34.101 IP db.5432 &gt; app.12345: Flags [S.]     <span class="comment"># 连接确认</span></span><br><span class="line">13:21:34.102 IP app.12345 &gt; db.5432: Flags [P.]     <span class="comment"># 查询1</span></span><br><span class="line">13:21:34.110 IP db.5432 &gt; app.12345: Flags [P.]     <span class="comment"># 响应1</span></span><br><span class="line">13:21:34.200 IP app.12345 &gt; db.5432: Flags [P.]     <span class="comment"># 查询2 (复用连接)</span></span><br><span class="line">13:21:34.210 IP db.5432 &gt; app.12345: Flags [P.]     <span class="comment"># 响应2</span></span><br><span class="line">13:21:34.300 IP app.12345 &gt; db.5432: Flags [P.]     <span class="comment"># 查询3 (复用连接)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不良的连接模式 (每次请求都建立新连接)</span></span><br><span class="line">13:21:34.100 IP app.12345 &gt; db.5432: Flags [S]      <span class="comment"># 建立连接1</span></span><br><span class="line">13:21:34.102 IP app.12345 &gt; db.5432: Flags [P.]     <span class="comment"># 查询1</span></span><br><span class="line">13:21:34.110 IP app.12345 &gt; db.5432: Flags [F.]     <span class="comment"># 关闭连接1</span></span><br><span class="line">13:21:34.200 IP app.12346 &gt; db.5432: Flags [S]      <span class="comment"># 建立连接2</span></span><br><span class="line">13:21:34.202 IP app.12346 &gt; db.5432: Flags [P.]     <span class="comment"># 查询2</span></span><br><span class="line">13:21:34.210 IP app.12346 &gt; db.5432: Flags [F.]     <span class="comment"># 关闭连接2</span></span><br></pre></td></tr></table></figure>

<h4 id="连接池监控指标"><a href="#连接池监控指标" class="headerlink" title="连接池监控指标"></a>连接池监控指标</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 连接建立频率</span></span><br><span class="line">tcpdump -nn <span class="string">&quot;tcp[tcpflags] &amp; tcp-syn != 0&quot;</span> | \</span><br><span class="line">    grep <span class="string">&quot;app_server&quot;</span> | <span class="built_in">wc</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 连接复用率  </span></span><br><span class="line">总请求数 / 新建连接数 = 复用率</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 连接超时情况</span></span><br><span class="line">tcpdump -nn <span class="string">&quot;tcp[tcpflags] &amp; tcp-rst != 0&quot;</span> | \</span><br><span class="line">    grep <span class="string">&quot;connection.*timeout&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="🔐-HTTPS-TLS-优化分析"><a href="#🔐-HTTPS-TLS-优化分析" class="headerlink" title="🔐 HTTPS&#x2F;TLS 优化分析"></a>🔐 HTTPS&#x2F;TLS 优化分析</h3><h4 id="TLS-握手性能分析"><a href="#TLS-握手性能分析" class="headerlink" title="TLS 握手性能分析"></a>TLS 握手性能分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 完整的 TLS 1.2 握手过程</span></span><br><span class="line">13:21:34.100 IP client &gt; server.443: Flags [S]           <span class="comment"># TCP SYN</span></span><br><span class="line">13:21:34.101 IP server.443 &gt; client: Flags [S.]          <span class="comment"># TCP SYN-ACK  </span></span><br><span class="line">13:21:34.102 IP client &gt; server.443: Flags [.]           <span class="comment"># TCP ACK</span></span><br><span class="line"></span><br><span class="line">13:21:34.103 IP client &gt; server.443: Flags [P.]          <span class="comment"># Client Hello</span></span><br><span class="line">13:21:34.105 IP server.443 &gt; client: Flags [P.]          <span class="comment"># Server Hello, Certificate, Server Hello Done</span></span><br><span class="line">13:21:34.108 IP client &gt; server.443: Flags [P.]          <span class="comment"># Client Key Exchange, Change Cipher Spec, Finished</span></span><br><span class="line">13:21:34.110 IP server.443 &gt; client: Flags [P.]          <span class="comment"># Change Cipher Spec, Finished</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TLS 握手总耗时 = 110 - 100 = 10ms (4个往返)</span></span><br></pre></td></tr></table></figure>

<h4 id="TLS-会话复用"><a href="#TLS-会话复用" class="headerlink" title="TLS 会话复用"></a>TLS 会话复用</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 会话复用模式 (Session ID 或 Session Ticket)</span></span><br><span class="line">13:21:34.100 IP client &gt; server.443: Flags [P.]          <span class="comment"># Client Hello (带 Session ID)</span></span><br><span class="line">13:21:34.102 IP server.443 &gt; client: Flags [P.]          <span class="comment"># Server Hello (确认复用)</span></span><br><span class="line">13:21:34.103 IP client &gt; server.443: Flags [P.]          <span class="comment"># Change Cipher Spec, Finished</span></span><br><span class="line">13:21:34.104 IP server.443 &gt; client: Flags [P.]          <span class="comment"># Change Cipher Spec, Finished</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复用握手总耗时 = 4ms (2个往返，节省50%时间)</span></span><br></pre></td></tr></table></figure>

<h3 id="🎯-微服务间通信优化"><a href="#🎯-微服务间通信优化" class="headerlink" title="🎯 微服务间通信优化"></a>🎯 微服务间通信优化</h3><h4 id="服务发现模式分析"><a href="#服务发现模式分析" class="headerlink" title="服务发现模式分析"></a>服务发现模式分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DNS 服务发现</span></span><br><span class="line">13:21:34.100 IP app &gt; dns.53: A? user-service.internal   <span class="comment"># DNS 查询</span></span><br><span class="line">13:21:34.101 IP dns.53 &gt; app: A 10.0.1.100              <span class="comment"># DNS 响应</span></span><br><span class="line">13:21:34.102 IP app &gt; 10.0.1.100.8080: Flags [S]        <span class="comment"># 连接服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务注册中心模式 (如 Consul)</span></span><br><span class="line">13:21:34.100 IP app &gt; consul.8500: GET /v1/health/service/user-service</span><br><span class="line">13:21:34.102 IP consul.8500 &gt; app: 200 OK [&#123;<span class="string">&quot;Address&quot;</span>:<span class="string">&quot;10.0.1.100&quot;</span>,<span class="string">&quot;Port&quot;</span>:8080&#125;]</span><br><span class="line">13:21:34.103 IP app &gt; 10.0.1.100.8080: Flags [S]</span><br></pre></td></tr></table></figure>

<h4 id="熔断器模式识别"><a href="#熔断器模式识别" class="headerlink" title="熔断器模式识别"></a>熔断器模式识别</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常请求模式</span></span><br><span class="line">13:21:34.100 IP app &gt; user-service.8080: POST /api/users</span><br><span class="line">13:21:34.110 IP user-service.8080 &gt; app: 200 OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务开始出现延迟</span></span><br><span class="line">13:21:35.100 IP app &gt; user-service.8080: POST /api/users</span><br><span class="line">13:21:35.500 IP user-service.8080 &gt; app: 200 OK          <span class="comment"># 400ms 延迟</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 熔断器打开，请求被快速拒绝 (本地响应，无网络请求)</span></span><br><span class="line">13:21:36.100 <span class="comment"># 无网络流量，应用直接返回降级响应</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 熔断器半开，尝试恢复</span></span><br><span class="line">13:21:37.100 IP app &gt; user-service.8080: POST /api/users <span class="comment"># 探测请求</span></span><br><span class="line">13:21:37.120 IP user-service.8080 &gt; app: 200 OK          <span class="comment"># 快速响应，熔断器关闭</span></span><br></pre></td></tr></table></figure>

<h3 id="📊-性能指标监控"><a href="#📊-性能指标监控" class="headerlink" title="📊 性能指标监控"></a>📊 性能指标监控</h3><h4 id="关键网络指标"><a href="#关键网络指标" class="headerlink" title="关键网络指标"></a>关键网络指标</h4><ol>
<li><p><strong>连接建立时间</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算 SYN 到 SYN+ACK 的时间差</span></span><br><span class="line">tcpdump -ttt -nn <span class="string">&quot;tcp[tcpflags] &amp; (tcp-syn|tcp-ack) != 0&quot;</span> | \</span><br><span class="line">    awk <span class="string">&#x27;/SYN/ &#123;syn_time=$1&#125; /SYN.*ACK/ &#123;print &quot;Connection time:&quot;, $1-syn_time, &quot;ms&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>请求响应时间</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算 HTTP 请求到响应的时间差  </span></span><br><span class="line">tcpdump -ttt -nn -A <span class="string">&quot;port 80&quot;</span> | \</span><br><span class="line">    awk <span class="string">&#x27;/GET|POST/ &#123;req_time=$1&#125; /HTTP.*200/ &#123;print &quot;Response time:&quot;, $1-req_time, &quot;ms&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重传率计算</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计重传包数量</span></span><br><span class="line">total_packets=$(tcpdump -r capture.pcap -nn | <span class="built_in">wc</span> -l)</span><br><span class="line">retrans_packets=$(tcpdump -r capture.pcap -nn | grep <span class="string">&quot;retransmission&quot;</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">retrans_rate=$(<span class="built_in">echo</span> <span class="string">&quot;scale=2; <span class="variable">$retrans_packets</span> * 100 / <span class="variable">$total_packets</span>&quot;</span> | bc)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;重传率: <span class="variable">$retrans_rate</span>%&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="🛠️-问题定位工具组合"><a href="#🛠️-问题定位工具组合" class="headerlink" title="🛠️ 问题定位工具组合"></a>🛠️ 问题定位工具组合</h3><h4 id="应用层面问题定位"><a href="#应用层面问题定位" class="headerlink" title="应用层面问题定位"></a>应用层面问题定位</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 应用日志 + 网络抓包对比</span></span><br><span class="line"><span class="built_in">tail</span> -f app.log &amp;</span><br><span class="line">tcpdump -i any -nn -A <span class="string">&quot;port 8080&quot;</span> -w app_network.pcap &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 数据库连接池分析</span></span><br><span class="line">tcpdump -i any -nn <span class="string">&quot;port 5432&quot;</span> | \</span><br><span class="line">    awk <span class="string">&#x27;&#123;print $1, $3, $5&#125;&#x27;</span> | \</span><br><span class="line">    <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 缓存命中率网络视角</span></span><br><span class="line">tcpdump -i any -nn <span class="string">&quot;port 6379&quot;</span> | \</span><br><span class="line">    grep -E <span class="string">&quot;(GET|SET|HGET)&quot;</span> | \</span><br><span class="line">    awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br></pre></td></tr></table></figure>

<h4 id="容器环境问题定位"><a href="#容器环境问题定位" class="headerlink" title="容器环境问题定位"></a>容器环境问题定位</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Kubernetes 环境网络分析</span></span><br><span class="line"><span class="comment"># 1. Pod 间通信</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it pod1 -- tcpdump -i eth0 -nn <span class="string">&quot;host pod2_ip&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Service 负载均衡</span></span><br><span class="line">tcpdump -i any -nn <span class="string">&quot;port 80&quot;</span> | grep -E <span class="string">&quot;<span class="subst">$(kubectl get endpoints service-name -o jsonpath=&#x27;&#123;.subsets[*].addresses[*].ip&#125;&#x27;)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Ingress 流量分析  </span></span><br><span class="line">tcpdump -i any -nn <span class="string">&quot;port 443&quot;</span> | grep -E <span class="string">&quot;SNI.*domain\.com&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🎓-进阶技巧与最佳实践"><a href="#🎓-进阶技巧与最佳实践" class="headerlink" title="🎓 进阶技巧与最佳实践"></a>🎓 进阶技巧与最佳实践</h2><h3 id="🔬-高级过滤技巧"><a href="#🔬-高级过滤技巧" class="headerlink" title="🔬 高级过滤技巧"></a>🔬 高级过滤技巧</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 只抓握手包，分析连接建立问题</span></span><br><span class="line">tcpdump -nn <span class="string">&quot;tcp[tcpflags] &amp; (tcp-syn|tcp-fin|tcp-rst) != 0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 抓取有数据载荷的包</span></span><br><span class="line">tcpdump -nn <span class="string">&quot;tcp and greater 0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 抓取异常包 (重传、乱序、重复ACK)</span></span><br><span class="line">tcpdump -nn <span class="string">&quot;tcp and ((tcp[tcpflags] &amp; tcp-rst) != 0 or tcp[tcpflags] &amp; tcp-syn != 0)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 分析特定应用协议</span></span><br><span class="line">tcpdump -nn -A <span class="string">&quot;port 3306&quot;</span> | grep -E <span class="string">&quot;(SELECT|INSERT|UPDATE|DELETE)&quot;</span></span><br><span class="line">tcpdump -nn -A <span class="string">&quot;port 6379&quot;</span> | grep -E <span class="string">&quot;(GET|SET|HGET|HSET)&quot;</span></span><br><span class="line">tcpdump -nn -A <span class="string">&quot;port 80&quot;</span> | grep -E <span class="string">&quot;(GET|POST|PUT|DELETE) .* HTTP&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 抓取大包 (可能的分片或性能问题)</span></span><br><span class="line">tcpdump -nn <span class="string">&quot;greater 1500&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 抓取小包 (可能的Nagle算法问题)</span></span><br><span class="line">tcpdump -nn <span class="string">&quot;less 100 and tcp&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="📈-性能调优实战"><a href="#📈-性能调优实战" class="headerlink" title="📈 性能调优实战"></a>📈 性能调优实战</h3><h4 id="网络拥塞分析"><a href="#网络拥塞分析" class="headerlink" title="网络拥塞分析"></a>网络拥塞分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 检测零窗口 (接收方处理不过来)</span></span><br><span class="line">tcpdump -nn <span class="string">&quot;tcp and tcp[14:2] = 0&quot;</span> | <span class="built_in">head</span> -20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例输出分析:</span></span><br><span class="line">13:21:34.100 IP client.12345 &gt; server.80: Flags [.], ack 1000, win 0, length 0</span><br><span class="line"><span class="comment"># win 0 表示客户端缓冲区满，要求服务端停止发送</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 检测窗口扩大 (拥塞恢复)</span></span><br><span class="line">tcpdump -nn <span class="string">&quot;tcp&quot;</span> | awk <span class="string">&#x27;/win/ &#123;print $1, $NF&#125;&#x27;</span> | \</span><br><span class="line">    grep -E <span class="string">&quot;win [0-9]+&quot;</span> | <span class="built_in">sort</span> -k2 -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 分析重传模式</span></span><br><span class="line">tcpdump -nn -r capture.pcap | \</span><br><span class="line">    awk <span class="string">&#x27;/retransmission/ &#123;retrans++&#125; END &#123;print &quot;重传包数:&quot;, retrans&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="TCP-调优参数验证"><a href="#TCP-调优参数验证" class="headerlink" title="TCP 调优参数验证"></a>TCP 调优参数验证</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. MSS (最大段大小) 协商分析</span></span><br><span class="line">tcpdump -nn <span class="string">&quot;tcp[tcpflags] &amp; tcp-syn != 0&quot;</span> | grep <span class="string">&quot;mss&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例:</span></span><br><span class="line">13:21:34.100 IP client &gt; server.80: Flags [S], options [mss 1460], length 0</span><br><span class="line">13:21:34.101 IP server.80 &gt; client: Flags [S.], options [mss 1460], length 0</span><br><span class="line"><span class="comment"># 双方协商 MSS = 1460，这是以太网标准值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 窗口扩大因子分析</span></span><br><span class="line">tcpdump -nn <span class="string">&quot;tcp[tcpflags] &amp; tcp-syn != 0&quot;</span> | grep <span class="string">&quot;wscale&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例:</span></span><br><span class="line">options [mss 1460,sackOK,TS val 123456 ecr 0,nop,wscale 7]</span><br><span class="line"><span class="comment"># wscale 7 表示窗口可以扩大 2^7 = 128 倍</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. SACK (选择性确认) 支持检测</span></span><br><span class="line">tcpdump -nn | grep <span class="string">&quot;sackOK&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="🚨-故障排查进阶"><a href="#🚨-故障排查进阶" class="headerlink" title="🚨 故障排查进阶"></a>🚨 故障排查进阶</h3><h4 id="复杂网络环境调试"><a href="#复杂网络环境调试" class="headerlink" title="复杂网络环境调试"></a>复杂网络环境调试</h4><p><strong>1. 多网卡环境分析</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查流量在哪个网卡</span></span><br><span class="line"><span class="keyword">for</span> iface <span class="keyword">in</span> $(ip <span class="built_in">link</span> show | grep -o <span class="string">&#x27;^[0-9]*: [^:]*&#x27;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27; &#x27;</span> -f2); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;=== <span class="variable">$iface</span> ===&quot;</span></span><br><span class="line">    <span class="built_in">timeout</span> 5 tcpdump -i <span class="variable">$iface</span> -c 10 -nn 2&gt;/dev/null | <span class="built_in">head</span> -5</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析路由决策</span></span><br><span class="line">ip route get 192.168.1.100</span><br><span class="line"><span class="comment"># via 192.168.1.1 dev eth0 src 192.168.1.50</span></span><br></pre></td></tr></table></figure>

<p><strong>2. Docker&#x2F;Kubernetes 网络调试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 容器网络栈分析</span></span><br><span class="line">docker <span class="built_in">exec</span> container_name ip netns <span class="built_in">exec</span> netns_id tcpdump -i eth0 -nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># Kubernetes Pod 网络</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it pod-name -c container-name -- tcpdump -i eth0 -nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析 CNI 网络</span></span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i cni0 -nn <span class="string">&quot;host pod_ip&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Service 网络分析 (iptables 规则影响)</span></span><br><span class="line"><span class="built_in">sudo</span> iptables -t nat -L -n -v | grep service_name</span><br><span class="line"><span class="built_in">sudo</span> tcpdump -i any -nn <span class="string">&quot;port service_port&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 负载均衡器后端健康检查</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 识别健康检查模式</span></span><br><span class="line">tcpdump -nn <span class="string">&quot;port 80&quot;</span> | grep -E <span class="string">&quot;(GET /health|GET /status|GET /ping)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析健康检查频率</span></span><br><span class="line">tcpdump -nn -c 100 <span class="string">&quot;port 80 and host lb_ip&quot;</span> | \</span><br><span class="line">    grep <span class="string">&quot;health&quot;</span> | \</span><br><span class="line">    awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> | <span class="built_in">uniq</span> -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查健康检查响应时间</span></span><br><span class="line">tcpdump -ttt -nn <span class="string">&quot;port 80&quot;</span> | \</span><br><span class="line">    awk <span class="string">&#x27;/GET.*health/ &#123;start=$1&#125; /200 OK/ &#123;print &quot;Health check time:&quot;, $1-start, &quot;ms&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="🎯-微服务架构网络分析"><a href="#🎯-微服务架构网络分析" class="headerlink" title="🎯 微服务架构网络分析"></a>🎯 微服务架构网络分析</h3><h4 id="服务网格-Service-Mesh-流量分析"><a href="#服务网格-Service-Mesh-流量分析" class="headerlink" title="服务网格 (Service Mesh) 流量分析"></a>服务网格 (Service Mesh) 流量分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Istio/Envoy 代理流量分析</span></span><br><span class="line"><span class="comment"># 1. 边车代理入站流量</span></span><br><span class="line">tcpdump -i any -nn <span class="string">&quot;port 15001&quot;</span> | <span class="built_in">head</span> -10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 边车代理出站流量  </span></span><br><span class="line">tcpdump -i any -nn <span class="string">&quot;port 15000&quot;</span> | <span class="built_in">head</span> -10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 控制平面通信</span></span><br><span class="line">tcpdump -i any -nn <span class="string">&quot;port 15010&quot;</span> | grep -E <span class="string">&quot;(pilot|mixer|citadel)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 分析 mTLS 流量特征</span></span><br><span class="line">tcpdump -i any -nn -X <span class="string">&quot;port 15001&quot;</span> | grep -A5 -B5 <span class="string">&quot;TLS&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="API-网关流量模式"><a href="#API-网关流量模式" class="headerlink" title="API 网关流量模式"></a>API 网关流量模式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 速率限制检测</span></span><br><span class="line">tcpdump -nn -A <span class="string">&quot;port 80&quot;</span> | grep -E <span class="string">&quot;429|Rate.*Limit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 认证流量分析</span></span><br><span class="line">tcpdump -nn -A <span class="string">&quot;port 80&quot;</span> | grep -E <span class="string">&quot;Authorization:|401|403&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. API 版本路由分析</span></span><br><span class="line">tcpdump -nn -A <span class="string">&quot;port 80&quot;</span> | grep -E <span class="string">&quot;GET /v[0-9]+/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例分析：</span></span><br><span class="line">GET /v1/users HTTP/1.1     -&gt; backend-v1.8080</span><br><span class="line">GET /v2/users HTTP/1.1     -&gt; backend-v2.8080</span><br><span class="line">GET /v3/users HTTP/1.1     -&gt; backend-v3.8080</span><br></pre></td></tr></table></figure>

<h3 id="📊-监控与告警"><a href="#📊-监控与告警" class="headerlink" title="📊 监控与告警"></a>📊 监控与告警</h3><h4 id="自动化网络问题检测脚本"><a href="#自动化网络问题检测脚本" class="headerlink" title="自动化网络问题检测脚本"></a>自动化网络问题检测脚本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># network_monitor.sh - 实时网络问题检测</span></span><br><span class="line"></span><br><span class="line">LOG_FILE=<span class="string">&quot;/var/log/network_monitor.log&quot;</span></span><br><span class="line">ALERT_THRESHOLD=10  <span class="comment"># RST包阈值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 监控异常连接重置</span></span><br><span class="line"><span class="function"><span class="title">monitor_rst</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> rst_count=$(<span class="built_in">timeout</span> 60 tcpdump -i any -nn -c 1000 2&gt;/dev/null | \</span><br><span class="line">                     grep -c <span class="string">&quot;Flags \[R\]&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$rst_count</span> -gt <span class="variable">$ALERT_THRESHOLD</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;[<span class="subst">$(date)</span>] ALERT: High RST count: <span class="variable">$rst_count</span>&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line">        <span class="comment"># 发送告警通知</span></span><br><span class="line">        curl -X POST <span class="string">&quot;http://alert-manager/api/v1/alerts&quot;</span> \</span><br><span class="line">             -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">             -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">                 &quot;labels&quot;: &#123;</span></span><br><span class="line"><span class="string">                     &quot;alertname&quot;: &quot;HighRSTCount&quot;,</span></span><br><span class="line"><span class="string">                     &quot;severity&quot;: &quot;warning&quot;,</span></span><br><span class="line"><span class="string">                     &quot;instance&quot;: &quot;&#x27;</span>$(hostname)<span class="string">&#x27;&quot;</span></span><br><span class="line"><span class="string">                 &#125;,</span></span><br><span class="line"><span class="string">                 &quot;annotations&quot;: &#123;</span></span><br><span class="line"><span class="string">                     &quot;description&quot;: &quot;RST count exceeded threshold: &#x27;</span><span class="variable">$rst_count</span><span class="string">&#x27;&quot;</span></span><br><span class="line"><span class="string">                 &#125;</span></span><br><span class="line"><span class="string">             &#125;&#x27;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 监控连接建立延迟</span></span><br><span class="line"><span class="function"><span class="title">monitor_connection_latency</span></span>() &#123;</span><br><span class="line">    <span class="built_in">timeout</span> 30 tcpdump -i any -nn -ttt <span class="string">&quot;tcp[tcpflags] &amp; (tcp-syn|tcp-ack) != 0&quot;</span> 2&gt;/dev/null | \</span><br><span class="line">    awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">    /Flags \[S\]/ &#123; syn_time = $1; syn_packet = $0 &#125;</span></span><br><span class="line"><span class="string">    /Flags \[S\.\]/ &#123; </span></span><br><span class="line"><span class="string">        if (syn_time &gt; 0) &#123;</span></span><br><span class="line"><span class="string">            latency = $1 - syn_time</span></span><br><span class="line"><span class="string">            if (latency &gt; 100) &#123;  # 超过100ms告警</span></span><br><span class="line"><span class="string">                print &quot;[&quot; strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) &quot;] HIGH LATENCY:&quot;, latency &quot;ms&quot;</span></span><br><span class="line"><span class="string">                print &quot;SYN:&quot;, syn_packet</span></span><br><span class="line"><span class="string">                print &quot;SYN-ACK:&quot;, $0</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            syn_time = 0</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;&#x27;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 监控重传率</span></span><br><span class="line"><span class="function"><span class="title">monitor_retransmission</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> stats=$(<span class="built_in">timeout</span> 60 tcpdump -i any -nn -c 1000 2&gt;/dev/null | \</span><br><span class="line">                 awk <span class="string">&#x27;/retransmission/ &#123;retrans++&#125; END &#123;</span></span><br><span class="line"><span class="string">                     total=NR; </span></span><br><span class="line"><span class="string">                     rate=(retrans/total)*100; </span></span><br><span class="line"><span class="string">                     print retrans&quot;,&quot;total&quot;,&quot;rate</span></span><br><span class="line"><span class="string">                 &#125;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">local</span> retrans=$(<span class="built_in">echo</span> <span class="variable">$stats</span> | <span class="built_in">cut</span> -d, -f1)</span><br><span class="line">    <span class="built_in">local</span> total=$(<span class="built_in">echo</span> <span class="variable">$stats</span> | <span class="built_in">cut</span> -d, -f2)</span><br><span class="line">    <span class="built_in">local</span> rate=$(<span class="built_in">echo</span> <span class="variable">$stats</span> | <span class="built_in">cut</span> -d, -f3)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (( $(echo &quot;<span class="variable">$rate</span> &gt; <span class="number">5.0</span>&quot; | bc -l) )); <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;[<span class="subst">$(date)</span>] ALERT: High retransmission rate: <span class="variable">$rate</span>%&quot;</span> &gt;&gt; <span class="variable">$LOG_FILE</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    monitor_rst</span><br><span class="line">    monitor_connection_latency  </span><br><span class="line">    monitor_retransmission</span><br><span class="line">    <span class="built_in">sleep</span> 60</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h4 id="网络质量报告生成"><a href="#网络质量报告生成" class="headerlink" title="网络质量报告生成"></a>网络质量报告生成</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># network_quality_report.sh - 生成网络质量报告</span></span><br><span class="line"></span><br><span class="line">CAPTURE_FILE=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">REPORT_FILE=<span class="string">&quot;network_quality_report_<span class="subst">$(date +%Y%m%d_%H%M%S)</span>.html&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 HTML 报告</span></span><br><span class="line"><span class="built_in">cat</span> &gt; <span class="variable">$REPORT_FILE</span> &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">    &lt;title&gt;网络质量分析报告&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body &#123; font-family: Arial, sans-serif; margin: 20px; &#125;</span><br><span class="line">        .metric &#123; background: <span class="comment">#f5f5f5; padding: 10px; margin: 10px 0; &#125;</span></span><br><span class="line">        .warning &#123; background: <span class="comment">#fff3cd; border-left: 4px solid #ffc107; &#125;</span></span><br><span class="line">        .error &#123; background: <span class="comment">#f8d7da; border-left: 4px solid #dc3545; &#125;</span></span><br><span class="line">        .success &#123; background: <span class="comment">#d4edda; border-left: 4px solid #28a745; &#125;</span></span><br><span class="line">        table &#123; border-collapse: collapse; width: 100%; &#125;</span><br><span class="line">        th, td &#123; border: 1px solid <span class="comment">#ddd; padding: 8px; text-align: left; &#125;</span></span><br><span class="line">        th &#123; background-color: <span class="comment">#f2f2f2; &#125;</span></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;h1&gt;网络质量分析报告&lt;/h1&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;p&gt;生成时间: <span class="subst">$(date)</span>&lt;/p&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;p&gt;分析文件: <span class="variable">$CAPTURE_FILE</span>&lt;/p&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础统计</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;h2&gt;基础流量统计&lt;/h2&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;div class=&#x27;metric&#x27;&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"></span><br><span class="line">total_packets=$(tcpdump -r <span class="variable">$CAPTURE_FILE</span> -nn 2&gt;/dev/null | <span class="built_in">wc</span> -l)</span><br><span class="line">tcp_packets=$(tcpdump -r <span class="variable">$CAPTURE_FILE</span> -nn <span class="string">&quot;tcp&quot;</span> 2&gt;/dev/null | <span class="built_in">wc</span> -l)</span><br><span class="line">udp_packets=$(tcpdump -r <span class="variable">$CAPTURE_FILE</span> -nn <span class="string">&quot;udp&quot;</span> 2&gt;/dev/null | <span class="built_in">wc</span> -l)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;p&gt;总包数: <span class="variable">$total_packets</span>&lt;/p&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;p&gt;TCP 包数: <span class="variable">$tcp_packets</span>&lt;/p&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span>  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;p&gt;UDP 包数: <span class="variable">$udp_packets</span>&lt;/p&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;/div&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接问题分析</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;h2&gt;连接问题分析&lt;/h2&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"></span><br><span class="line">rst_count=$(tcpdump -r <span class="variable">$CAPTURE_FILE</span> -nn <span class="string">&quot;tcp[tcpflags] &amp; tcp-rst != 0&quot;</span> 2&gt;/dev/null | <span class="built_in">wc</span> -l)</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$rst_count</span> -gt 10 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&lt;div class=&#x27;metric error&#x27;&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&lt;p&gt;⚠️ 发现大量 RST 包: <span class="variable">$rst_count</span> 个&lt;/p&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&lt;div class=&#x27;metric success&#x27;&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&lt;p&gt;✅ RST 包数量正常: <span class="variable">$rst_count</span> 个&lt;/p&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;/div&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重传分析</span></span><br><span class="line">retrans_count=$(tcpdump -r <span class="variable">$CAPTURE_FILE</span> -nn 2&gt;/dev/null | grep -c <span class="string">&quot;retransmission&quot;</span>)</span><br><span class="line">retrans_rate=$(<span class="built_in">echo</span> <span class="string">&quot;scale=2; <span class="variable">$retrans_count</span> * 100 / <span class="variable">$total_packets</span>&quot;</span> | bc -l)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;h2&gt;重传分析&lt;/h2&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"><span class="keyword">if</span> (( $(echo &quot;<span class="variable">$retrans_rate</span> &gt; <span class="number">3.0</span>&quot; | bc -l) )); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&lt;div class=&#x27;metric warning&#x27;&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&lt;p&gt;⚠️ 重传率较高: <span class="variable">$retrans_rate</span>%&lt;/p&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&lt;div class=&#x27;metric success&#x27;&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&lt;p&gt;✅ 重传率正常: <span class="variable">$retrans_rate</span>%&lt;/p&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;/div&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成报告</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span> &gt;&gt; <span class="variable">$REPORT_FILE</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;报告已生成: <span class="variable">$REPORT_FILE</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="🔍-深度包检测技巧"><a href="#🔍-深度包检测技巧" class="headerlink" title="🔍 深度包检测技巧"></a>🔍 深度包检测技巧</h3><h4 id="应用层协议分析"><a href="#应用层协议分析" class="headerlink" title="应用层协议分析"></a>应用层协议分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. HTTP 性能分析</span></span><br><span class="line">tcpdump -nn -A -s 0 <span class="string">&quot;port 80&quot;</span> | \</span><br><span class="line">awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">/GET|POST|PUT|DELETE/ &#123;</span></span><br><span class="line"><span class="string">    method = $1; url = $2; req_time = systime()</span></span><br><span class="line"><span class="string">    printf &quot;REQUEST: %s %s at %s\n&quot;, method, url, strftime(&quot;%H:%M:%S&quot;, req_time)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">/HTTP.*200/ &#123; </span></span><br><span class="line"><span class="string">    resp_time = systime()</span></span><br><span class="line"><span class="string">    printf &quot;RESPONSE: 200 OK at %s (duration: %ds)\n\n&quot;, strftime(&quot;%H:%M:%S&quot;, resp_time), resp_time - req_time</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. SQL 查询分析</span></span><br><span class="line">tcpdump -nn -A -s 0 <span class="string">&quot;port 3306&quot;</span> | \</span><br><span class="line">grep -E <span class="string">&quot;(SELECT|INSERT|UPDATE|DELETE)&quot;</span> | \</span><br><span class="line">sed <span class="string">&#x27;s/.*\(SELECT\|INSERT\|UPDATE\|DELETE\)/\1/&#x27;</span> | \</span><br><span class="line"><span class="built_in">head</span> -10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Redis 命令分析</span></span><br><span class="line">tcpdump -nn -A -s 0 <span class="string">&quot;port 6379&quot;</span> | \</span><br><span class="line">grep -oE <span class="string">&quot;(GET|SET|HGET|HSET|LPUSH|RPOP)[^\\r\\n]*&quot;</span> | \</span><br><span class="line"><span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. DNS 查询类型统计</span></span><br><span class="line">tcpdump -nn -r capture.pcap <span class="string">&quot;port 53&quot;</span> | \</span><br><span class="line">awk <span class="string">&#x27;/A\?/ &#123;a_queries++&#125; /AAAA\?/ &#123;aaaa_queries++&#125; /MX\?/ &#123;mx_queries++&#125; /CNAME\?/ &#123;cname_queries++&#125; </span></span><br><span class="line"><span class="string">END &#123;</span></span><br><span class="line"><span class="string">    print &quot;A queries:&quot;, a_queries</span></span><br><span class="line"><span class="string">    print &quot;AAAA queries:&quot;, aaaa_queries  </span></span><br><span class="line"><span class="string">    print &quot;MX queries:&quot;, mx_queries</span></span><br><span class="line"><span class="string">    print &quot;CNAME queries:&quot;, cname_queries</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="网络安全分析"><a href="#网络安全分析" class="headerlink" title="网络安全分析"></a>网络安全分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 端口扫描检测</span></span><br><span class="line">tcpdump -nn <span class="string">&quot;tcp[tcpflags] &amp; tcp-syn != 0&quot;</span> | \</span><br><span class="line">awk <span class="string">&#x27;&#123;print $3, $5&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr | <span class="built_in">head</span> -10</span><br><span class="line"><span class="comment"># 如果看到同一源IP对多个端口发起连接，可能是端口扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. DDoS 攻击检测</span></span><br><span class="line">tcpdump -nn -c 10000 | \</span><br><span class="line">awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> | <span class="built_in">cut</span> -d. -f1-4 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr | <span class="built_in">head</span> -10</span><br><span class="line"><span class="comment"># 如果某个IP的请求数异常高，可能是攻击</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 异常流量模式检测</span></span><br><span class="line">tcpdump -nn | \</span><br><span class="line">awk <span class="string">&#x27;length($0) &gt; 200 &#123;long_packets++&#125; </span></span><br><span class="line"><span class="string">     /Flags \[R\]/ &#123;rst_packets++&#125;</span></span><br><span class="line"><span class="string">     /ttl 1/ &#123;suspicious_ttl++&#125;</span></span><br><span class="line"><span class="string">     END &#123;</span></span><br><span class="line"><span class="string">         print &quot;Long packets:&quot;, long_packets</span></span><br><span class="line"><span class="string">         print &quot;RST packets:&quot;, rst_packets</span></span><br><span class="line"><span class="string">         print &quot;Suspicious TTL:&quot;, suspicious_ttl</span></span><br><span class="line"><span class="string">     &#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. SSL/TLS 版本分析</span></span><br><span class="line">tcpdump -nn -X <span class="string">&quot;port 443&quot;</span> | \</span><br><span class="line">grep -oE <span class="string">&quot;TLS 1\.[0-3]&quot;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🎓-总结与提升建议"><a href="#🎓-总结与提升建议" class="headerlink" title="🎓 总结与提升建议"></a>🎓 总结与提升建议</h2><h3 id="📚-知识点总结"><a href="#📚-知识点总结" class="headerlink" title="📚 知识点总结"></a>📚 知识点总结</h3><h4 id="TCP-状态机理解"><a href="#TCP-状态机理解" class="headerlink" title="TCP 状态机理解"></a>TCP 状态机理解</h4><ul>
<li><strong>LISTEN</strong>: 服务端等待连接</li>
<li><strong>SYN_SENT</strong>: 客户端发起连接等待响应</li>
<li><strong>SYN_RECEIVED</strong>: 服务端收到SYN等待ACK</li>
<li><strong>ESTABLISHED</strong>: 连接建立，数据传输状态</li>
<li><strong>FIN_WAIT_1&#x2F;2</strong>: 主动关闭方的等待状态</li>
<li><strong>CLOSE_WAIT</strong>: 被动关闭方等待应用程序关闭</li>
<li><strong>TIME_WAIT</strong>: 主动关闭方的最终等待状态</li>
</ul>
<h4 id="负载均衡器行为模式"><a href="#负载均衡器行为模式" class="headerlink" title="负载均衡器行为模式"></a>负载均衡器行为模式</h4><ul>
<li><strong>4层LB</strong>: 基于IP+端口转发，维持连接状态</li>
<li><strong>7层LB</strong>: 解析应用协议，可以路由和修改内容</li>
<li><strong>健康检查</strong>: 定期探测后端服务可用性</li>
<li><strong>会话保持</strong>: 确保同一用户的请求到达同一后端</li>
</ul>
<h4 id="性能优化要点"><a href="#性能优化要点" class="headerlink" title="性能优化要点"></a>性能优化要点</h4><ul>
<li><strong>连接复用</strong>: 减少TCP握手开销</li>
<li><strong>Keep-Alive</strong>: HTTP连接保持</li>
<li><strong>压缩传输</strong>: 减少网络传输量</li>
<li><strong>缓存策略</strong>: 减少不必要的网络请求</li>
</ul>
<h3 id="🚀-进阶学习路径"><a href="#🚀-进阶学习路径" class="headerlink" title="🚀 进阶学习路径"></a>🚀 进阶学习路径</h3><ol>
<li><p><strong>协议深入</strong></p>
<ul>
<li>学习 HTTP&#x2F;2, HTTP&#x2F;3 特性</li>
<li>理解 QUIC 协议优势</li>
<li>掌握 WebSocket 长连接机制</li>
</ul>
</li>
<li><p><strong>容器网络</strong></p>
<ul>
<li>Kubernetes 网络模型</li>
<li>CNI 插件原理</li>
<li>Service Mesh 架构</li>
</ul>
</li>
<li><p><strong>监控工具</strong></p>
<ul>
<li>Wireshark 高级功能</li>
<li>网络监控系统 (Prometheus + Grafana)</li>
<li>APM 工具集成</li>
</ul>
</li>
<li><p><strong>自动化运维</strong></p>
<ul>
<li>网络问题自动检测</li>
<li>告警规则设计</li>
<li>故障自愈机制</li>
</ul>
</li>
</ol>
<hr>
<p><strong>最后更新时间:</strong> $(date +%Y-%m-%d)<br><strong>版本:</strong> v2.0<br><strong>适用场景:</strong> 服务端开发、网络运维、性能优化</p>
]]></content>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>pod生命周期与webhook管控分析</title>
    <url>/2025/08/01/pod%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8Ewebhook%E7%AE%A1%E6%8E%A7%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Kubernetes-Pod-生命周期与-Webhook-管控分析"><a href="#Kubernetes-Pod-生命周期与-Webhook-管控分析" class="headerlink" title="Kubernetes Pod 生命周期与 Webhook 管控分析"></a>Kubernetes Pod 生命周期与 Webhook 管控分析</h1><h2 id="🎯-目录"><a href="#🎯-目录" class="headerlink" title="🎯 目录"></a>🎯 目录</h2><ul>
<li><a href="#pod-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3">Pod 生命周期状态详解</a></li>
<li><a href="#webhook-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA">Webhook 类型与触发时机</a></li>
<li><a href="#%E5%90%84%E9%98%B6%E6%AE%B5-webhook-%E7%AE%A1%E6%8E%A7%E8%83%BD%E5%8A%9B">各阶段 Webhook 管控能力</a></li>
<li><a href="#pod-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B%E5%9B%BE">Pod 生命周期流程图</a></li>
<li><a href="#%E5%AE%9E%E6%88%98%E5%9C%BA%E6%99%AF%E4%B8%8E%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B">实战场景与配置示例</a></li>
<li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">最佳实践与注意事项</a></li>
</ul>
<hr>
<h2 id="Pod-生命周期状态详解"><a href="#Pod-生命周期状态详解" class="headerlink" title="Pod 生命周期状态详解"></a>Pod 生命周期状态详解</h2><h3 id="📊-Pod-状态转换表"><a href="#📊-Pod-状态转换表" class="headerlink" title="📊 Pod 状态转换表"></a>📊 Pod 状态转换表</h3><table>
<thead>
<tr>
<th>阶段</th>
<th>Pod Phase</th>
<th>Pod Condition</th>
<th>Container State</th>
<th>Webhook 触发</th>
<th>管控能力</th>
</tr>
</thead>
<tbody><tr>
<td><strong>创建前</strong></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>✅ ValidatingAdmissionWebhook<br>✅ MutatingAdmissionWebhook</td>
<td>🔥 <strong>完全管控</strong></td>
</tr>
<tr>
<td><strong>创建中</strong></td>
<td>Pending</td>
<td>PodScheduled: False</td>
<td>Waiting</td>
<td>❌</td>
<td>🚫 <strong>无法管控</strong></td>
</tr>
<tr>
<td><strong>调度中</strong></td>
<td>Pending</td>
<td>PodScheduled: True</td>
<td>Waiting</td>
<td>❌</td>
<td>🚫 <strong>无法管控</strong></td>
</tr>
<tr>
<td><strong>初始化</strong></td>
<td>Pending</td>
<td>Initialized: False</td>
<td>Waiting&#x2F;Running</td>
<td>❌</td>
<td>🚫 <strong>无法管控</strong></td>
</tr>
<tr>
<td><strong>运行中</strong></td>
<td>Running</td>
<td>Ready: True</td>
<td>Running</td>
<td>❌</td>
<td>🚫 <strong>无法管控</strong></td>
</tr>
<tr>
<td><strong>终止前</strong></td>
<td>Running → Terminating</td>
<td>-</td>
<td>Running</td>
<td>✅ Lifecycle PreStop Hook</td>
<td>⚠️ <strong>有限管控</strong></td>
</tr>
<tr>
<td><strong>终止中</strong></td>
<td>Terminating</td>
<td>-</td>
<td>Terminating</td>
<td>❌</td>
<td>🚫 <strong>无法管控</strong></td>
</tr>
<tr>
<td><strong>完成&#x2F;失败</strong></td>
<td>Succeeded&#x2F;Failed</td>
<td>-</td>
<td>Terminated</td>
<td>❌</td>
<td>🚫 <strong>无法管控</strong></td>
</tr>
</tbody></table>
<h3 id="🔍-关键观察点"><a href="#🔍-关键观察点" class="headerlink" title="🔍 关键观察点"></a>🔍 关键观察点</h3><h4 id="1-Webhook-生效的关键时刻"><a href="#1-Webhook-生效的关键时刻" class="headerlink" title="1. Webhook 生效的关键时刻"></a>1. Webhook 生效的关键时刻</h4><ul>
<li><strong>Pod 创建前</strong>：Admission Controller 阶段，最强管控能力</li>
<li><strong>Pod 终止前</strong>：PreStop Hook 阶段，有限的优雅关闭控制</li>
</ul>
<h4 id="2-无法管控的阶段"><a href="#2-无法管控的阶段" class="headerlink" title="2. 无法管控的阶段"></a>2. 无法管控的阶段</h4><ul>
<li>Pod 创建后的整个运行生命周期</li>
<li>容器启动、健康检查、重启等过程</li>
<li>资源调度和节点分配过程</li>
</ul>
<hr>
<h2 id="Webhook-类型与触发时机"><a href="#Webhook-类型与触发时机" class="headerlink" title="Webhook 类型与触发时机"></a>Webhook 类型与触发时机</h2><h3 id="🎣-Admission-Controller-Webhook"><a href="#🎣-Admission-Controller-Webhook" class="headerlink" title="🎣 Admission Controller Webhook"></a>🎣 Admission Controller Webhook</h3><h4 id="ValidatingAdmissionWebhook"><a href="#ValidatingAdmissionWebhook" class="headerlink" title="ValidatingAdmissionWebhook"></a>ValidatingAdmissionWebhook</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ValidatingAdmissionWebhook</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-validator</span></span><br><span class="line"><span class="attr">webhooks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">validate-pod.example.com</span></span><br><span class="line">  <span class="attr">clientConfig:</span></span><br><span class="line">    <span class="attr">service:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">webhook-service</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">webhook-system</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">&quot;/validate&quot;</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">operations:</span> [<span class="string">&quot;CREATE&quot;</span>, <span class="string">&quot;UPDATE&quot;</span>]</span><br><span class="line">    <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">apiVersions:</span> [<span class="string">&quot;v1&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">admissionReviewVersions:</span> [<span class="string">&quot;v1&quot;</span>, <span class="string">&quot;v1beta1&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>触发时机：</strong></p>
<ul>
<li>✅ Pod CREATE 请求</li>
<li>✅ Pod UPDATE 请求  </li>
<li>✅ 在 etcd 存储之前</li>
<li>✅ 在调度器分配之前</li>
</ul>
<p><strong>管控能力：</strong></p>
<ul>
<li>🔥 <strong>拒绝创建</strong>：返回错误阻止 Pod 创建</li>
<li>🔥 <strong>验证规则</strong>：检查资源限制、标签、注解等</li>
<li>🔥 <strong>安全策略</strong>：强制安全策略合规</li>
</ul>
<h4 id="MutatingAdmissionWebhook"><a href="#MutatingAdmissionWebhook" class="headerlink" title="MutatingAdmissionWebhook"></a>MutatingAdmissionWebhook</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">MutatingAdmissionWebhook</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-mutator</span></span><br><span class="line"><span class="attr">webhooks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mutate-pod.example.com</span></span><br><span class="line">  <span class="attr">clientConfig:</span></span><br><span class="line">    <span class="attr">service:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">webhook-service</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">webhook-system</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">&quot;/mutate&quot;</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">operations:</span> [<span class="string">&quot;CREATE&quot;</span>]</span><br><span class="line">    <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">apiVersions:</span> [<span class="string">&quot;v1&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">admissionReviewVersions:</span> [<span class="string">&quot;v1&quot;</span>, <span class="string">&quot;v1beta1&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>管控能力：</strong></p>
<ul>
<li>🔥 <strong>修改配置</strong>：注入 sidecar 容器</li>
<li>🔥 <strong>添加资源</strong>：设置默认资源限制</li>
<li>🔥 <strong>安全增强</strong>：添加安全上下文</li>
<li>🔥 <strong>环境注入</strong>：添加环境变量、挂载点</li>
</ul>
<h3 id="🪝-Lifecycle-Hook"><a href="#🪝-Lifecycle-Hook" class="headerlink" title="🪝 Lifecycle Hook"></a>🪝 Lifecycle Hook</h3><h4 id="PreStop-Hook"><a href="#PreStop-Hook" class="headerlink" title="PreStop Hook"></a>PreStop Hook</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;nginx -s quit; while killall -0 nginx; do sleep 1; done&quot;</span>]</span><br><span class="line">        <span class="comment"># 或者 HTTP 调用</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/shutdown</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br></pre></td></tr></table></figure>

<p><strong>触发时机：</strong></p>
<ul>
<li>✅ Pod 收到 SIGTERM 之前</li>
<li>✅ 删除 Pod 时</li>
<li>✅ 节点驱逐时</li>
<li>✅ Deployment 滚动更新时</li>
</ul>
<p><strong>管控能力：</strong></p>
<ul>
<li>⚠️ <strong>优雅关闭</strong>：清理资源、保存状态</li>
<li>⚠️ <strong>完成处理</strong>：处理剩余请求</li>
<li>⚠️ <strong>通知服务</strong>：通知其他服务下线</li>
<li>⚠️ <strong>有时间限制</strong>：默认 30s (terminationGracePeriodSeconds)</li>
</ul>
<hr>
<h2 id="各阶段-Webhook-管控能力"><a href="#各阶段-Webhook-管控能力" class="headerlink" title="各阶段 Webhook 管控能力"></a>各阶段 Webhook 管控能力</h2><h3 id="🚀-Pod-创建阶段-最强管控"><a href="#🚀-Pod-创建阶段-最强管控" class="headerlink" title="🚀 Pod 创建阶段 (最强管控)"></a>🚀 Pod 创建阶段 (最强管控)</h3><h4 id="Mutating-Webhook-典型用例"><a href="#Mutating-Webhook-典型用例" class="headerlink" title="Mutating Webhook 典型用例"></a>Mutating Webhook 典型用例</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. Sidecar 注入</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app-pod</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">sidecar.istio.io/inject:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp:latest</span></span><br><span class="line"><span class="comment"># 经过 Mutating Webhook 后:</span></span><br><span class="line"><span class="comment"># + istio-proxy sidecar 容器</span></span><br><span class="line"><span class="comment"># + 相关 volume 和 挂载点</span></span><br><span class="line"><span class="comment"># + 网络配置修改</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. 安全策略注入</span></span><br><span class="line"><span class="comment"># 原始 Pod 规范</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp:latest</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 经过 Mutating Webhook 后:</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">securityContext:</span></span><br><span class="line">    <span class="attr">runAsNonRoot:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">runAsUser:</span> <span class="number">1000</span></span><br><span class="line">    <span class="attr">fsGroup:</span> <span class="number">2000</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp:latest</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">capabilities:</span></span><br><span class="line">        <span class="attr">drop:</span> [<span class="string">&quot;ALL&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="Validating-Webhook-典型场景"><a href="#Validating-Webhook-典型场景" class="headerlink" title="Validating Webhook 典型场景"></a>Validating Webhook 典型场景</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Webhook 验证逻辑示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validatePod</span><span class="params">(pod *corev1.Pod)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 资源限制检查</span></span><br><span class="line">    <span class="keyword">for</span> _, container := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line">        <span class="keyword">if</span> container.Resources.Limits == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;container %s must have resource limits&quot;</span>, container.Name)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cpuLimit := container.Resources.Limits[corev1.ResourceCPU]</span><br><span class="line">        <span class="keyword">if</span> cpuLimit.IsZero() || cpuLimit.Cmp(resource.MustParse(<span class="string">&quot;2&quot;</span>)) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;CPU limit must be between 0 and 2 cores&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 镜像安全检查</span></span><br><span class="line">    <span class="keyword">for</span> _, container := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line">        <span class="keyword">if</span> !strings.HasPrefix(container.Image, <span class="string">&quot;registry.company.com/&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;only internal registry images are allowed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 标签必需性检查</span></span><br><span class="line">    <span class="keyword">if</span> pod.Labels[<span class="string">&quot;app&quot;</span>] == <span class="string">&quot;&quot;</span> || pod.Labels[<span class="string">&quot;version&quot;</span>] == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;app and version labels are required&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="⚠️-Pod-终止阶段-有限管控"><a href="#⚠️-Pod-终止阶段-有限管控" class="headerlink" title="⚠️ Pod 终止阶段 (有限管控)"></a>⚠️ Pod 终止阶段 (有限管控)</h3><h4 id="PreStop-Hook-使用场景"><a href="#PreStop-Hook-使用场景" class="headerlink" title="PreStop Hook 使用场景"></a>PreStop Hook 使用场景</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 数据库连接池优雅关闭</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">myapp:latest</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">            # 停止接受新请求</span></span><br><span class="line"><span class="string">            curl -X POST http://localhost:8080/admin/shutdown</span></span><br><span class="line"><span class="string"></span>            </span><br><span class="line">            <span class="comment"># 等待现有请求完成</span></span><br><span class="line">            <span class="string">while</span> [ <span class="string">$(curl</span> <span class="string">-s</span> <span class="string">http://localhost:8080/admin/connections)</span> <span class="string">-gt</span> <span class="number">0</span> ]<span class="string">;</span> <span class="string">do</span></span><br><span class="line">              <span class="string">echo</span> <span class="string">&quot;Waiting for connections to drain...&quot;</span></span><br><span class="line">              <span class="string">sleep</span> <span class="number">2</span></span><br><span class="line">            <span class="string">done</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 清理缓存</span></span><br><span class="line">            <span class="string">curl</span> <span class="string">-X</span> <span class="string">POST</span> <span class="string">http://localhost:8080/admin/flush-cache</span></span><br><span class="line">            </span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;Graceful shutdown completed&quot;</span></span><br><span class="line">  <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">60</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. 消息队列消费者优雅关闭</span></span><br><span class="line"><span class="attr">lifecycle:</span></span><br><span class="line">  <span class="attr">preStop:</span></span><br><span class="line">    <span class="attr">exec:</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">        # 停止消费新消息</span></span><br><span class="line"><span class="string">        kill -USR1 $(pgrep consumer)</span></span><br><span class="line"><span class="string"></span>        </span><br><span class="line">        <span class="comment"># 等待当前消息处理完成</span></span><br><span class="line">        <span class="string">while</span> <span class="string">pgrep</span> <span class="string">-f</span> <span class="string">&quot;processing_message&quot;</span> <span class="string">&gt;</span> <span class="string">/dev/null;</span> <span class="string">do</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">&quot;Waiting for message processing...&quot;</span></span><br><span class="line">          <span class="string">sleep</span> <span class="number">1</span></span><br><span class="line">        <span class="string">done</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 提交偏移量</span></span><br><span class="line">        <span class="string">/app/commit_offsets.sh</span></span><br></pre></td></tr></table></figure>

<h3 id="🚫-无法管控的阶段"><a href="#🚫-无法管控的阶段" class="headerlink" title="🚫 无法管控的阶段"></a>🚫 无法管控的阶段</h3><h4 id="运行时状态变化"><a href="#运行时状态变化" class="headerlink" title="运行时状态变化"></a>运行时状态变化</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这些状态变化无法通过 Webhook 管控:</span></span><br><span class="line"><span class="comment"># - 容器启动失败 (CrashLoopBackOff)</span></span><br><span class="line"><span class="comment"># - 健康检查失败 (Liveness/Readiness Probe)</span></span><br><span class="line"><span class="comment"># - 资源不足导致驱逐 (Evicted)</span></span><br><span class="line"><span class="comment"># - 节点故障导致的 Pod 重新调度</span></span><br><span class="line"><span class="comment"># - OOMKilled 状态</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Pod-生命周期流程图"><a href="#Pod-生命周期流程图" class="headerlink" title="Pod 生命周期流程图"></a>Pod 生命周期流程图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[kubectl apply pod.yaml] --&gt; B&#123;Mutating Admission Webhook&#125;</span><br><span class="line">    B --&gt; C&#123;Validating Admission Webhook&#125;</span><br><span class="line">    C --&gt;|Approved| D[Pod Stored in etcd]</span><br><span class="line">    C --&gt;|Rejected| E[Creation Failed]</span><br><span class="line">    B --&gt;|Modified| C</span><br><span class="line">    </span><br><span class="line">    D --&gt; F[Scheduler Assigns Node]</span><br><span class="line">    F --&gt; G[Kubelet Pulls Images]</span><br><span class="line">    G --&gt; H[Init Containers]</span><br><span class="line">    H --&gt; I[Main Containers Start]</span><br><span class="line">    I --&gt; J&#123;Health Checks&#125;</span><br><span class="line">    J --&gt;|Pass| K[Pod Running]</span><br><span class="line">    J --&gt;|Fail| L[Container Restart]</span><br><span class="line">    L --&gt; I</span><br><span class="line">    </span><br><span class="line">    K --&gt; M[Application Serving]</span><br><span class="line">    M --&gt; N&#123;Termination Signal?&#125;</span><br><span class="line">    N --&gt;|No| M</span><br><span class="line">    N --&gt;|Yes| O[PreStop Hook Execution]</span><br><span class="line">    </span><br><span class="line">    O --&gt; P[SIGTERM Sent]</span><br><span class="line">    P --&gt; Q[Graceful Shutdown Period]</span><br><span class="line">    Q --&gt; R&#123;Containers Stopped?&#125;</span><br><span class="line">    R --&gt;|Yes| S[Pod Terminated]</span><br><span class="line">    R --&gt;|No| T[SIGKILL After Grace Period]</span><br><span class="line">    T --&gt; S</span><br><span class="line">    </span><br><span class="line">    S --&gt; U[Pod Removed from etcd]</span><br><span class="line">    </span><br><span class="line">    style B fill:#ffeb3b</span><br><span class="line">    style C fill:#ffeb3b</span><br><span class="line">    style O fill:#ff9800</span><br><span class="line">    style E fill:#f44336</span><br><span class="line">    style K fill:#4caf50</span><br><span class="line">    style S fill:#9e9e9e</span><br></pre></td></tr></table></figure>

<h3 id="🎯-关键控制点说明"><a href="#🎯-关键控制点说明" class="headerlink" title="🎯 关键控制点说明"></a>🎯 关键控制点说明</h3><h4 id="1-创建前控制点-最强管控"><a href="#1-创建前控制点-最强管控" class="headerlink" title="1. 创建前控制点 (最强管控)"></a>1. <strong>创建前控制点</strong> (最强管控)</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 时机：Pod 对象创建之前</span></span><br><span class="line"><span class="comment"># 位置：API Server 接收到请求后，存储到 etcd 之前</span></span><br><span class="line"><span class="comment"># 能力：</span></span><br><span class="line"><span class="comment"># - 完全拒绝创建</span></span><br><span class="line"><span class="comment"># - 修改 Pod 规范</span></span><br><span class="line"><span class="comment"># - 注入额外配置</span></span><br><span class="line"><span class="comment"># - 强制安全策略</span></span><br></pre></td></tr></table></figure>

<h4 id="2-终止前控制点-有限管控"><a href="#2-终止前控制点-有限管控" class="headerlink" title="2. 终止前控制点 (有限管控)"></a>2. <strong>终止前控制点</strong> (有限管控)</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 时机：Pod 收到删除信号后，SIGTERM 发送前</span></span><br><span class="line"><span class="comment"># 位置：容器运行时准备终止容器时</span></span><br><span class="line"><span class="comment"># 能力：</span></span><br><span class="line"><span class="comment"># - 优雅关闭处理</span></span><br><span class="line"><span class="comment"># - 清理资源</span></span><br><span class="line"><span class="comment"># - 保存状态</span></span><br><span class="line"><span class="comment"># - 通知其他服务</span></span><br><span class="line"><span class="comment"># 限制：</span></span><br><span class="line"><span class="comment"># - 有时间限制 (terminationGracePeriodSeconds)</span></span><br><span class="line"><span class="comment"># - 无法阻止删除</span></span><br><span class="line"><span class="comment"># - 无法修改 Pod 规范</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="实战场景与配置示例"><a href="#实战场景与配置示例" class="headerlink" title="实战场景与配置示例"></a>实战场景与配置示例</h2><h3 id="场景1：安全合规检查"><a href="#场景1：安全合规检查" class="headerlink" title="场景1：安全合规检查"></a>场景1：安全合规检查</h3><h4 id="Validating-Webhook-实现"><a href="#Validating-Webhook-实现" class="headerlink" title="Validating Webhook 实现"></a>Validating Webhook 实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    </span><br><span class="line">    admissionv1 <span class="string">&quot;k8s.io/api/admission/v1&quot;</span></span><br><span class="line">    corev1 <span class="string">&quot;k8s.io/api/core/v1&quot;</span></span><br><span class="line">    metav1 <span class="string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span></span><br><span class="line">    <span class="string">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SecurityValidator <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sv *SecurityValidator)</span></span> ValidatePod(pod *corev1.Pod) []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> violations []<span class="type">string</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查特权容器</span></span><br><span class="line">    <span class="keyword">for</span> _, container := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line">        <span class="keyword">if</span> container.SecurityContext != <span class="literal">nil</span> &amp;&amp; </span><br><span class="line">           container.SecurityContext.Privileged != <span class="literal">nil</span> &amp;&amp; </span><br><span class="line">           *container.SecurityContext.Privileged &#123;</span><br><span class="line">            violations = <span class="built_in">append</span>(violations, </span><br><span class="line">                fmt.Sprintf(<span class="string">&quot;Privileged container not allowed: %s&quot;</span>, container.Name))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查 root 用户</span></span><br><span class="line">        <span class="keyword">if</span> container.SecurityContext == <span class="literal">nil</span> || </span><br><span class="line">           container.SecurityContext.RunAsNonRoot == <span class="literal">nil</span> || </span><br><span class="line">           !*container.SecurityContext.RunAsNonRoot &#123;</span><br><span class="line">            violations = <span class="built_in">append</span>(violations, </span><br><span class="line">                fmt.Sprintf(<span class="string">&quot;Container must run as non-root: %s&quot;</span>, container.Name))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查资源限制</span></span><br><span class="line">        <span class="keyword">if</span> container.Resources.Limits == <span class="literal">nil</span> &#123;</span><br><span class="line">            violations = <span class="built_in">append</span>(violations, </span><br><span class="line">                fmt.Sprintf(<span class="string">&quot;Resource limits required: %s&quot;</span>, container.Name))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查网络策略</span></span><br><span class="line">    <span class="keyword">if</span> pod.Spec.HostNetwork &#123;</span><br><span class="line">        violations = <span class="built_in">append</span>(violations, <span class="string">&quot;Host network not allowed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查卷挂载</span></span><br><span class="line">    <span class="keyword">for</span> _, volume := <span class="keyword">range</span> pod.Spec.Volumes &#123;</span><br><span class="line">        <span class="keyword">if</span> volume.HostPath != <span class="literal">nil</span> &#123;</span><br><span class="line">            violations = <span class="built_in">append</span>(violations, </span><br><span class="line">                fmt.Sprintf(<span class="string">&quot;HostPath volume not allowed: %s&quot;</span>, volume.Name))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> violations</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sv *SecurityValidator)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">var</span> body []<span class="type">byte</span></span><br><span class="line">    <span class="keyword">if</span> r.Body != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> data, err := io.ReadAll(r.Body); err == <span class="literal">nil</span> &#123;</span><br><span class="line">            body = data</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> admissionResponse *admissionv1.AdmissionResponse</span><br><span class="line">    ar := admissionv1.AdmissionReview&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(body, &amp;ar); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        admissionResponse = &amp;admissionv1.AdmissionResponse&#123;</span><br><span class="line">            Result: &amp;metav1.Status&#123;</span><br><span class="line">                Message: err.Error(),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        admissionResponse = sv.validate(&amp;ar)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    admissionReview := admissionv1.AdmissionReview&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> admissionResponse != <span class="literal">nil</span> &#123;</span><br><span class="line">        admissionReview.Response = admissionResponse</span><br><span class="line">        <span class="keyword">if</span> ar.Request != <span class="literal">nil</span> &#123;</span><br><span class="line">            admissionReview.Response.UID = ar.Request.UID</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    respBytes, _ := json.Marshal(admissionReview)</span><br><span class="line">    w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    w.Write(respBytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sv *SecurityValidator)</span></span> validate(ar *admissionv1.AdmissionReview) *admissionv1.AdmissionResponse &#123;</span><br><span class="line">    req := ar.Request</span><br><span class="line">    <span class="keyword">var</span> pod corev1.Pod</span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(req.Object.Raw, &amp;pod); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;admissionv1.AdmissionResponse&#123;</span><br><span class="line">            Result: &amp;metav1.Status&#123;</span><br><span class="line">                Message: err.Error(),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    violations := sv.ValidatePod(&amp;pod)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(violations) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;admissionv1.AdmissionResponse&#123;</span><br><span class="line">            Allowed: <span class="literal">false</span>,</span><br><span class="line">            Result: &amp;metav1.Status&#123;</span><br><span class="line">                Message: fmt.Sprintf(<span class="string">&quot;Security violations: %v&quot;</span>, violations),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;admissionv1.AdmissionResponse&#123;</span><br><span class="line">        Allowed: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="场景2：Sidecar-自动注入"><a href="#场景2：Sidecar-自动注入" class="headerlink" title="场景2：Sidecar 自动注入"></a>场景2：Sidecar 自动注入</h3><h4 id="Mutating-Webhook-实现"><a href="#Mutating-Webhook-实现" class="headerlink" title="Mutating Webhook 实现"></a>Mutating Webhook 实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    </span><br><span class="line">    corev1 <span class="string">&quot;k8s.io/api/core/v1&quot;</span></span><br><span class="line">    <span class="string">&quot;k8s.io/apimachinery/pkg/api/resource&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SidecarInjector <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(si *SidecarInjector)</span></span> InjectSidecar(pod *corev1.Pod) []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否需要注入</span></span><br><span class="line">    <span class="keyword">if</span> pod.Annotations == <span class="literal">nil</span> || pod.Annotations[<span class="string">&quot;sidecar.example.com/inject&quot;</span>] != <span class="string">&quot;true&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> patches []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注入 sidecar 容器</span></span><br><span class="line">    sidecarContainer := corev1.Container&#123;</span><br><span class="line">        Name:  <span class="string">&quot;logging-sidecar&quot;</span>,</span><br><span class="line">        Image: <span class="string">&quot;fluent/fluent-bit:1.8&quot;</span>,</span><br><span class="line">        Resources: corev1.ResourceRequirements&#123;</span><br><span class="line">            Limits: corev1.ResourceList&#123;</span><br><span class="line">                corev1.ResourceCPU:    resource.MustParse(<span class="string">&quot;100m&quot;</span>),</span><br><span class="line">                corev1.ResourceMemory: resource.MustParse(<span class="string">&quot;128Mi&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            Requests: corev1.ResourceList&#123;</span><br><span class="line">                corev1.ResourceCPU:    resource.MustParse(<span class="string">&quot;50m&quot;</span>),</span><br><span class="line">                corev1.ResourceMemory: resource.MustParse(<span class="string">&quot;64Mi&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        VolumeMounts: []corev1.VolumeMount&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                Name:      <span class="string">&quot;app-logs&quot;</span>,</span><br><span class="line">                MountPath: <span class="string">&quot;/var/log/app&quot;</span>,</span><br><span class="line">                ReadOnly:  <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                Name:      <span class="string">&quot;fluent-bit-config&quot;</span>,</span><br><span class="line">                MountPath: <span class="string">&quot;/fluent-bit/etc&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加容器的 patch</span></span><br><span class="line">    patches = <span class="built_in">append</span>(patches, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;op&quot;</span>:    <span class="string">&quot;add&quot;</span>,</span><br><span class="line">        <span class="string">&quot;path&quot;</span>:  <span class="string">&quot;/spec/containers/-&quot;</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: sidecarContainer,</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注入共享卷</span></span><br><span class="line">    logVolume := corev1.Volume&#123;</span><br><span class="line">        Name: <span class="string">&quot;app-logs&quot;</span>,</span><br><span class="line">        VolumeSource: corev1.VolumeSource&#123;</span><br><span class="line">            EmptyDir: &amp;corev1.EmptyDirVolumeSource&#123;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    configVolume := corev1.Volume&#123;</span><br><span class="line">        Name: <span class="string">&quot;fluent-bit-config&quot;</span>,</span><br><span class="line">        VolumeSource: corev1.VolumeSource&#123;</span><br><span class="line">            ConfigMap: &amp;corev1.ConfigMapVolumeSource&#123;</span><br><span class="line">                LocalObjectReference: corev1.LocalObjectReference&#123;</span><br><span class="line">                    Name: <span class="string">&quot;fluent-bit-config&quot;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pod.Spec.Volumes) == <span class="number">0</span> &#123;</span><br><span class="line">        patches = <span class="built_in">append</span>(patches, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;op&quot;</span>:    <span class="string">&quot;add&quot;</span>,</span><br><span class="line">            <span class="string">&quot;path&quot;</span>:  <span class="string">&quot;/spec/volumes&quot;</span>,</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: []corev1.Volume&#123;logVolume, configVolume&#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        patches = <span class="built_in">append</span>(patches, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;op&quot;</span>:    <span class="string">&quot;add&quot;</span>,</span><br><span class="line">            <span class="string">&quot;path&quot;</span>:  <span class="string">&quot;/spec/volumes/-&quot;</span>,</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: logVolume,</span><br><span class="line">        &#125;)</span><br><span class="line">        patches = <span class="built_in">append</span>(patches, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;op&quot;</span>:    <span class="string">&quot;add&quot;</span>,</span><br><span class="line">            <span class="string">&quot;path&quot;</span>:  <span class="string">&quot;/spec/volumes/-&quot;</span>,</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: configVolume,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为主容器添加日志卷挂载</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line">        patches = <span class="built_in">append</span>(patches, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;op&quot;</span>:   <span class="string">&quot;add&quot;</span>,</span><br><span class="line">            <span class="string">&quot;path&quot;</span>: fmt.Sprintf(<span class="string">&quot;/spec/containers/%d/volumeMounts/-&quot;</span>, i),</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: corev1.VolumeMount&#123;</span><br><span class="line">                Name:      <span class="string">&quot;app-logs&quot;</span>,</span><br><span class="line">                MountPath: <span class="string">&quot;/var/log/app&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    patchBytes, _ := json.Marshal(patches)</span><br><span class="line">    <span class="keyword">return</span> patchBytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="场景3：优雅关闭处理"><a href="#场景3：优雅关闭处理" class="headerlink" title="场景3：优雅关闭处理"></a>场景3：优雅关闭处理</h3><h4 id="PreStop-Hook-配置"><a href="#PreStop-Hook-配置" class="headerlink" title="PreStop Hook 配置"></a>PreStop Hook 配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">web-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">web-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">60</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web-app</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.21</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">lifecycle:</span></span><br><span class="line">          <span class="attr">preStop:</span></span><br><span class="line">            <span class="attr">exec:</span></span><br><span class="line">              <span class="attr">command:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">                echo &quot;Starting graceful shutdown...&quot;</span></span><br><span class="line"><span class="string"></span>                </span><br><span class="line">                <span class="comment"># 1. 停止接受新连接 (从负载均衡器摘除)</span></span><br><span class="line">                <span class="string">curl</span> <span class="string">-X</span> <span class="string">POST</span> <span class="string">http://localhost:8080/admin/health/disable</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 2. 等待现有连接完成</span></span><br><span class="line">                <span class="string">echo</span> <span class="string">&quot;Waiting for connections to finish...&quot;</span></span><br><span class="line">                <span class="string">timeout=50</span></span><br><span class="line">                <span class="string">while</span> [ <span class="string">$timeout</span> <span class="string">-gt</span> <span class="number">0</span> ]<span class="string">;</span> <span class="string">do</span></span><br><span class="line">                  <span class="string">active_conn=$(netstat</span> <span class="string">-an</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">:80</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">ESTABLISHED</span> <span class="string">|</span> <span class="string">wc</span> <span class="string">-l)</span></span><br><span class="line">                  <span class="string">if</span> [ <span class="string">$active_conn</span> <span class="string">-eq</span> <span class="number">0</span> ]<span class="string">;</span> <span class="string">then</span></span><br><span class="line">                    <span class="string">echo</span> <span class="string">&quot;All connections closed&quot;</span></span><br><span class="line">                    <span class="string">break</span></span><br><span class="line">                  <span class="string">fi</span></span><br><span class="line">                  <span class="string">echo</span> <span class="string">&quot;Active connections: $active_conn, waiting...&quot;</span></span><br><span class="line">                  <span class="string">sleep</span> <span class="number">1</span></span><br><span class="line">                  <span class="string">timeout=$((timeout-1))</span></span><br><span class="line">                <span class="string">done</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 3. 刷新缓存到持久存储</span></span><br><span class="line">                <span class="string">if</span> [ <span class="string">-f</span> <span class="string">/app/flush_cache.sh</span> ]<span class="string">;</span> <span class="string">then</span></span><br><span class="line">                  <span class="string">echo</span> <span class="string">&quot;Flushing cache...&quot;</span></span><br><span class="line">                  <span class="string">/app/flush_cache.sh</span></span><br><span class="line">                <span class="string">fi</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 4. 通知监控系统</span></span><br><span class="line">                <span class="string">curl</span> <span class="string">-X</span> <span class="string">POST</span> <span class="string">http://monitoring-service/api/v1/shutdown</span> <span class="string">\</span></span><br><span class="line">                  <span class="string">-H</span> <span class="string">&quot;Content-Type: application/json&quot;</span> <span class="string">\</span></span><br><span class="line">                  <span class="string">-d</span> <span class="string">&quot;&#123;\&quot;pod\&quot;:\&quot;$HOSTNAME\&quot;,\&quot;timestamp\&quot;:\&quot;$(date -Iseconds)\&quot;&#125;&quot;</span></span><br><span class="line">                </span><br><span class="line">                <span class="string">echo</span> <span class="string">&quot;Graceful shutdown completed&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 健康检查配置</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/health</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">        </span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/ready</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="最佳实践与注意事项"><a href="#最佳实践与注意事项" class="headerlink" title="最佳实践与注意事项"></a>最佳实践与注意事项</h2><h3 id="✅-Admission-Webhook-最佳实践"><a href="#✅-Admission-Webhook-最佳实践" class="headerlink" title="✅ Admission Webhook 最佳实践"></a>✅ Admission Webhook 最佳实践</h3><h4 id="1-性能优化"><a href="#1-性能优化" class="headerlink" title="1. 性能优化"></a>1. 性能优化</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Webhook 配置优化</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ValidatingAdmissionWebhook</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">optimized-validator</span></span><br><span class="line"><span class="attr">webhooks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">validate.example.com</span></span><br><span class="line">  <span class="attr">clientConfig:</span></span><br><span class="line">    <span class="attr">service:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">webhook-service</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">webhook-system</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">&quot;/validate&quot;</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">operations:</span> [<span class="string">&quot;CREATE&quot;</span>]</span><br><span class="line">    <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">apiVersions:</span> [<span class="string">&quot;v1&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="comment"># 性能优化配置</span></span><br><span class="line">  <span class="attr">timeoutSeconds:</span> <span class="number">10</span>          <span class="comment"># 设置适当超时</span></span><br><span class="line">  <span class="attr">failurePolicy:</span> <span class="string">Fail</span>         <span class="comment"># 明确失败策略</span></span><br><span class="line">  <span class="attr">sideEffects:</span> <span class="string">None</span>          <span class="comment"># 声明无副作用</span></span><br><span class="line">  <span class="attr">reinvocationPolicy:</span> <span class="string">Never</span>   <span class="comment"># 避免重复调用</span></span><br></pre></td></tr></table></figure>

<h4 id="2-错误处理"><a href="#2-错误处理" class="headerlink" title="2. 错误处理"></a>2. 错误处理</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Webhook)</span></span> validate(ar *admissionv1.AdmissionReview) *admissionv1.AdmissionResponse &#123;</span><br><span class="line">    <span class="comment">// 实现超时控制</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现重试机制</span></span><br><span class="line">    <span class="keyword">var</span> lastErr <span class="type">error</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> result, err := w.doValidation(ctx, ar); err == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lastErr = err</span><br><span class="line">            time.Sleep(time.Duration(i+<span class="number">1</span>) * time.Millisecond * <span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据策略处理失败</span></span><br><span class="line">    <span class="keyword">if</span> w.config.FailurePolicy == <span class="string">&quot;Ignore&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;admissionv1.AdmissionResponse&#123;</span><br><span class="line">            Allowed: <span class="literal">true</span>,</span><br><span class="line">            Warnings: []<span class="type">string</span>&#123;fmt.Sprintf(<span class="string">&quot;Validation failed but ignored: %v&quot;</span>, lastErr)&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;admissionv1.AdmissionResponse&#123;</span><br><span class="line">        Allowed: <span class="literal">false</span>,</span><br><span class="line">        Result: &amp;metav1.Status&#123;</span><br><span class="line">            Code:    http.StatusInternalServerError,</span><br><span class="line">            Message: lastErr.Error(),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-安全考虑"><a href="#3-安全考虑" class="headerlink" title="3. 安全考虑"></a>3. 安全考虑</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TLS 配置</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">webhook-certs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">webhook-system</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/tls</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">tls.crt:</span> <span class="comment"># Base64 encoded certificate</span></span><br><span class="line">  <span class="attr">tls.key:</span> <span class="comment"># Base64 encoded private key</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># RBAC 配置</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">webhook-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>, <span class="string">&quot;configmaps&quot;</span>, <span class="string">&quot;secrets&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;apps&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;deployments&quot;</span>, <span class="string">&quot;replicasets&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">webhook-reader-binding</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">webhook-reader</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">webhook-service-account</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">webhook-system</span></span><br></pre></td></tr></table></figure>

<h3 id="⚠️-PreStop-Hook-注意事项"><a href="#⚠️-PreStop-Hook-注意事项" class="headerlink" title="⚠️ PreStop Hook 注意事项"></a>⚠️ PreStop Hook 注意事项</h3><h4 id="1-时间限制管理"><a href="#1-时间限制管理" class="headerlink" title="1. 时间限制管理"></a>1. 时间限制管理</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">60</span>  <span class="comment"># 根据应用需要调整</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">            # 预留时间给 SIGTERM 处理</span></span><br><span class="line"><span class="string">            available_time=50  # 比 terminationGracePeriodSeconds 少 10 秒</span></span><br><span class="line"><span class="string"></span>            </span><br><span class="line">            <span class="comment"># 分阶段处理</span></span><br><span class="line">            <span class="comment"># 阶段1: 停止接受新请求 (5秒)</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;Phase 1: Stopping new requests...&quot;</span></span><br><span class="line">            <span class="string">/app/stop_accepting_requests.sh</span></span><br><span class="line">            <span class="string">sleep</span> <span class="number">5</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 阶段2: 等待现有请求完成 (35秒)</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;Phase 2: Waiting for existing requests...&quot;</span></span><br><span class="line">            <span class="string">timeout</span> <span class="number">35</span> <span class="string">/app/wait_for_requests.sh</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 阶段3: 清理资源 (10秒)</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;Phase 3: Cleanup...&quot;</span></span><br><span class="line">            <span class="string">timeout</span> <span class="number">10</span> <span class="string">/app/cleanup.sh</span></span><br><span class="line">            </span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;PreStop hook completed&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-幂等性保证"><a href="#2-幂等性保证" class="headerlink" title="2. 幂等性保证"></a>2. 幂等性保证</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># graceful_shutdown.sh - 幂等的关闭脚本</span></span><br><span class="line"></span><br><span class="line">SHUTDOWN_FLAG=<span class="string">&quot;/tmp/shutdown_initiated&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否已经开始关闭流程</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$SHUTDOWN_FLAG</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Shutdown already in progress, skipping...&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建关闭标记</span></span><br><span class="line"><span class="built_in">touch</span> <span class="string">&quot;<span class="variable">$SHUTDOWN_FLAG</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting graceful shutdown process...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭逻辑</span></span><br><span class="line"><span class="function"><span class="title">cleanup</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Performing cleanup...&quot;</span></span><br><span class="line">    <span class="comment"># 清理临时文件</span></span><br><span class="line">    <span class="built_in">rm</span> -f /tmp/app_*.tmp</span><br><span class="line">    <span class="comment"># 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">exec</span> 3&gt;&amp;-</span><br><span class="line">    <span class="comment"># 移除关闭标记</span></span><br><span class="line">    <span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$SHUTDOWN_FLAG</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置信号处理</span></span><br><span class="line"><span class="built_in">trap</span> cleanup EXIT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行关闭步骤</span></span><br><span class="line">/app/shutdown_steps.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Graceful shutdown completed&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="🚨-常见问题与解决方案"><a href="#🚨-常见问题与解决方案" class="headerlink" title="🚨 常见问题与解决方案"></a>🚨 常见问题与解决方案</h3><h4 id="1-Webhook-超时问题"><a href="#1-Webhook-超时问题" class="headerlink" title="1. Webhook 超时问题"></a>1. Webhook 超时问题</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 问题：Webhook 响应时间过长导致 Pod 创建失败</span></span><br><span class="line"><span class="comment"># 解决方案：</span></span><br><span class="line"><span class="attr">webhooks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">fast-validator</span></span><br><span class="line">  <span class="attr">timeoutSeconds:</span> <span class="number">5</span>          <span class="comment"># 设置合理超时</span></span><br><span class="line">  <span class="attr">failurePolicy:</span> <span class="string">Ignore</span>      <span class="comment"># 超时时允许通过</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 在 Webhook 代码中实现快速路径</span></span><br><span class="line">  <span class="string">func</span> <span class="string">quickValidation(pod</span> <span class="string">*corev1.Pod)</span> <span class="string">bool</span> &#123;</span><br><span class="line">      <span class="string">//</span> <span class="string">只检查关键项，跳过耗时验证</span></span><br><span class="line">      <span class="string">return</span> <span class="string">pod.Spec.SecurityContext</span> <span class="type">!=</span> <span class="string">nil</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-PreStop-Hook-执行失败"><a href="#2-PreStop-Hook-执行失败" class="headerlink" title="2. PreStop Hook 执行失败"></a>2. PreStop Hook 执行失败</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 问题：PreStop hook 脚本执行失败或超时</span></span><br><span class="line"><span class="comment"># 解决方案：</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">90</span>  <span class="comment"># 增加优雅关闭时间</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">            set -e  # 遇到错误立即退出</span></span><br><span class="line"><span class="string"></span>            </span><br><span class="line">            <span class="comment"># 添加详细日志</span></span><br><span class="line">            <span class="string">exec</span> <span class="string">&gt;</span> <span class="string">/var/log/prestop.log</span> <span class="number">2</span><span class="string">&gt;&amp;1</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;$(date): Starting PreStop hook&quot;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 使用 timeout 命令防止卡死</span></span><br><span class="line">            <span class="string">timeout</span> <span class="number">30</span> <span class="string">/app/graceful_shutdown.sh</span> <span class="string">||</span> &#123;</span><br><span class="line">                <span class="string">echo</span> <span class="string">&quot;$(date): Graceful shutdown timeout, forcing cleanup&quot;</span></span><br><span class="line">                <span class="string">/app/force_cleanup.sh</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;$(date): PreStop hook completed&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-循环依赖问题"><a href="#3-循环依赖问题" class="headerlink" title="3. 循环依赖问题"></a>3. 循环依赖问题</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 问题：Webhook 本身的 Pod 也被 Webhook 拦截</span></span><br><span class="line"><span class="comment"># 解决方案：使用 namespaceSelector 排除</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">admissionregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ValidatingAdmissionWebhook</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app-validator</span></span><br><span class="line"><span class="attr">webhooks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">validate-app-pods</span></span><br><span class="line">  <span class="attr">namespaceSelector:</span></span><br><span class="line">    <span class="attr">matchExpressions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">NotIn</span></span><br><span class="line">      <span class="attr">values:</span> [<span class="string">&quot;webhook-system&quot;</span>, <span class="string">&quot;kube-system&quot;</span>]  <span class="comment"># 排除系统命名空间</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">operations:</span> [<span class="string">&quot;CREATE&quot;</span>, <span class="string">&quot;UPDATE&quot;</span>]</span><br><span class="line">    <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">apiVersions:</span> [<span class="string">&quot;v1&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="4-资源竞争问题"><a href="#4-资源竞争问题" class="headerlink" title="4. 资源竞争问题"></a>4. 资源竞争问题</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题：多个 Webhook 同时修改同一个 Pod</span></span><br><span class="line"><span class="comment">// 解决方案：使用版本控制和条件检查</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutatingWebhook)</span></span> mutate(ar *admissionv1.AdmissionReview) *admissionv1.AdmissionResponse &#123;</span><br><span class="line">    <span class="keyword">var</span> pod corev1.Pod</span><br><span class="line">    json.Unmarshal(ar.Request.Object.Raw, &amp;pod)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否已经被其他 Webhook 处理过</span></span><br><span class="line">    <span class="keyword">if</span> pod.Annotations[<span class="string">&quot;webhook.example.com/processed&quot;</span>] == <span class="string">&quot;true&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;admissionv1.AdmissionResponse&#123;Allowed: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> patches []<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加处理标记</span></span><br><span class="line">    <span class="keyword">if</span> pod.Annotations == <span class="literal">nil</span> &#123;</span><br><span class="line">        patches = <span class="built_in">append</span>(patches, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;op&quot;</span>:    <span class="string">&quot;add&quot;</span>,</span><br><span class="line">            <span class="string">&quot;path&quot;</span>:  <span class="string">&quot;/metadata/annotations&quot;</span>,</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    patches = <span class="built_in">append</span>(patches, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">&quot;op&quot;</span>:    <span class="string">&quot;add&quot;</span>,</span><br><span class="line">        <span class="string">&quot;path&quot;</span>:  <span class="string">&quot;/metadata/annotations/webhook.example.com~1processed&quot;</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行实际的变更</span></span><br><span class="line">    patches = <span class="built_in">append</span>(patches, m.addSidecar(&amp;pod)...)</span><br><span class="line">    </span><br><span class="line">    patchBytes, _ := json.Marshal(patches)</span><br><span class="line">    <span class="keyword">return</span> &amp;admissionv1.AdmissionResponse&#123;</span><br><span class="line">        Allowed: <span class="literal">true</span>,</span><br><span class="line">        Patch:   patchBytes,</span><br><span class="line">        PatchType: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> *admissionv1.PatchType &#123;</span><br><span class="line">            pt := admissionv1.PatchTypeJSONPatch</span><br><span class="line">            <span class="keyword">return</span> &amp;pt</span><br><span class="line">        &#125;(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="高级场景与扩展"><a href="#高级场景与扩展" class="headerlink" title="高级场景与扩展"></a>高级场景与扩展</h2><h3 id="🎯-动态策略管理"><a href="#🎯-动态策略管理" class="headerlink" title="🎯 动态策略管理"></a>🎯 动态策略管理</h3><h4 id="基于-ConfigMap-的策略配置"><a href="#基于-ConfigMap-的策略配置" class="headerlink" title="基于 ConfigMap 的策略配置"></a>基于 ConfigMap 的策略配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">webhook-policies</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">webhook-system</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">security-policy.yaml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    rules:</span></span><br><span class="line"><span class="string">      - name: &quot;no-privileged-containers&quot;</span></span><br><span class="line"><span class="string">        enabled: true</span></span><br><span class="line"><span class="string">        severity: &quot;error&quot;</span></span><br><span class="line"><span class="string">        check: &quot;privileged_container&quot;</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">      - name: &quot;resource-limits-required&quot;</span></span><br><span class="line"><span class="string">        enabled: true</span></span><br><span class="line"><span class="string">        severity: &quot;warning&quot;</span></span><br><span class="line"><span class="string">        check: &quot;resource_limits&quot;</span></span><br><span class="line"><span class="string">        config:</span></span><br><span class="line"><span class="string">          max_cpu: &quot;2&quot;</span></span><br><span class="line"><span class="string">          max_memory: &quot;4Gi&quot;</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">      - name: &quot;trusted-registries-only&quot;</span></span><br><span class="line"><span class="string">        enabled: true</span></span><br><span class="line"><span class="string">        severity: &quot;error&quot;</span></span><br><span class="line"><span class="string">        check: &quot;image_registry&quot;</span></span><br><span class="line"><span class="string">        config:</span></span><br><span class="line"><span class="string">          allowed_registries:</span></span><br><span class="line"><span class="string">            - &quot;registry.company.com&quot;</span></span><br><span class="line"><span class="string">            - &quot;gcr.io/company-project&quot;</span></span><br><span class="line"><span class="string"></span>  </span><br><span class="line">  <span class="attr">injection-policy.yaml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    sidecars:</span></span><br><span class="line"><span class="string">      - name: &quot;logging-sidecar&quot;</span></span><br><span class="line"><span class="string">        enabled: true</span></span><br><span class="line"><span class="string">        trigger:</span></span><br><span class="line"><span class="string">          annotation: &quot;logging.company.com/enabled&quot;</span></span><br><span class="line"><span class="string">          value: &quot;true&quot;</span></span><br><span class="line"><span class="string">        container:</span></span><br><span class="line"><span class="string">          image: &quot;fluent/fluent-bit:1.8&quot;</span></span><br><span class="line"><span class="string">          resources:</span></span><br><span class="line"><span class="string">            requests:</span></span><br><span class="line"><span class="string">              cpu: &quot;50m&quot;</span></span><br><span class="line"><span class="string">              memory: &quot;64Mi&quot;</span></span><br><span class="line"><span class="string">            limits:</span></span><br><span class="line"><span class="string">              cpu: &quot;100m&quot;</span></span><br><span class="line"><span class="string">              memory: &quot;128Mi&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="动态策略加载器"><a href="#动态策略加载器" class="headerlink" title="动态策略加载器"></a>动态策略加载器</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;k8s.io/client-go/kubernetes&quot;</span></span><br><span class="line">    <span class="string">&quot;gopkg.in/yaml.v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PolicyManager <span class="keyword">struct</span> &#123;</span><br><span class="line">    client       kubernetes.Interface</span><br><span class="line">    policies     *PolicyConfig</span><br><span class="line">    lastUpdate   time.Time</span><br><span class="line">    updateChan   <span class="keyword">chan</span> *PolicyConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PolicyConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">    Rules    []ValidationRule <span class="string">`yaml:&quot;rules&quot;`</span></span><br><span class="line">    Sidecars []SidecarConfig  <span class="string">`yaml:&quot;sidecars&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PolicyManager)</span></span> WatchPolicies(ctx context.Context) &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">10</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            <span class="keyword">if</span> err := pm.reloadPolicies(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Printf(<span class="string">&quot;Failed to reload policies: %v&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *PolicyManager)</span></span> reloadPolicies() <span class="type">error</span> &#123;</span><br><span class="line">    cm, err := pm.client.CoreV1().ConfigMaps(<span class="string">&quot;webhook-system&quot;</span>).</span><br><span class="line">        Get(context.TODO(), <span class="string">&quot;webhook-policies&quot;</span>, metav1.GetOptions&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查 ConfigMap 是否有更新</span></span><br><span class="line">    <span class="keyword">if</span> cm.ResourceVersion == pm.policies.Version &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> newPolicies PolicyConfig</span><br><span class="line">    <span class="keyword">if</span> securityData, ok := cm.Data[<span class="string">&quot;security-policy.yaml&quot;</span>]; ok &#123;</span><br><span class="line">        <span class="keyword">if</span> err := yaml.Unmarshal([]<span class="type">byte</span>(securityData), &amp;newPolicies); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原子性更新策略</span></span><br><span class="line">    pm.policies = &amp;newPolicies</span><br><span class="line">    pm.lastUpdate = time.Now()</span><br><span class="line">    </span><br><span class="line">    log.Printf(<span class="string">&quot;Policies updated at %v&quot;</span>, pm.lastUpdate)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🔍-审计与监控"><a href="#🔍-审计与监控" class="headerlink" title="🔍 审计与监控"></a>🔍 审计与监控</h3><h4 id="Webhook-执行监控"><a href="#Webhook-执行监控" class="headerlink" title="Webhook 执行监控"></a>Webhook 执行监控</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/prometheus/client_golang/prometheus&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    webhookDuration = prometheus.NewHistogramVec(</span><br><span class="line">        prometheus.HistogramOpts&#123;</span><br><span class="line">            Name: <span class="string">&quot;webhook_admission_duration_seconds&quot;</span>,</span><br><span class="line">            Help: <span class="string">&quot;Time spent processing admission webhook requests&quot;</span>,</span><br><span class="line">            Buckets: prometheus.DefBuckets,</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="type">string</span>&#123;<span class="string">&quot;webhook_name&quot;</span>, <span class="string">&quot;operation&quot;</span>, <span class="string">&quot;resource&quot;</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    webhookRequests = prometheus.NewCounterVec(</span><br><span class="line">        prometheus.CounterOpts&#123;</span><br><span class="line">            Name: <span class="string">&quot;webhook_admission_requests_total&quot;</span>,</span><br><span class="line">            Help: <span class="string">&quot;Total number of admission webhook requests&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="type">string</span>&#123;<span class="string">&quot;webhook_name&quot;</span>, <span class="string">&quot;operation&quot;</span>, <span class="string">&quot;resource&quot;</span>, <span class="string">&quot;result&quot;</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    webhookErrors = prometheus.NewCounterVec(</span><br><span class="line">        prometheus.CounterOpts&#123;</span><br><span class="line">            Name: <span class="string">&quot;webhook_admission_errors_total&quot;</span>, </span><br><span class="line">            Help: <span class="string">&quot;Total number of admission webhook errors&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        []<span class="type">string</span>&#123;<span class="string">&quot;webhook_name&quot;</span>, <span class="string">&quot;error_type&quot;</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    prometheus.MustRegister(webhookDuration, webhookRequests, webhookErrors)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *AdmissionWebhook)</span></span> ServeHTTP(writer http.ResponseWriter, request *http.Request) &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析请求</span></span><br><span class="line">    ar, err := w.parseAdmissionRequest(request)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        webhookErrors.WithLabelValues(w.name, <span class="string">&quot;parse_error&quot;</span>).Inc()</span><br><span class="line">        http.Error(writer, err.Error(), http.StatusBadRequest)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理请求</span></span><br><span class="line">    response := w.processAdmissionRequest(ar)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录指标</span></span><br><span class="line">    duration := time.Since(start).Seconds()</span><br><span class="line">    labels := []<span class="type">string</span>&#123;</span><br><span class="line">        w.name,</span><br><span class="line">        <span class="type">string</span>(ar.Request.Operation),</span><br><span class="line">        ar.Request.Kind.Kind,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> response.Allowed &#123;</span><br><span class="line">        webhookRequests.WithLabelValues(<span class="built_in">append</span>(labels, <span class="string">&quot;allowed&quot;</span>)...).Inc()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        webhookRequests.WithLabelValues(<span class="built_in">append</span>(labels, <span class="string">&quot;denied&quot;</span>)...).Inc()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    webhookDuration.WithLabelValues(labels...).Observe(duration)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送响应</span></span><br><span class="line">    w.sendAdmissionResponse(writer, response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="审计日志结构化"><a href="#审计日志结构化" class="headerlink" title="审计日志结构化"></a>审计日志结构化</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AuditEvent <span class="keyword">struct</span> &#123;</span><br><span class="line">    Timestamp     time.Time                 <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">    WebhookName   <span class="type">string</span>                   <span class="string">`json:&quot;webhook_name&quot;`</span></span><br><span class="line">    Operation     <span class="type">string</span>                   <span class="string">`json:&quot;operation&quot;`</span></span><br><span class="line">    Resource      <span class="type">string</span>                   <span class="string">`json:&quot;resource&quot;`</span></span><br><span class="line">    Namespace     <span class="type">string</span>                   <span class="string">`json:&quot;namespace&quot;`</span></span><br><span class="line">    ObjectName    <span class="type">string</span>                   <span class="string">`json:&quot;object_name&quot;`</span></span><br><span class="line">    UserInfo      *authenticationv1.UserInfo <span class="string">`json:&quot;user_info&quot;`</span></span><br><span class="line">    Decision      <span class="type">string</span>                   <span class="string">`json:&quot;decision&quot;`</span></span><br><span class="line">    Reason        <span class="type">string</span>                   <span class="string">`json:&quot;reason,omitempty&quot;`</span></span><br><span class="line">    Modifications []<span class="type">string</span>                 <span class="string">`json:&quot;modifications,omitempty&quot;`</span></span><br><span class="line">    Duration      time.Duration            <span class="string">`json:&quot;duration&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *AdmissionWebhook)</span></span> auditLog(ar *admissionv1.AdmissionReview, response *admissionv1.AdmissionResponse, duration time.Duration) &#123;</span><br><span class="line">    event := AuditEvent&#123;</span><br><span class="line">        Timestamp:   time.Now(),</span><br><span class="line">        WebhookName: w.name,</span><br><span class="line">        Operation:   <span class="type">string</span>(ar.Request.Operation),</span><br><span class="line">        Resource:    ar.Request.Kind.Kind,</span><br><span class="line">        Namespace:   ar.Request.Namespace,</span><br><span class="line">        ObjectName:  ar.Request.Name,</span><br><span class="line">        UserInfo:    &amp;ar.Request.UserInfo,</span><br><span class="line">        Duration:    duration,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> response.Allowed &#123;</span><br><span class="line">        event.Decision = <span class="string">&quot;ALLOW&quot;</span></span><br><span class="line">        <span class="keyword">if</span> response.Patch != <span class="literal">nil</span> &#123;</span><br><span class="line">            event.Modifications = w.extractModifications(response.Patch)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event.Decision = <span class="string">&quot;DENY&quot;</span></span><br><span class="line">        <span class="keyword">if</span> response.Result != <span class="literal">nil</span> &#123;</span><br><span class="line">            event.Reason = response.Result.Message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送到审计系统</span></span><br><span class="line">    w.auditLogger.Log(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🛠️-测试与调试"><a href="#🛠️-测试与调试" class="headerlink" title="🛠️ 测试与调试"></a>🛠️ 测试与调试</h3><h4 id="Webhook-单元测试"><a href="#Webhook-单元测试" class="headerlink" title="Webhook 单元测试"></a>Webhook 单元测试</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">    </span><br><span class="line">    admissionv1 <span class="string">&quot;k8s.io/api/admission/v1&quot;</span></span><br><span class="line">    corev1 <span class="string">&quot;k8s.io/api/core/v1&quot;</span></span><br><span class="line">    metav1 <span class="string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span></span><br><span class="line">    <span class="string">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSecurityValidator_ValidatePod</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        name     <span class="type">string</span></span><br><span class="line">        pod      *corev1.Pod</span><br><span class="line">        wantErr  <span class="type">bool</span></span><br><span class="line">        wantMsgs []<span class="type">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&quot;valid pod&quot;</span>,</span><br><span class="line">            pod: &amp;corev1.Pod&#123;</span><br><span class="line">                Spec: corev1.PodSpec&#123;</span><br><span class="line">                    Containers: []corev1.Container&#123;</span><br><span class="line">                        &#123;</span><br><span class="line">                            Name:  <span class="string">&quot;app&quot;</span>,</span><br><span class="line">                            Image: <span class="string">&quot;registry.company.com/app:v1.0&quot;</span>,</span><br><span class="line">                            SecurityContext: &amp;corev1.SecurityContext&#123;</span><br><span class="line">                                RunAsNonRoot: &amp;[]<span class="type">bool</span>&#123;<span class="literal">true</span>&#125;[<span class="number">0</span>],</span><br><span class="line">                            &#125;,</span><br><span class="line">                            Resources: corev1.ResourceRequirements&#123;</span><br><span class="line">                                Limits: corev1.ResourceList&#123;</span><br><span class="line">                                    corev1.ResourceCPU: resource.MustParse(<span class="string">&quot;1&quot;</span>),</span><br><span class="line">                                &#125;,</span><br><span class="line">                            &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            wantErr: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&quot;privileged container&quot;</span>,</span><br><span class="line">            pod: &amp;corev1.Pod&#123;</span><br><span class="line">                Spec: corev1.PodSpec&#123;</span><br><span class="line">                    Containers: []corev1.Container&#123;</span><br><span class="line">                        &#123;</span><br><span class="line">                            Name:  <span class="string">&quot;app&quot;</span>,</span><br><span class="line">                            Image: <span class="string">&quot;registry.company.com/app:v1.0&quot;</span>,</span><br><span class="line">                            SecurityContext: &amp;corev1.SecurityContext&#123;</span><br><span class="line">                                Privileged: &amp;[]<span class="type">bool</span>&#123;<span class="literal">true</span>&#125;[<span class="number">0</span>],</span><br><span class="line">                            &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            wantErr:  <span class="literal">true</span>,</span><br><span class="line">            wantMsgs: []<span class="type">string</span>&#123;<span class="string">&quot;Privileged container not allowed: app&quot;</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    validator := &amp;SecurityValidator&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">        t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            violations := validator.ValidatePod(tt.pod)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> tt.wantErr &amp;&amp; <span class="built_in">len</span>(violations) == <span class="number">0</span> &#123;</span><br><span class="line">                t.Error(<span class="string">&quot;Expected violations but got none&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> !tt.wantErr &amp;&amp; <span class="built_in">len</span>(violations) &gt; <span class="number">0</span> &#123;</span><br><span class="line">                t.Errorf(<span class="string">&quot;Unexpected violations: %v&quot;</span>, violations)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> _, expectedMsg := <span class="keyword">range</span> tt.wantMsgs &#123;</span><br><span class="line">                found := <span class="literal">false</span></span><br><span class="line">                <span class="keyword">for</span> _, violation := <span class="keyword">range</span> violations &#123;</span><br><span class="line">                    <span class="keyword">if</span> violation == expectedMsg &#123;</span><br><span class="line">                        found = <span class="literal">true</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> !found &#123;</span><br><span class="line">                    t.Errorf(<span class="string">&quot;Expected violation message %q not found&quot;</span>, expectedMsg)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdmissionWebhook_Integration</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建测试用的 admission request</span></span><br><span class="line">    pod := &amp;corev1.Pod&#123;</span><br><span class="line">        ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">            Name:      <span class="string">&quot;test-pod&quot;</span>,</span><br><span class="line">            Namespace: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        Spec: corev1.PodSpec&#123;</span><br><span class="line">            Containers: []corev1.Container&#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    Name:  <span class="string">&quot;app&quot;</span>,</span><br><span class="line">                    Image: <span class="string">&quot;nginx:latest&quot;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    podBytes, _ := json.Marshal(pod)</span><br><span class="line">    ar := &amp;admissionv1.AdmissionReview&#123;</span><br><span class="line">        Request: &amp;admissionv1.AdmissionRequest&#123;</span><br><span class="line">            UID:       <span class="string">&quot;test-uid&quot;</span>,</span><br><span class="line">            Operation: admissionv1.Create,</span><br><span class="line">            Object: runtime.RawExtension&#123;</span><br><span class="line">                Raw: podBytes,</span><br><span class="line">            &#125;,</span><br><span class="line">            Kind: metav1.GroupVersionKind&#123;</span><br><span class="line">                Kind: <span class="string">&quot;Pod&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    webhook := NewSecurityValidator()</span><br><span class="line">    response := webhook.validate(ar)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> !response.Allowed &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Expected pod to be allowed, but was denied: %v&quot;</span>, response.Result.Message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调试工具脚本"><a href="#调试工具脚本" class="headerlink" title="调试工具脚本"></a>调试工具脚本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># webhook_debug.sh - Webhook 调试工具</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">WEBHOOK_NAME=<span class="variable">$&#123;1:-&quot;security-validator&quot;&#125;</span></span><br><span class="line">NAMESPACE=<span class="variable">$&#123;2:-&quot;webhook-system&quot;&#125;</span></span><br><span class="line">TEST_POD=<span class="variable">$&#123;3:-&quot;test-pod.yaml&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=== Webhook 调试工具 ===&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Webhook: <span class="variable">$WEBHOOK_NAME</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Namespace: <span class="variable">$NAMESPACE</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Test Pod: <span class="variable">$TEST_POD</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 检查 Webhook 配置</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1. 检查 Webhook 配置:&quot;</span></span><br><span class="line">kubectl get validatingadmissionwebhooks.admissionregistration.k8s.io <span class="variable">$WEBHOOK_NAME</span> -o yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 检查 Webhook 服务状态</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2. 检查 Webhook 服务:&quot;</span></span><br><span class="line">kubectl get pods -n <span class="variable">$NAMESPACE</span> -l app=<span class="variable">$WEBHOOK_NAME</span></span><br><span class="line">kubectl get svc -n <span class="variable">$NAMESPACE</span> -l app=<span class="variable">$WEBHOOK_NAME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 检查证书有效性</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;3. 检查 TLS 证书:&quot;</span></span><br><span class="line">kubectl get secret -n <span class="variable">$NAMESPACE</span> webhook-certs -o jsonpath=<span class="string">&#x27;&#123;.data.tls\.crt&#125;&#x27;</span> | \</span><br><span class="line">    <span class="built_in">base64</span> -d | openssl x509 -text -noout | grep -A2 <span class="string">&quot;Validity&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 测试 Webhook 连通性</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;4. 测试 Webhook 连通性:&quot;</span></span><br><span class="line">WEBHOOK_SVC=$(kubectl get svc -n <span class="variable">$NAMESPACE</span> -l app=<span class="variable">$WEBHOOK_NAME</span> -o jsonpath=<span class="string">&#x27;&#123;.items[0].metadata.name&#125;&#x27;</span>)</span><br><span class="line">kubectl run webhook-test --image=curlimages/curl --<span class="built_in">rm</span> -it --restart=Never -- \</span><br><span class="line">    curl -k https://<span class="variable">$WEBHOOK_SVC</span>.<span class="variable">$NAMESPACE</span>.svc.cluster.local/validate -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 干运行测试 Pod</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;5. 干运行测试 Pod:&quot;</span></span><br><span class="line">kubectl apply -f <span class="variable">$TEST_POD</span> --dry-run=server -v=8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 查看 Webhook 日志</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;6. Webhook 日志 (最近 50 行):&quot;</span></span><br><span class="line">kubectl logs -n <span class="variable">$NAMESPACE</span> -l app=<span class="variable">$WEBHOOK_NAME</span> --<span class="built_in">tail</span>=50</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 查看 API Server 审计日志 (如果可用)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;7. API Server 相关日志:&quot;</span></span><br><span class="line">kubectl logs -n kube-system -l component=kube-apiserver --<span class="built_in">tail</span>=20 | grep -i admission</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=== 调试完成 ===&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结与建议"><a href="#总结与建议" class="headerlink" title="总结与建议"></a>总结与建议</h2><h3 id="🎯-关键要点总结"><a href="#🎯-关键要点总结" class="headerlink" title="🎯 关键要点总结"></a>🎯 关键要点总结</h3><h4 id="1-Webhook-管控的黄金时间窗口"><a href="#1-Webhook-管控的黄金时间窗口" class="headerlink" title="1. Webhook 管控的黄金时间窗口"></a>1. <strong>Webhook 管控的黄金时间窗口</strong></h4><ul>
<li><strong>Pod 创建前</strong>：最强管控能力，可以完全拒绝或修改 Pod</li>
<li><strong>Pod 终止前</strong>：有限管控能力，只能执行清理和通知操作</li>
<li><strong>运行期间</strong>：无法通过 Webhook 管控，需要其他机制</li>
</ul>
<h4 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. <strong>设计原则</strong></h4><ul>
<li><strong>快速响应</strong>：Webhook 应该在毫秒级完成处理</li>
<li><strong>幂等性</strong>：同样的输入总是产生同样的输出</li>
<li><strong>容错性</strong>：合理设置 failurePolicy 和超时时间</li>
<li><strong>可观测性</strong>：提供详细的日志和指标</li>
</ul>
<h4 id="3-常见陷阱"><a href="#3-常见陷阱" class="headerlink" title="3. 常见陷阱"></a>3. <strong>常见陷阱</strong></h4><ul>
<li>避免 Webhook 处理自身 Pod (使用 namespaceSelector)</li>
<li>防止无限递归调用 (使用 reinvocationPolicy)</li>
<li>注意时间限制 (PreStop Hook 有 terminationGracePeriodSeconds 限制)</li>
<li>处理网络分区和超时情况</li>
</ul>
<h3 id="🚀-进阶建议"><a href="#🚀-进阶建议" class="headerlink" title="🚀 进阶建议"></a>🚀 进阶建议</h3><h4 id="1-多层防护策略"><a href="#1-多层防护策略" class="headerlink" title="1. 多层防护策略"></a>1. <strong>多层防护策略</strong></h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 组合使用多种 Webhook 实现深度防护</span></span><br><span class="line"><span class="comment"># Layer 1: Mutating Webhook (注入安全配置)</span></span><br><span class="line"><span class="comment"># Layer 2: Validating Webhook (验证安全策略)  </span></span><br><span class="line"><span class="comment"># Layer 3: OPA Gatekeeper (策略即代码)</span></span><br><span class="line"><span class="comment"># Layer 4: Pod Security Standards (运行时安全)</span></span><br></pre></td></tr></table></figure>

<h4 id="2-渐进式部署"><a href="#2-渐进式部署" class="headerlink" title="2. 渐进式部署"></a>2. <strong>渐进式部署</strong></h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从宽松到严格的策略演进</span></span><br><span class="line"><span class="attr">Phase 1: failurePolicy:</span> <span class="string">Ignore</span>  <span class="comment"># 观察模式，记录但不阻止</span></span><br><span class="line"><span class="attr">Phase 2:</span> <span class="string">只针对特定命名空间启用</span></span><br><span class="line"><span class="attr">Phase 3: failurePolicy:</span> <span class="string">Fail</span>    <span class="comment"># 强制执行</span></span><br><span class="line"><span class="attr">Phase 4:</span> <span class="string">扩展到所有命名空间</span></span><br></pre></td></tr></table></figure>

<h4 id="3-监控告警体系"><a href="#3-监控告警体系" class="headerlink" title="3. 监控告警体系"></a>3. <strong>监控告警体系</strong></h4><ul>
<li>Webhook 响应时间监控</li>
<li>拒绝率和通过率统计</li>
<li>错误类型分类统计</li>
<li>资源使用情况监控</li>
</ul>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>zap日志级别</title>
    <url>/2025/08/05/zap%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h2 id="zap调试"><a href="#zap调试" class="headerlink" title="zap调试"></a>zap调试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;flag&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">	ctrl &quot;sigs.k8s.io/controller-runtime&quot;</span><br><span class="line">	&quot;sigs.k8s.io/controller-runtime/pkg/log/zap&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var opts zap.Options</span><br><span class="line">	opts.BindFlags(flag.CommandLine)</span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	ctrl.SetLogger(zap.New(zap.UseFlagOptions(&amp;opts)))</span><br><span class="line">	log := ctrl.Log.WithName(&quot;TestLogger&quot;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;Testing different log levels:&quot;)</span><br><span class="line"></span><br><span class="line">	log.Info(&quot;This is Info level&quot;)</span><br><span class="line">	log.V(1).Info(&quot;This is V(1) level&quot;)</span><br><span class="line">	log.V(2).Info(&quot;This is V(2) level&quot;)</span><br><span class="line">	log.V(3).Info(&quot;This is V(3) level&quot;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;Test completed&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go run test-zap-levels.go --zap-log-level=1</span><br><span class="line">go run test-zap-levels.go --zap-log-level=debug</span><br><span class="line">go run test-zap-levels.go --zap-log-level=9</span><br><span class="line"></span><br><span class="line">V(1) → 显示为 debug 级别</span><br><span class="line">V(2) → 显示为 Level(-2) 级别</span><br><span class="line">V(3) → 显示为 Level(-3) 级别</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go并发实践</title>
    <url>/2025/08/09/go%E5%B9%B6%E5%8F%91%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="Worker-Pool模式"><a href="#Worker-Pool模式" class="headerlink" title="Worker Pool模式"></a>Worker Pool模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// worker 是我们的“工人”，负责处理具体的任务</span><br><span class="line">func worker(id int, tasks &lt;-chan int, wg *sync.WaitGroup) &#123;</span><br><span class="line">    defer wg.Done()</span><br><span class="line">    for taskID := range tasks &#123;</span><br><span class="line">        fmt.Printf(&quot;工人 %d 开始处理任务 %d\n&quot;, id, taskID)</span><br><span class="line">        time.Sleep(time.Second) // 模拟耗时</span><br><span class="line">        fmt.Printf(&quot;工人 %d 完成了任务 %d\n&quot;, id, taskID)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    const numTasks = 100    // 总任务数</span><br><span class="line">    const numWorkers = 5    // 工人数量（并发度）</span><br><span class="line"></span><br><span class="line">    tasks := make(chan int, numTasks)</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    // 启动固定数量的工人</span><br><span class="line">    for i := 1; i &lt;= numWorkers; i++ &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go worker(i, tasks, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 分配任务</span><br><span class="line">    for i := 1; i &lt;= numTasks; i++ &#123;</span><br><span class="line">        tasks &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    close(tasks) // 所有任务分配完毕，关闭任务通道</span><br><span class="line"></span><br><span class="line">    // 等待所有工人完成工作</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(&quot;所有任务处理完毕！&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-工作池模式（Worker-Pool-Pattern）"><a href="#1-工作池模式（Worker-Pool-Pattern）" class="headerlink" title="1. 工作池模式（Worker Pool Pattern）"></a>1. 工作池模式（Worker Pool Pattern）</h2><p><strong>分析</strong>：<br>这个文件实现了一个典型的工作池模式，通过固定数量的goroutine处理来自通道的任务。</p>
<p><strong>关键特点</strong>：</p>
<ul>
<li>创建固定数量（5个）的工作goroutine</li>
<li>使用带缓冲的通道分发任务</li>
<li>使用<code>sync.WaitGroup</code>等待所有工作完成</li>
<li>工作者在通道关闭后自动退出</li>
</ul>
<p><strong>图例说明</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                    +------------------+</span><br><span class="line">                    |    任务通道       |</span><br><span class="line">                    |  (tasks channel) |</span><br><span class="line">                    +------------------+</span><br><span class="line">                            |</span><br><span class="line">                            v</span><br><span class="line">+----------+  +----------+  +----------+  +----------+  +----------+</span><br><span class="line">| 工人 1   |  | 工人 2   |  | 工人 3   |  | 工人 4   |  | 工人 5   |</span><br><span class="line">| goroutine|  | goroutine|  | goroutine|  | goroutine|  | goroutine|</span><br><span class="line">+----------+  +----------+  +----------+  +----------+  +----------+</span><br><span class="line">      |             |             |             |             |</span><br><span class="line">      v             v             v             v             v</span><br><span class="line">   处理任务      处理任务      处理任务      处理任务      处理任务</span><br><span class="line"></span><br><span class="line">                            |</span><br><span class="line">                            v</span><br><span class="line">                    +------------------+</span><br><span class="line">                    |   WaitGroup      |</span><br><span class="line">                    | 等待所有工作完成  |</span><br><span class="line">                    +------------------+</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="pipline-模式"><a href="#pipline-模式" class="headerlink" title="pipline 模式"></a>pipline 模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 第一个阶段：生成数字</span><br><span class="line">func generator(nums ...int) &lt;-chan int &#123;</span><br><span class="line">    out := make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for _, n := range nums &#123;</span><br><span class="line">            out &lt;- n</span><br><span class="line">        &#125;</span><br><span class="line">        close(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第二个阶段：计算平方</span><br><span class="line">func square(in &lt;-chan int) &lt;-chan int &#123;</span><br><span class="line">    out := make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for n := range in &#123;</span><br><span class="line">            out &lt;- n * n</span><br><span class="line">        &#125;</span><br><span class="line">        close(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 第三个阶段：加倍</span><br><span class="line">func double(in &lt;-chan int) &lt;-chan int &#123;</span><br><span class="line">    out := make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for n := range in &#123;</span><br><span class="line">            out &lt;- n * 2</span><br><span class="line">        &#125;</span><br><span class="line">        close(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // 构建流水线</span><br><span class="line">    nums := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">    stage1 := generator(nums...)</span><br><span class="line">    stage2 := square(stage1)</span><br><span class="line">    stage3 := double(stage2)</span><br><span class="line"></span><br><span class="line">    // 消费最终结果</span><br><span class="line">    for result := range stage3 &#123;</span><br><span class="line">        fmt.Println(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-流水线模式（Pipeline-Pattern）"><a href="#2-流水线模式（Pipeline-Pattern）" class="headerlink" title="2. 流水线模式（Pipeline Pattern）"></a>2. 流水线模式（Pipeline Pattern）</h2><p><strong>分析</strong>：<br>这个文件实现了一个简单的数据处理流水线，数据通过多个处理阶段依次传递。</p>
<p><strong>关键特点</strong>：</p>
<ul>
<li>每个阶段都在独立的goroutine中运行</li>
<li>通过通道连接各个处理阶段</li>
<li>每个处理函数接收输入通道并返回输出通道</li>
<li>流水线按顺序执行：生成数字 -&gt; 计算平方 -&gt; 加倍</li>
</ul>
<p><strong>图例说明</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------+      +------------+      +------------+</span><br><span class="line">|            |      |            |      |            |</span><br><span class="line">| 生成阶段    | ---&gt; | 平方阶段    | ---&gt; | 加倍阶段    |</span><br><span class="line">| (generator)|      | (square)   |      | (double)   |</span><br><span class="line">|            |      |            |      |            |</span><br><span class="line">+------------+      +------------+      +------------+</span><br><span class="line">    1,2,3,4,5  --&gt;   1,4,9,16,25  --&gt;  2,8,18,32,50</span><br><span class="line"></span><br><span class="line">    goroutine 1      goroutine 2        goroutine 3</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="扇出-扇入模式"><a href="#扇出-扇入模式" class="headerlink" title="扇出&#x2F;扇入模式"></a>扇出&#x2F;扇入模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// generator 和 double 函数与上例相同...</span><br><span class="line">func generator(nums ...int) &lt;-chan int &#123;</span><br><span class="line">    out := make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for _, n := range nums &#123;</span><br><span class="line">            out &lt;- n</span><br><span class="line">        &#125;</span><br><span class="line">        close(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func double(in &lt;-chan int) &lt;-chan int &#123;</span><br><span class="line">    out := make(chan int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for n := range in &#123;</span><br><span class="line">            out &lt;- n * 2</span><br><span class="line">        &#125;</span><br><span class="line">        close(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扇出：启动多个 square worker</span><br><span class="line">func squareFanOut(in &lt;-chan int, numWorkers int) []&lt;-chan int &#123;</span><br><span class="line">    outs := make([]&lt;-chan int, numWorkers)</span><br><span class="line">    for i := 0; i &lt; numWorkers; i++ &#123;</span><br><span class="line">        out := make(chan int)</span><br><span class="line">        go func() &#123;</span><br><span class="line">            for n := range in &#123;</span><br><span class="line">                // 模拟复杂计算</span><br><span class="line">                // time.Sleep(time.Millisecond * 500)</span><br><span class="line">                out &lt;- n * n</span><br><span class="line">            &#125;</span><br><span class="line">            close(out)</span><br><span class="line">        &#125;()</span><br><span class="line">        outs[i] = out</span><br><span class="line">    &#125;</span><br><span class="line">    return outs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 扇入：将多个 channel 的结果合并到一个 channel</span><br><span class="line">func fanIn(ins ...&lt;-chan int) &lt;-chan int &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    out := make(chan int)</span><br><span class="line"></span><br><span class="line">    // 为每个输入 channel 启动一个 goroutine</span><br><span class="line">    for _, in := range ins &#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go func(ch &lt;-chan int) &#123;</span><br><span class="line">            defer wg.Done()</span><br><span class="line">            for n := range ch &#123;</span><br><span class="line">                out &lt;- n</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(in)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 启动一个 goroutine，在所有输入 channel 都关闭后，关闭输出 channel</span><br><span class="line">    go func() &#123;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        close(out)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    nums := []int&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;</span><br><span class="line"></span><br><span class="line">    // 构建流水线</span><br><span class="line">    stage1 := generator(nums...)</span><br><span class="line"></span><br><span class="line">    // 扇出到3个 square worker</span><br><span class="line">    squareChannels := squareFanOut(stage1, 3)</span><br><span class="line"></span><br><span class="line">    // 扇入合并结果</span><br><span class="line">    stage2 := fanIn(squareChannels...)</span><br><span class="line"></span><br><span class="line">    stage3 := double(stage2)</span><br><span class="line"></span><br><span class="line">    // 消费最终结果</span><br><span class="line">    for result := range stage3 &#123;</span><br><span class="line">        fmt.Println(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-扇入扇出模式（Fan-in-Fan-out-Pattern）"><a href="#3-扇入扇出模式（Fan-in-Fan-out-Pattern）" class="headerlink" title="3. 扇入扇出模式（Fan-in Fan-out Pattern）"></a>3. 扇入扇出模式（Fan-in Fan-out Pattern）</h2><p><strong>分析</strong>：<br>这个文件结合了流水线模式，并添加了扇出（将工作分配给多个worker）和扇入（收集多个worker的结果）功能。</p>
<p><strong>关键特点</strong>：</p>
<ul>
<li>扇出：将单个输入通道的数据分配给多个并行工作的goroutine</li>
<li>扇入：将多个通道的输出合并到单个通道</li>
<li>使用<code>sync.WaitGroup</code>确保所有数据处理完毕后关闭输出通道</li>
<li>主流水线：生成数字 -&gt; [多个平方计算并行处理] -&gt; 合并结果 -&gt; 加倍</li>
</ul>
<h2 id="图例说明："><a href="#图例说明：" class="headerlink" title="图例说明："></a><strong>图例说明</strong>：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             +----------------+</span><br><span class="line">             |                |</span><br><span class="line">             |  生成阶段       |</span><br><span class="line">             | (generator)    |</span><br><span class="line">             |                |</span><br><span class="line">             +----------------+</span><br><span class="line">                     |</span><br><span class="line">                     | 扇出 (Fan-out)</span><br><span class="line">                     v</span><br><span class="line">+----------------+  +----------------+  +----------------+</span><br><span class="line">|                |  |                |  |                |</span><br><span class="line">|  平方计算 1     |  |  平方计算 2     |  |  平方计算 3     |</span><br><span class="line">| (square 1)     |  | (square 2)     |  | (square 3)     |</span><br><span class="line">|                |  |                |  |                |</span><br><span class="line">+----------------+  +----------------+  +----------------+</span><br><span class="line">            |                |                |</span><br><span class="line">            |     扇入 (Fan-in)               |</span><br><span class="line">            v                v                v</span><br><span class="line">                   +----------------+</span><br><span class="line">                   |                |</span><br><span class="line">                   |  合并结果       |</span><br><span class="line">                   | (fanIn)        |</span><br><span class="line">                   |                |</span><br><span class="line">                   +----------------+</span><br><span class="line">                            |</span><br><span class="line">                            v</span><br><span class="line">                   +----------------+</span><br><span class="line">                   |                |</span><br><span class="line">                   |  加倍阶段       |</span><br><span class="line">                   | (double)       |</span><br><span class="line">                   |                |</span><br><span class="line">                   +----------------+</span><br></pre></td></tr></table></figure></h2><h2 id="Go并发最佳实践"><a href="#Go并发最佳实践" class="headerlink" title="Go并发最佳实践"></a>Go并发最佳实践</h2><h3 id="1-通道（Channel）使用原则"><a href="#1-通道（Channel）使用原则" class="headerlink" title="1. 通道（Channel）使用原则"></a>1. 通道（Channel）使用原则</h3><ul>
<li><strong>谁创建，谁关闭</strong>：只在生产者端关闭通道，避免向已关闭的通道发送数据</li>
<li><strong>使用带缓冲的通道</strong>：当知道要发送的元素数量时，设置适当的缓冲大小以提高性能</li>
<li><strong>优先使用无缓冲通道</strong>：对于需要严格同步的场景，无缓冲通道提供了更好的保证</li>
<li><strong>使用<code>for range</code>循环</strong>：优雅地从通道接收数据直至通道关闭</li>
<li><strong>使用<code>select</code>处理多通道</strong>：避免在单个goroutine中阻塞</li>
</ul>
<h3 id="2-资源管理和泄漏预防"><a href="#2-资源管理和泄漏预防" class="headerlink" title="2. 资源管理和泄漏预防"></a>2. 资源管理和泄漏预防</h3><ul>
<li><strong>确保goroutine终止</strong>：为长时间运行的goroutine提供退出机制，如done通道</li>
<li><strong>使用<code>context</code>包</strong>：管理goroutine的生命周期和传递截止时间、取消信号</li>
<li><strong>关闭输入通道</strong>：作为通知goroutine停止工作的信号</li>
<li><strong>使用sync.WaitGroup</strong>：等待一组goroutine完成</li>
<li><strong>限制goroutine数量</strong>：使用工作池或信号量控制并发度</li>
</ul>
<h3 id="3-并发安全"><a href="#3-并发安全" class="headerlink" title="3. 并发安全"></a>3. 并发安全</h3><ul>
<li><strong>避免共享内存</strong>：优先通过通道通信而非共享内存</li>
<li><strong>使用互斥锁</strong>：当必须共享内存时，使用<code>sync.Mutex</code>或<code>sync.RWMutex</code>保护</li>
<li><strong>使用原子操作</strong>：对于简单的计数器或标志，使用<code>sync/atomic</code>包</li>
<li><strong>不要复制互斥锁</strong>：互斥锁不应该被复制，应该通过指针传递</li>
<li><strong>避免竞态条件</strong>：使用<code>go build -race</code>或<code>go test -race</code>检测竞态条件</li>
</ul>
<h3 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4. 性能优化"></a>4. 性能优化</h3><ul>
<li><strong>使用并发数量上限</strong>：通常设置为<code>runtime.NumCPU()</code>或略高</li>
<li><strong>避免过度goroutine</strong>：每个goroutine消耗内存，创建过多会导致性能下降</li>
<li><strong>批量处理</strong>：当可能时，批量发送数据而非单个发送</li>
<li><strong>使用适当的通道缓冲</strong>：根据吞吐量和延迟要求调整缓冲大小</li>
<li><strong>注意内存局部性</strong>：分散数据访问可能导致缓存未命中</li>
</ul>
<h3 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5. 错误处理"></a>5. 错误处理</h3><ul>
<li><strong>传播错误</strong>：使用专门的错误通道或包含错误的结果结构体</li>
<li><strong>优雅处理panic</strong>：使用<code>recover()</code>在goroutine中捕获panic</li>
<li><strong>超时处理</strong>：使用<code>context</code>或<code>select</code>与<code>time.After</code>组合处理超时</li>
<li><strong>取消操作</strong>：提供取消机制，允许提前终止长时间运行的操作</li>
</ul>
<h3 id="6-测试和调试"><a href="#6-测试和调试" class="headerlink" title="6. 测试和调试"></a>6. 测试和调试</h3><ul>
<li><strong>使用竞态检测器</strong>：<code>go test -race</code>或<code>go build -race</code></li>
<li><strong>编写并发测试</strong>：确保并发代码在各种竞争条件下正确工作</li>
<li><strong>使用runtime&#x2F;pprof</strong>：分析goroutine的性能和使用情况</li>
<li><strong>限制测试并发度</strong>：测试时可控制并发数量以重现问题</li>
</ul>
<h3 id="7-并发模式"><a href="#7-并发模式" class="headerlink" title="7. 并发模式"></a>7. 并发模式</h3><ul>
<li><strong>工作池模式</strong>：限制并发goroutine数量处理大量任务</li>
<li><strong>流水线模式</strong>：将任务分解为连续的阶段，每个阶段在单独的goroutine中执行</li>
<li><strong>扇入扇出模式</strong>：将工作分配给多个goroutine，然后收集结果</li>
<li><strong>定时器模式</strong>：使用<code>time.Ticker</code>和<code>time.Timer</code>处理定时任务</li>
<li><strong>发布订阅模式</strong>：将消息从发布者分发给多个订阅者</li>
</ul>
]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump分析包命令参考</title>
    <url>/2025/08/11/tcpdump%E5%88%86%E6%9E%90%E5%8C%85%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<h1 id="tcpdump网络抓包与分析速查笔记"><a href="#tcpdump网络抓包与分析速查笔记" class="headerlink" title="tcpdump网络抓包与分析速查笔记"></a>tcpdump网络抓包与分析速查笔记</h1><h2 id="最佳实践：TCP-异常分析流程"><a href="#最佳实践：TCP-异常分析流程" class="headerlink" title="最佳实践：TCP 异常分析流程"></a>最佳实践：TCP 异常分析流程</h2><ol>
<li><strong>先看连接是否建立</strong>（SYN→SYN&#x2F;ACK→ACK）</li>
<li><strong>检查是否有重传</strong>（<code>tcp.analysis.retransmission</code>）</li>
<li><strong>看是否有 RST&#x2F;FIN 提前关闭</strong></li>
<li><strong>分析延迟&#x2F;窗口问题</strong>（<code>tcp.analysis.window_full</code>、<code>tcp.analysis.zero_window</code>）</li>
<li><strong>抓取完整 TCP 流</strong>（用 <code>-z follow,tcp,ascii</code>）</li>
</ol>
<hr>
<h2 id="1-tcpdump-命令速查表"><a href="#1-tcpdump-命令速查表" class="headerlink" title="1. tcpdump 命令速查表"></a>1. tcpdump 命令速查表</h2><table>
<thead>
<tr>
<th>用途说明</th>
<th>示例命令</th>
</tr>
</thead>
<tbody><tr>
<td>抓取指定接口的所有包</td>
<td><code>tcpdump -i eth0  -nn -tttt -vvv -s 0 </code></td>
</tr>
<tr>
<td>抓取指定主机的包</td>
<td><code>tcpdump host 192.168.1.10</code></td>
</tr>
<tr>
<td>抓取指定端口的包</td>
<td><code>tcpdump port 80</code></td>
</tr>
<tr>
<td>抓取 TCP 协议的包</td>
<td><code>tcpdump tcp</code></td>
</tr>
<tr>
<td>抓取并保存到文件</td>
<td><code>tcpdump -i eth0 -w output_$(date +%Y%m%d_%H%M%S).pcap</code></td>
</tr>
<tr>
<td>从文件读取包</td>
<td><code>tcpdump -r output.pcap</code></td>
</tr>
<tr>
<td>抓取并显示 ASCII 内容（例如 JSON）</td>
<td><code>tcpdump -A -s 0 -r output.pcap</code></td>
</tr>
<tr>
<td>抓取并显示 16 进制和 ASCII</td>
<td><code>tcpdump -XX -s 0 -r output.pcap</code></td>
</tr>
<tr>
<td>按条件过滤（主机 + 端口）</td>
<td><code>tcpdump host 10.0.0.1 and port 8080</code></td>
</tr>
<tr>
<td>显示更详细的信息</td>
<td><code>tcpdump -vvv</code></td>
</tr>
</tbody></table>
<ul>
<li>输出格式控制参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>-v</code></td>
<td>详细输出</td>
<td>提供更多包头信息，如TTL，TOS，长度等</td>
</tr>
<tr>
<td><code>-vv</code></td>
<td>更详细输出</td>
<td>提供更多协议细节，如窗口大小，TCP选项等</td>
</tr>
<tr>
<td><code>-vvv</code></td>
<td>最详细输出</td>
<td>提供最大程度的细节，包括包内容的详细解析</td>
</tr>
<tr>
<td><code>-nn</code></td>
<td>不解析主机名和端口名</td>
<td>加快输出速度，避免DNS查询延迟，直接显示IP和数字端口</td>
</tr>
<tr>
<td><code>-t</code></td>
<td>不打印时间戳</td>
<td>简化输出，关注包内容而非时间</td>
</tr>
<tr>
<td><code>-tt</code></td>
<td>打印未格式化的时间戳</td>
<td>用于精确测量包间延迟，精确到微秒</td>
</tr>
<tr>
<td><code>-ttt</code></td>
<td>打印相对前一个包的延迟</td>
<td>分析包间延迟模式，识别网络抖动</td>
</tr>
<tr>
<td><code>-tttt</code></td>
<td>打印带日期的时间戳</td>
<td>长时间捕获时，便于识别包的具体时间点</td>
</tr>
</tbody></table>
<ul>
<li>包大小和内容控制参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>-s 0</code> 或 <code>-s 65535</code></td>
<td>捕获完整包</td>
<td>需要查看包的完整内容，进行深度包检查时</td>
</tr>
<tr>
<td><code>-s 96</code></td>
<td>限制捕获字节数</td>
<td>只关心包头，减少存储空间和处理开销</td>
</tr>
<tr>
<td><code>-X</code></td>
<td>以十六进制和ASCII格式打印包内容</td>
<td>查看包的原始数据，调试应用层协议</td>
</tr>
<tr>
<td><code>-XX</code></td>
<td>同-X，但包括链路层头部</td>
<td>更全面地分析包结构，包括MAC地址等</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump 需要抓取原始网络包，这在 Linux 里默认需要 root 权限或具备特定的 CAP_NET_RAW / CAP_NET_ADMIN 能力</span><br><span class="line">#给 tcpdump 二进制加 CAP_NET_RAW &amp; CAP_NET_ADMIN 能力</span><br><span class="line"># 1. 确认 tcpdump 路径</span><br><span class="line">which tcpdump</span><br><span class="line"># 假设输出是 /usr/sbin/tcpdump</span><br><span class="line"></span><br><span class="line"># 2. 给 tcpdump 添加所需权限（只需执行一次）</span><br><span class="line">sudo setcap cap_net_raw,cap_net_admin=eip /usr/sbin/tcpdump</span><br><span class="line"></span><br><span class="line"># 3. 验证</span><br><span class="line">getcap /usr/sbin/tcpdump</span><br><span class="line"># 应该输出类似：</span><br><span class="line"># /usr/sbin/tcpdump = cap_net_admin,cap_net_raw+eip</span><br><span class="line"></span><br><span class="line">#cap_net_raw 权限可以抓取敏感数据包，存在信息泄露风险。</span><br><span class="line">#生产服务器建议仅给特定用户赋权，并在抓包完成后移除能力：</span><br><span class="line">sudo setcap -r /usr/sbin/tcpdump</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-tshark-命令速查表"><a href="#2-tshark-命令速查表" class="headerlink" title="2. tshark 命令速查表"></a>2. tshark 命令速查表</h2><table>
<thead>
<tr>
<th>用途说明</th>
<th>示例命令</th>
</tr>
</thead>
<tbody><tr>
<td>从文件读取并解析</td>
<td><code>tshark -r file.pcap</code></td>
</tr>
<tr>
<td>按显示过滤器过滤</td>
<td><code>tshark -r file.pcap -Y &quot;http&quot;</code></td>
</tr>
<tr>
<td>查看所有字段名</td>
<td><code>tshark -G fields</code></td>
</tr>
<tr>
<td>显示 HTTP 请求</td>
<td><code>tshark -r file.pcap -Y &quot;http.request&quot;</code></td>
</tr>
<tr>
<td>显示包内容（ASCII）</td>
<td><code>tshark -r file.pcap -x</code></td>
</tr>
<tr>
<td>显示包内容（16 进制）</td>
<td><code>tshark -r file.pcap -x -V</code></td>
</tr>
<tr>
<td>显示 HTTP 请求头和 body</td>
<td><code>tshark -r file.pcap -Y &quot;http&quot; -T fields -e http.file_data</code></td>
</tr>
<tr>
<td>按 TCP 流查看</td>
<td><code>tshark -r file.pcap -q -z follow,tcp,ascii,0</code></td>
</tr>
<tr>
<td>统计 TCP 流信息</td>
<td><code>tshark -r file.pcap -q -z conv,tcp</code></td>
</tr>
<tr>
<td>过滤 SYN 包</td>
<td><code>tshark -r file.pcap -Y &quot;tcp.flags.syn==1 &amp;&amp; tcp.flags.ack==0&quot;</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="3-TCP-异常包类型对照表"><a href="#3-TCP-异常包类型对照表" class="headerlink" title="3. TCP 异常包类型对照表"></a>3. TCP 异常包类型对照表</h2><table>
<thead>
<tr>
<th>异常类型</th>
<th>说明</th>
<th>tcpdump 过滤命令</th>
<th>tshark 过滤命令</th>
</tr>
</thead>
<tbody><tr>
<td>TCP 连接建立（SYN）</td>
<td>仅包含 SYN（第一次握手）</td>
<td><code>tcpdump &#39;tcp[tcpflags] &amp; tcp-syn != 0 and tcp[tcpflags] &amp; tcp-ack == 0&#39;</code></td>
<td><code>tshark -r file.pcap -Y &quot;tcp.flags.syn==1 &amp;&amp; tcp.flags.ack==0&quot;</code></td>
</tr>
<tr>
<td>TCP 连接确认（SYN+ACK）</td>
<td>第二次握手</td>
<td><code>tcpdump &#39;tcp[tcpflags] &amp; tcp-syn != 0 and tcp[tcpflags] &amp; tcp-ack != 0&#39;</code></td>
<td><code>tshark -r file.pcap -Y &quot;tcp.flags.syn==1 &amp;&amp; tcp.flags.ack==1&quot;</code></td>
</tr>
<tr>
<td>TCP 正常关闭（FIN）</td>
<td>发起关闭连接</td>
<td><code>tcpdump &#39;tcp[tcpflags] &amp; tcp-fin != 0&#39;</code></td>
<td><code>tshark -r file.pcap -Y &quot;tcp.flags.fin==1&quot;</code></td>
</tr>
<tr>
<td>TCP 异常关闭（RST）</td>
<td>强制关闭连接</td>
<td><code>tcpdump &#39;tcp[tcpflags] &amp; tcp-rst != 0&#39;</code></td>
<td><code>tshark -r file.pcap -Y &quot;tcp.flags.reset==1&quot;</code></td>
</tr>
<tr>
<td>TCP 重传包</td>
<td>数据包丢失重发</td>
<td>（建议用 tshark）</td>
<td><code>tshark -r file.pcap -Y &quot;tcp.analysis.retransmission&quot;</code></td>
</tr>
<tr>
<td>TCP 快速重传</td>
<td>提前触发的重传</td>
<td>-</td>
<td><code>tshark -r file.pcap -Y &quot;tcp.analysis.fast_retransmission&quot;</code></td>
</tr>
<tr>
<td>TCP 零窗口</td>
<td>接收方窗口大小为 0</td>
<td>-</td>
<td><code>tshark -r file.pcap -Y &quot;tcp.analysis.zero_window&quot;</code></td>
</tr>
<tr>
<td>TCP 窗口更新</td>
<td>更新接收窗口大小</td>
<td>-</td>
<td><code>tshark -r file.pcap -Y &quot;tcp.analysis.window_update&quot;</code></td>
</tr>
<tr>
<td>TCP 重复 ACK</td>
<td>接收方收到相同序列号数据</td>
<td>-</td>
<td><code>tshark -r file.pcap -Y &quot;tcp.analysis.duplicate_ack&quot;</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="4-速查总结"><a href="#4-速查总结" class="headerlink" title="4. 速查总结"></a>4. 速查总结</h2><ul>
<li><strong>tcpdump</strong> 适合快速抓包、实时监控。</li>
<li><strong>tshark</strong> 适合深度分析、协议解析、统计。</li>
<li>建议配合使用：<code>tcpdump</code> 抓包 + <code>tshark</code> 离线分析。</li>
</ul>
<h2 id="5-其他命令"><a href="#5-其他命令" class="headerlink" title="5. 其他命令"></a>5. 其他命令</h2><h3 id="1-分析协议和流量分布"><a href="#1-分析协议和流量分布" class="headerlink" title="1. 分析协议和流量分布"></a>1. 分析协议和流量分布</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看协议分布</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据包大小分布</span></span><br><span class="line">tcpdump -r 文件名.pcap -nq | awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> | <span class="built_in">sort</span> -n | <span class="built_in">uniq</span> -c</span><br></pre></td></tr></table></figure>

<h3 id="2-分析TCP连接"><a href="#2-分析TCP连接" class="headerlink" title="2. 分析TCP连接"></a>2. 分析TCP连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看TCP SYN包（连接建立）</span></span><br><span class="line">tcpdump -r 文件名.pcap -nnvX | grep -i <span class="string">&quot;Flags \[S&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看TCP FIN包（连接终止）</span></span><br><span class="line">tcpdump -r 文件名.pcap -nnvX | grep -i <span class="string">&quot;Flags \[F&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看TCP RST包（连接重置）</span></span><br><span class="line">tcpdump -r 文件名.pcap -nnvX | grep -i <span class="string">&quot;Flags \[R&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有带P标志的包（数据推送）</span></span><br><span class="line">tcpdump -r 文件名.pcap -nnvX | grep -i <span class="string">&quot;Flags \[P&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-HTTP流量分析"><a href="#3-HTTP流量分析" class="headerlink" title="3. HTTP流量分析"></a>3. HTTP流量分析</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看HTTP请求</span></span><br><span class="line">tcpdump -r 文件名.pcap -A | grep -i <span class="string">&quot;HTTP\|GET\|POST&quot;</span> | <span class="built_in">head</span> -10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看HTTP响应状态</span></span><br><span class="line">tcpdump -r 文件名.pcap -nnn -A | grep -i <span class="string">&quot;HTTP/&quot;</span> | <span class="built_in">head</span> -5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看请求和响应的内容类型</span></span><br><span class="line">tcpdump -r 文件名.pcap -nnn -A | grep -i <span class="string">&quot;Accept\|Content-Type&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看HTTP请求的User-Agent</span></span><br><span class="line">tcpdump -r 文件名.pcap -nnA | grep -i <span class="string">&quot;User-Agent&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-安全和异常分析"><a href="#4-安全和异常分析" class="headerlink" title="4. 安全和异常分析"></a>4. 安全和异常分析</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找错误或异常信息</span></span><br><span class="line">tcpdump -r 文件名.pcap -nnA | grep -i <span class="string">&quot;error\|failure\|denied\|attack\|malicious\|failed&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找可疑的HTTP请求（如SQL注入、XSS攻击）</span></span><br><span class="line">tcpdump -r 文件名.pcap -A | grep -i <span class="string">&quot;select\|union\|insert\|delete\|&lt;script&gt;\|eval(&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找端口扫描行为（大量SYN包）</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn <span class="string">&#x27;tcp[13] &amp; 2 != 0&#x27;</span> | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr</span><br></pre></td></tr></table></figure>

<h2 id="高级tcpdump分析技巧"><a href="#高级tcpdump分析技巧" class="headerlink" title="高级tcpdump分析技巧"></a>高级tcpdump分析技巧</h2><h3 id="1-按IP地址和端口过滤"><a href="#1-按IP地址和端口过滤" class="headerlink" title="1. 按IP地址和端口过滤"></a>1. 按IP地址和端口过滤</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看特定源IP的流量</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn src host 192.168.1.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定目标IP的流量</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn dst host 192.168.1.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定端口的流量</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn port 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定IP和端口组合的流量</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn <span class="string">&#x27;host 192.168.1.1 and port 80&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-按协议过滤"><a href="#2-按协议过滤" class="headerlink" title="2. 按协议过滤"></a>2. 按协议过滤</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只查看TCP流量</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只查看UDP流量</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn udp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只查看ICMP流量</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn icmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看非HTTP流量</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn <span class="string">&#x27;tcp and not port 80 and not port 443&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-数据包内容分析"><a href="#3-数据包内容分析" class="headerlink" title="3. 数据包内容分析"></a>3. 数据包内容分析</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以十六进制和ASCII格式显示完整数据包内容</span></span><br><span class="line">tcpdump -r 文件名.pcap -nnvXX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示数据包头部</span></span><br><span class="line">tcpdump -r 文件名.pcap -nnvv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示特定字节偏移量的内容</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn <span class="string">&#x27;tcp[20:4] = 0x47455420&#x27;</span>  <span class="comment"># 查找&quot;GET &quot;开头的数据包</span></span><br></pre></td></tr></table></figure>

<h3 id="4-会话流分析"><a href="#4-会话流分析" class="headerlink" title="4. 会话流分析"></a>4. 会话流分析</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 追踪特定TCP会话</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn -A <span class="string">&#x27;host 192.168.1.1 and host 192.168.1.2 and port 80&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看握手包的时间差（延迟分析）</span></span><br><span class="line">tcpdump -r 文件名.pcap -nntt <span class="string">&#x27;tcp[13] &amp; 2 != 0 or tcp[13] &amp; 16 != 0&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="其他有用的网络分析工具"><a href="#其他有用的网络分析工具" class="headerlink" title="其他有用的网络分析工具"></a>其他有用的网络分析工具</h2><h3 id="1-tshark-Wireshark的命令行版本"><a href="#1-tshark-Wireshark的命令行版本" class="headerlink" title="1. tshark (Wireshark的命令行版本)"></a>1. tshark (Wireshark的命令行版本)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux下安装</span></span><br><span class="line">yum install -y wireshark</span><br><span class="line"><span class="comment"># 基本使用方法</span></span><br><span class="line">tshark -r 文件名.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment">#termshark GUI</span></span><br><span class="line">https://github.com/gcla/termshark</span><br><span class="line"><span class="comment">#使用说明</span></span><br><span class="line">https://github.com/gcla/termshark/blob/master/docs/UserGuide.md</span><br></pre></td></tr></table></figure>

<h3 id="2-tcpflow-TCP流重组"><a href="#2-tcpflow-TCP流重组" class="headerlink" title="2. tcpflow (TCP流重组)"></a>2. tcpflow (TCP流重组)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重组TCP会话</span></span><br><span class="line">tcpflow -r 文件名.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定输出目录</span></span><br><span class="line">tcpflow -r 文件名.pcap -o 输出目录</span><br></pre></td></tr></table></figure>

<h2 id="实用一行命令"><a href="#实用一行命令" class="headerlink" title="实用一行命令"></a>实用一行命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找Top Talkers (通信最频繁的主机)</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> | <span class="built_in">cut</span> -d. -f1-4 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr | <span class="built_in">head</span> -10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找最常用的服务</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> | <span class="built_in">cut</span> -d. -f5 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr | <span class="built_in">head</span> -10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取所有URL</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn -A | grep -oE <span class="string">&#x27;(GET|POST|HEAD) .* HTTP/[0-9.]+&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测SYN Flood攻击</span></span><br><span class="line">tcpdump -r 文件名.pcap -nn <span class="string">&#x27;tcp[13] &amp; 2 != 0&#x27;</span> | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr | <span class="built_in">head</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取所有邮箱地址</span></span><br><span class="line">tcpdump -r 文件名.pcap -A | grep -oE <span class="string">&#x27;[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]&#123;2,6&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="实时捕获命令参考"><a href="#实时捕获命令参考" class="headerlink" title="实时捕获命令参考"></a>实时捕获命令参考</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 捕获指定接口的流量</span></span><br><span class="line">tcpdump -i eth0 -w 输出文件.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获特定主机的流量</span></span><br><span class="line">tcpdump -i eth0 host 192.168.1.1 -w 输出文件.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获特定端口的流量</span></span><br><span class="line">tcpdump -i eth0 port 80 -w 输出文件.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制捕获包的数量或大小</span></span><br><span class="line">tcpdump -i eth0 -c 1000 -w 输出文件.pcap  <span class="comment"># 捕获1000个包后停止</span></span><br><span class="line">tcpdump -i eth0 -C 10 -w 输出文件.pcap    <span class="comment"># 每个文件限制为10MB</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>tshark分析包</title>
    <url>/2025/08/11/tshark%E5%88%86%E6%9E%90%E5%8C%85/</url>
    <content><![CDATA[<h2 id="tshark常用方法排查-TCP-异常包"><a href="#tshark常用方法排查-TCP-异常包" class="headerlink" title="tshark常用方法排查 TCP 异常包"></a>tshark常用方法排查 TCP 异常包</h2><h3 id="1-查找连接建立（SYN-包）"><a href="#1-查找连接建立（SYN-包）" class="headerlink" title="1. 查找连接建立（SYN 包）"></a>1. 查找连接建立（SYN 包）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r tcp_connection_20250811_180802.pcap -Y <span class="string">&quot;tcp.flags.syn==1 and tcp.flags.ack==0&quot;</span></span><br></pre></td></tr></table></figure>

<p>用来找三次握手的第一个包。</p>
<h3 id="2-查找连接重置（RST-包）"><a href="#2-查找连接重置（RST-包）" class="headerlink" title="2. 查找连接重置（RST 包）"></a>2. 查找连接重置（RST 包）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r tcp_connection_20250811_180802.pcap -Y <span class="string">&quot;tcp.flags.reset==1&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以定位连接被强制中断的地方。</p>
<h3 id="3-查找连接关闭（FIN-包）"><a href="#3-查找连接关闭（FIN-包）" class="headerlink" title="3. 查找连接关闭（FIN 包）"></a>3. 查找连接关闭（FIN 包）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r tcp_connection_20250811_180802.pcap -Y <span class="string">&quot;tcp.flags.fin==1&quot;</span></span><br></pre></td></tr></table></figure>

<p>用来分析正常关闭的 TCP 会话。</p>
<h3 id="4-查找异常-TCP-包（重传、乱序、窗口问题）"><a href="#4-查找异常-TCP-包（重传、乱序、窗口问题）" class="headerlink" title="4. 查找异常 TCP 包（重传、乱序、窗口问题）"></a>4. 查找异常 TCP 包（重传、乱序、窗口问题）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r tcp_connection_20250811_180802.pcap -Y <span class="string">&quot;tcp.analysis.flags&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>tshark</code> 会自动解析并标记重传、丢包、乱序等问题。</p>
<h3 id="5-按-TCP-流分析"><a href="#5-按-TCP-流分析" class="headerlink" title="5. 按 TCP 流分析"></a>5. 按 TCP 流分析</h3><p>先列出所有 TCP 流 ID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r tcp_connection_20250811_180802.pcap -T fields -e tcp.stream | <span class="built_in">sort</span> -n | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure>

<p>然后针对某个流 ID（比如 3）分析：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r tcp_connection_20250811_180802.pcap -Y <span class="string">&quot;tcp.stream eq 3 and (tcp.flags.syn==1 or tcp.flags.reset==1 or tcp.flags.fin==1)&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>网络故障排查指南（使用tcpdump和tshark）</title>
    <url>/2025/08/11/%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%8C%87%E5%8D%97%EF%BC%88%E4%BD%BF%E7%94%A8tcpdump%E5%92%8Ctshark%EF%BC%89/</url>
    <content><![CDATA[<h1 id="网络故障排查指南（使用tcpdump和tshark）"><a href="#网络故障排查指南（使用tcpdump和tshark）" class="headerlink" title="网络故障排查指南（使用tcpdump和tshark）"></a>网络故障排查指南（使用tcpdump和tshark）</h1><p>本指南提供参考表格和命令，用于分析数据包捕获以识别网络问题。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#http%E7%8A%B6%E6%80%81%E7%A0%81">HTTP状态码</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90">响应时间分析</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8C%87%E6%A0%87">数据传输指标</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF">连接信息</a></li>
<li><a href="#%E5%86%85%E5%AE%B9%E7%BC%96%E7%A0%81">内容编码</a></li>
<li><a href="#%E4%BC%9A%E8%AF%9D%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF">会话状态信息</a></li>
<li><a href="#tcp%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B">TCP连接建立</a></li>
<li><a href="#tcp%E9%87%8D%E4%BC%A0">TCP重传</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E5%85%B3%E9%97%AD%E5%88%86%E6%9E%90">连接关闭分析</a></li>
<li><a href="#tcp%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98">TCP窗口问题</a></li>
<li><a href="#%E6%8D%95%E8%8E%B7%E5%AE%8C%E6%95%B4tcp%E6%B5%81">捕获完整TCP流</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B">常用命令示例</a></li>
</ul>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><table>
<thead>
<tr>
<th>状态码范围</th>
<th>类别</th>
<th>描述</th>
<th>常见代码</th>
<th>tshark过滤器示例</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>信息性</td>
<td>请求已接收，继续处理</td>
<td>100 Continue, 101 Switching Protocols</td>
<td><code>http.response.code &gt;= 100 and http.response.code &lt; 200</code></td>
</tr>
<tr>
<td>2xx</td>
<td>成功</td>
<td>请求已成功接收、理解并接受</td>
<td>200 OK, 201 Created, 204 No Content</td>
<td><code>http.response.code &gt;= 200 and http.response.code &lt; 300</code></td>
</tr>
<tr>
<td>3xx</td>
<td>重定向</td>
<td>需要进一步操作才能完成请求</td>
<td>301 Moved Permanently, 302 Found, 304 Not Modified</td>
<td><code>http.response.code &gt;= 300 and http.response.code &lt; 400</code></td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误</td>
<td>请求包含错误语法或无法完成</td>
<td>400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found</td>
<td><code>http.response.code &gt;= 400 and http.response.code &lt; 500</code></td>
</tr>
<tr>
<td>5xx</td>
<td>服务器错误</td>
<td>服务器未能完成有效请求</td>
<td>500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable, 504 Gateway Timeout</td>
<td><code>http.response.code &gt;= 500 and http.response.code &lt; 600</code></td>
</tr>
</tbody></table>
<h3 id="具体HTTP状态码排障"><a href="#具体HTTP状态码排障" class="headerlink" title="具体HTTP状态码排障"></a>具体HTTP状态码排障</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
<th>潜在问题</th>
<th>调查步骤</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>错误请求</td>
<td>请求语法格式错误</td>
<td>检查请求头和请求体格式</td>
</tr>
<tr>
<td>401</td>
<td>未授权</td>
<td>需要身份验证</td>
<td>验证授权令牌&#x2F;请求头</td>
</tr>
<tr>
<td>403</td>
<td>禁止访问</td>
<td>服务器理解但拒绝执行</td>
<td>检查权限和IP限制</td>
</tr>
<tr>
<td>404</td>
<td>未找到</td>
<td>资源不存在</td>
<td>验证URL路径和资源是否存在</td>
</tr>
<tr>
<td>408</td>
<td>请求超时</td>
<td>服务器等待超时</td>
<td>检查网络延迟和服务器负载</td>
</tr>
<tr>
<td>413</td>
<td>负载过大</td>
<td>请求实体过大</td>
<td>检查文件大小限制</td>
</tr>
<tr>
<td>429</td>
<td>请求过多</td>
<td>超出速率限制</td>
<td>实施退避策略</td>
</tr>
<tr>
<td>500</td>
<td>服务器内部错误</td>
<td>通用服务器错误</td>
<td>检查服务器日志中的异常</td>
</tr>
<tr>
<td>502</td>
<td>网关错误</td>
<td>上游服务器返回无效响应</td>
<td>检查上游服务器健康状况</td>
</tr>
<tr>
<td>503</td>
<td>服务不可用</td>
<td>服务器暂时不可用</td>
<td>检查维护状态或过载情况</td>
</tr>
<tr>
<td>504</td>
<td>网关超时</td>
<td>网关超时</td>
<td>检查上游服务器响应时间</td>
</tr>
</tbody></table>
<h3 id="HTTP状态分析的tshark命令"><a href="#HTTP状态分析的tshark命令" class="headerlink" title="HTTP状态分析的tshark命令"></a>HTTP状态分析的tshark命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计HTTP响应码</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http.response&quot;</span> -T fields -e http.response.code | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤HTTP错误（4xx和5xx）</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http.response.code &gt;= 400&quot;</span> -T fields -e frame.time -e ip.src -e ip.dst -e http.request.uri -e http.response.code -e http.response.phrase</span><br></pre></td></tr></table></figure>

<h2 id="响应时间分析"><a href="#响应时间分析" class="headerlink" title="响应时间分析"></a>响应时间分析</h2><table>
<thead>
<tr>
<th>指标</th>
<th>描述</th>
<th>计算方法</th>
<th>正常范围</th>
<th>调查触发点</th>
<th>tshark过滤器示例</th>
</tr>
</thead>
<tbody><tr>
<td>请求-响应时间</td>
<td>请求与响应之间的时间</td>
<td>响应时间 - 请求时间</td>
<td>&lt;500ms</td>
<td>&gt;1s</td>
<td>见下方命令</td>
</tr>
<tr>
<td>首字节时间(TTFB)</td>
<td>从请求到响应第一个字节的时间</td>
<td>首个响应包时间 - 请求时间</td>
<td>&lt;200ms</td>
<td>&gt;500ms</td>
<td>见下方命令</td>
</tr>
<tr>
<td>服务器处理时间</td>
<td>服务器处理请求所需时间</td>
<td>首个响应包 - 最后请求包</td>
<td>&lt;200ms</td>
<td>&gt;500ms</td>
<td>从捕获中手动计算</td>
</tr>
<tr>
<td>总事务时间</td>
<td>完整HTTP事务时间</td>
<td>最后响应包 - 首个请求包</td>
<td>&lt;1s</td>
<td>&gt;3s</td>
<td>从捕获中手动计算</td>
</tr>
</tbody></table>
<h3 id="响应时间分析的tshark命令"><a href="#响应时间分析的tshark命令" class="headerlink" title="响应时间分析的tshark命令"></a>响应时间分析的tshark命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算HTTP请求-响应时间</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http.request or http.response&quot;</span> -T fields -e frame.number -e frame.time_epoch -e http.request.method -e http.request.uri -e http.response.code | awk <span class="string">&#x27;BEGIN &#123;OFS=&quot;\t&quot;; print &quot;Frame&quot;, &quot;Time&quot;, &quot;Method/Code&quot;, &quot;URI/Reason&quot;&#125; &#123;print $1, $2, $3, $4&#125;&#x27;</span> | <span class="built_in">sort</span> -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算TCP连接时间</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.flags.syn==1&quot;</span> -T fields -e frame.number -e frame.time_epoch -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport | <span class="built_in">sort</span> -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级响应时间分析（需要tshark 3.0+）</span></span><br><span class="line">tshark -r capture.pcap -q -z <span class="string">&quot;io,stat,0.001,COUNT(http.request)http.request,COUNT(http.response)http.response,SUM(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt/COUNT(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="数据传输指标"><a href="#数据传输指标" class="headerlink" title="数据传输指标"></a>数据传输指标</h2><table>
<thead>
<tr>
<th>指标</th>
<th>描述</th>
<th>计算方法</th>
<th>正常范围</th>
<th>调查触发点</th>
<th>tshark过滤器示例</th>
</tr>
</thead>
<tbody><tr>
<td>响应大小</td>
<td>HTTP响应体大小</td>
<td>所有HTTP响应数据包总和</td>
<td>因内容而异</td>
<td>异常大或小</td>
<td><code>http.content_length</code></td>
</tr>
<tr>
<td>吞吐量</td>
<td>数据传输速率</td>
<td>总字节数 &#x2F; 时间段</td>
<td>&gt;1 MB&#x2F;s</td>
<td>&lt;100 KB&#x2F;s</td>
<td>从捕获中计算</td>
</tr>
<tr>
<td>HTTP内容长度</td>
<td>声明的HTTP实体大小</td>
<td>Content-Length头的值</td>
<td>因内容而异</td>
<td>与实际大小不匹配</td>
<td><code>http.content_length</code></td>
</tr>
<tr>
<td>数据包大小</td>
<td>单个数据包的大小</td>
<td>数据包头中的大小字段</td>
<td>≤MTU（通常1500字节）</td>
<td>分片或极小包</td>
<td><code>frame.len</code></td>
</tr>
<tr>
<td>传输编码</td>
<td>用于传输实体的方法</td>
<td>检查分块或压缩</td>
<td>动态内容通常使用分块</td>
<td>大型静态文件的原始传输</td>
<td><code>http.transfer_encoding</code></td>
</tr>
</tbody></table>
<h3 id="数据传输分析的tshark命令"><a href="#数据传输分析的tshark命令" class="headerlink" title="数据传输分析的tshark命令"></a>数据传输分析的tshark命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分析HTTP响应大小</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http.response&quot;</span> -T fields -e http.response.code -e http.content_length -e http.content_type</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算吞吐量随时间变化</span></span><br><span class="line">tshark -r capture.pcap -q -z io,<span class="built_in">stat</span>,1,<span class="string">&quot;SUM(frame.len)frame.len&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析数据包大小</span></span><br><span class="line">tshark -r capture.pcap -T fields -e frame.number -e frame.len -e frame.time_relative | <span class="built_in">sort</span> -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找潜在的分片数据包</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;ip.flags.mf == 1 or ip.frag_offset &gt; 0&quot;</span> -T fields -e frame.number -e ip.src -e ip.dst -e frame.len</span><br></pre></td></tr></table></figure>

<h2 id="连接信息"><a href="#连接信息" class="headerlink" title="连接信息"></a>连接信息</h2><table>
<thead>
<tr>
<th>连接类型</th>
<th>描述</th>
<th>预期行为</th>
<th>潜在问题</th>
<th>tshark过滤器示例</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP Keep-Alive</td>
<td>复用TCP连接处理多个HTTP请求</td>
<td>请求头中包含<code>Connection: keep-alive</code></td>
<td>连接提前关闭</td>
<td><code>http.connection contains &quot;keep-alive&quot;</code></td>
</tr>
<tr>
<td>HTTP连接关闭</td>
<td>响应后关闭TCP连接</td>
<td>请求头中包含<code>Connection: close</code></td>
<td>连接仍在保持</td>
<td><code>http.connection contains &quot;close&quot;</code></td>
</tr>
<tr>
<td>持久连接</td>
<td>同一TCP连接上的多个请求&#x2F;响应对</td>
<td>相同5元组上有多个HTTP交换</td>
<td>短请求的高连接开销</td>
<td><code>tcp.stream eq X</code></td>
</tr>
<tr>
<td>连接池</td>
<td>客户端维护服务器连接池</td>
<td>与同一服务器建立多个并行连接</td>
<td>连接限制问题</td>
<td>检查唯一流计数</td>
</tr>
<tr>
<td>连接复用</td>
<td>为新请求重用现有连接</td>
<td>降低TCP握手开销</td>
<td>竞态条件，过期连接</td>
<td>请求间的时间分析</td>
</tr>
</tbody></table>
<h3 id="连接分析的tshark命令"><a href="#连接分析的tshark命令" class="headerlink" title="连接分析的tshark命令"></a>连接分析的tshark命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查HTTP连接头</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http.connection&quot;</span> -T fields -e frame.number -e http.connection</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算唯一TCP流数量</span></span><br><span class="line">tshark -r capture.pcap -T fields -e tcp.stream | <span class="built_in">sort</span> -n | <span class="built_in">uniq</span> | <span class="built_in">wc</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析连接持续时间</span></span><br><span class="line">tshark -r capture.pcap -q -z conv,tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找短暂连接（&lt;3个数据包）</span></span><br><span class="line">tshark -r capture.pcap -q -z <span class="string">&quot;conv,tcp&quot;</span> | grep <span class="string">&quot;&lt;3&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h2><table>
<thead>
<tr>
<th>编码类型</th>
<th>描述</th>
<th>头部</th>
<th>优势</th>
<th>潜在问题</th>
<th>tshark过滤器示例</th>
</tr>
</thead>
<tbody><tr>
<td>Gzip</td>
<td>使用gzip算法压缩</td>
<td><code>Content-Encoding: gzip</code></td>
<td>减少带宽使用</td>
<td>CPU开销，故障排除难度</td>
<td><code>http.content_encoding contains &quot;gzip&quot;</code></td>
</tr>
<tr>
<td>Deflate</td>
<td>使用deflate算法压缩</td>
<td><code>Content-Encoding: deflate</code></td>
<td>减少带宽使用</td>
<td>不太常见，兼容性问题</td>
<td><code>http.content_encoding contains &quot;deflate&quot;</code></td>
</tr>
<tr>
<td>Brotli</td>
<td>更新的压缩算法</td>
<td><code>Content-Encoding: br</code></td>
<td>比gzip更好的压缩</td>
<td>并非所有客户端都支持</td>
<td><code>http.content_encoding contains &quot;br&quot;</code></td>
</tr>
<tr>
<td>分块传输</td>
<td>数据以块形式发送</td>
<td><code>Transfer-Encoding: chunked</code></td>
<td>不知道最终大小的流数据</td>
<td>手动解析更困难</td>
<td><code>http.transfer_encoding contains &quot;chunked&quot;</code></td>
</tr>
<tr>
<td>Identity</td>
<td>不应用编码</td>
<td><code>Content-Encoding: identity</code>或缺席</td>
<td>简单性，无需解码</td>
<td>更大的传输大小</td>
<td><code>!(http.content_encoding)</code></td>
</tr>
<tr>
<td>Compressed</td>
<td>通用压缩</td>
<td><code>Content-Encoding: compressed</code></td>
<td>传统指示器</td>
<td>模糊的压缩方法</td>
<td><code>http.content_encoding contains &quot;compressed&quot;</code></td>
</tr>
</tbody></table>
<h3 id="内容编码分析的tshark命令"><a href="#内容编码分析的tshark命令" class="headerlink" title="内容编码分析的tshark命令"></a>内容编码分析的tshark命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查内容编码头</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http.content_encoding&quot;</span> -T fields -e frame.number -e http.content_encoding</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查传输编码头</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http.transfer_encoding&quot;</span> -T fields -e frame.number -e http.transfer_encoding</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算压缩比（需要手动分析）</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http.response and http.content_encoding&quot;</span> -T fields -e http.content_length -e http.content_encoding</span><br></pre></td></tr></table></figure>

<h2 id="会话状态信息"><a href="#会话状态信息" class="headerlink" title="会话状态信息"></a>会话状态信息</h2><table>
<thead>
<tr>
<th>会话机制</th>
<th>描述</th>
<th>查找位置</th>
<th>正常行为</th>
<th>潜在问题</th>
<th>tshark过滤器示例</th>
</tr>
</thead>
<tbody><tr>
<td>Cookies</td>
<td>客户端状态存储</td>
<td><code>Cookie</code>和<code>Set-Cookie</code>头</td>
<td>在请求之间保持持久性</td>
<td>丢失、过期或格式错误的cookies</td>
<td><code>http.cookie or http.set_cookie</code></td>
</tr>
<tr>
<td>会话ID</td>
<td>服务器分配的标识符</td>
<td>URL参数、cookie或头部</td>
<td>在用户会话中保持一致</td>
<td>会话中途更改，无效格式</td>
<td><code>http.cookie contains &quot;sessionid&quot;</code></td>
</tr>
<tr>
<td>JWT令牌</td>
<td>用于认证的JSON Web令牌</td>
<td>带<code>Bearer</code>的<code>Authorization</code>头</td>
<td>有效的、未过期的令牌</td>
<td>令牌验证失败，令牌过期</td>
<td><code>http.authorization contains &quot;Bearer&quot;</code></td>
</tr>
<tr>
<td>OAuth令牌</td>
<td>授权令牌</td>
<td><code>Authorization</code>头</td>
<td>具有适当范围的有效令牌</td>
<td>无效令牌，权限不足</td>
<td><code>http.authorization</code></td>
</tr>
<tr>
<td>本地存储</td>
<td>浏览器存储（不在数据包中）</td>
<td>JavaScript交互</td>
<td>不适用 - 仅客户端</td>
<td>不适用</td>
<td>不适用</td>
</tr>
<tr>
<td>CSRF令牌</td>
<td>跨站请求伪造保护</td>
<td>表单字段，自定义头部</td>
<td>令牌匹配服务器预期</td>
<td>丢失或不匹配的令牌</td>
<td>自定义头部过滤器</td>
</tr>
</tbody></table>
<h3 id="会话分析的tshark命令"><a href="#会话分析的tshark命令" class="headerlink" title="会话分析的tshark命令"></a>会话分析的tshark命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分析cookie使用情况</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http.cookie or http.set_cookie&quot;</span> -T fields -e frame.number -e http.cookie -e http.set_cookie</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪授权头</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http.authorization&quot;</span> -T fields -e frame.number -e http.authorization</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪HTTP流以查看完整会话</span></span><br><span class="line">tshark -r capture.pcap -q -z follow,http,ascii,0</span><br></pre></td></tr></table></figure>

<h2 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h2><table>
<thead>
<tr>
<th>连接阶段</th>
<th>预期数据包</th>
<th>正常行为</th>
<th>潜在问题</th>
<th>tshark过滤器示例</th>
</tr>
</thead>
<tbody><tr>
<td>SYN</td>
<td>客户端 → 服务器</td>
<td>初始连接请求</td>
<td>无响应（黑洞），多次重试</td>
<td><code>tcp.flags.syn==1 and tcp.flags.ack==0</code></td>
</tr>
<tr>
<td>SYN-ACK</td>
<td>服务器 → 客户端</td>
<td>服务器确认连接</td>
<td>延迟响应，无响应</td>
<td><code>tcp.flags.syn==1 and tcp.flags.ack==1</code></td>
</tr>
<tr>
<td>ACK</td>
<td>客户端 → 服务器</td>
<td>客户端确认连接已建立</td>
<td>缺少ACK，延迟ACK</td>
<td><code>tcp.flags.syn==0 and tcp.flags.ack==1 and tcp.len==0</code></td>
</tr>
<tr>
<td>完整握手</td>
<td>SYN → SYN-ACK → ACK</td>
<td>连接在&lt;1s内建立</td>
<td>不完整握手，过度延迟</td>
<td>见下方命令</td>
</tr>
</tbody></table>
<h3 id="连接建立分析表"><a href="#连接建立分析表" class="headerlink" title="连接建立分析表"></a>连接建立分析表</h3><table>
<thead>
<tr>
<th>问题</th>
<th>症状</th>
<th>可能原因</th>
<th>调查步骤</th>
</tr>
</thead>
<tbody><tr>
<td>连接超时</td>
<td>发送SYN，未收到SYN-ACK</td>
<td>防火墙阻止，服务器宕机，网络问题</td>
<td>检查防火墙规则，服务器状态，网络路径</td>
</tr>
<tr>
<td>慢连接</td>
<td>SYN与SYN-ACK之间延迟长</td>
<td>服务器过载，网络拥塞</td>
<td>检查服务器负载，网络延迟</td>
</tr>
<tr>
<td>SYN泛洪</td>
<td>客户端发送多个SYN</td>
<td>DoS攻击，客户端应用问题</td>
<td>检查客户端行为，实施SYN cookies</td>
</tr>
<tr>
<td>连接重置</td>
<td>SYN后RST</td>
<td>服务不可用，端口关闭</td>
<td>验证服务是否在预期端口运行</td>
</tr>
</tbody></table>
<h3 id="连接建立分析的tshark命令"><a href="#连接建立分析的tshark命令" class="headerlink" title="连接建立分析的tshark命令"></a>连接建立分析的tshark命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 识别TCP握手</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.flags.syn==1&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -e tcp.flags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找不完整握手</span></span><br><span class="line">tshark -r capture.pcap -q -z <span class="string">&quot;follow,tcp,ascii&quot;</span> | grep -i <span class="string">&quot;reassembled tcp\|connection\|handshake&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析TCP连接建立时间</span></span><br><span class="line">tshark -r capture.pcap -q -z <span class="string">&quot;io,stat,0.1,COUNT(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt/COUNT(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="TCP重传"><a href="#TCP重传" class="headerlink" title="TCP重传"></a>TCP重传</h2><table>
<thead>
<tr>
<th>重传类型</th>
<th>描述</th>
<th>症状</th>
<th>潜在原因</th>
<th>tshark过滤器示例</th>
</tr>
</thead>
<tbody><tr>
<td>快速重传</td>
<td>收到重复ACK后快速重发</td>
<td>多个重复ACK后跟重传</td>
<td>数据包丢失，网络拥塞</td>
<td><code>tcp.analysis.fast_retransmission</code></td>
</tr>
<tr>
<td>超时重传</td>
<td>超时后重发数据包</td>
<td>重发前长时间延迟</td>
<td>高延迟，严重数据包丢失</td>
<td><code>tcp.analysis.retransmission</code></td>
</tr>
<tr>
<td>虚假重传</td>
<td>不必要的重传</td>
<td>原始数据包实际已收到</td>
<td>延迟ACK，网络重排序</td>
<td><code>tcp.analysis.spurious_retransmission</code></td>
</tr>
<tr>
<td>乱序</td>
<td>数据包接收顺序混乱</td>
<td>TCP序列号不按顺序</td>
<td>网络路径差异，负载均衡</td>
<td><code>tcp.analysis.out_of_order</code></td>
</tr>
<tr>
<td>重复ACK</td>
<td>多次发送相同ACK</td>
<td>具有相同序列号的多个ACK</td>
<td>数据包丢失，重排序</td>
<td><code>tcp.analysis.duplicate_ack</code></td>
</tr>
</tbody></table>
<h3 id="重传分析表"><a href="#重传分析表" class="headerlink" title="重传分析表"></a>重传分析表</h3><table>
<thead>
<tr>
<th>问题</th>
<th>症状</th>
<th>可能原因</th>
<th>调查步骤</th>
</tr>
</thead>
<tbody><tr>
<td>高重传率</td>
<td>&gt;1%的数据包被重传</td>
<td>网络拥塞，硬件问题</td>
<td>检查网络设备，链路利用率</td>
</tr>
<tr>
<td>重复超时重传</td>
<td>同一段的多次超时重传</td>
<td>严重拥塞，防火墙丢包</td>
<td>检查防火墙规则，网络路径</td>
</tr>
<tr>
<td>非对称重传</td>
<td>只有一个方向显示重传</td>
<td>单向拥塞或过滤</td>
<td>检查有问题方向的网络路径</td>
</tr>
<tr>
<td>突发重传</td>
<td>短时间内多次重传</td>
<td>临时网络问题，微突发</td>
<td>检查模式（一天中的时间，特定流量）</td>
</tr>
</tbody></table>
<h3 id="重传分析的tshark命令"><a href="#重传分析的tshark命令" class="headerlink" title="重传分析的tshark命令"></a>重传分析的tshark命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找所有重传</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.analysis.retransmission or tcp.analysis.fast_retransmission&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e ip.dst -e tcp.srcport -e tcp.dstport</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算重传率</span></span><br><span class="line">tshark -r capture.pcap -q -z <span class="string">&quot;io,stat,1,COUNT(tcp.analysis.retransmission)tcp.analysis.retransmission,COUNT(tcp.analysis.fast_retransmission)tcp.analysis.fast_retransmission,COUNT(tcp)tcp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找重复ACK</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.analysis.duplicate_ack&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -e tcp.ack</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析有问题的特定TCP流</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.stream eq X and (tcp.analysis.retransmission or tcp.analysis.duplicate_ack)&quot;</span> -T fields -e frame.number -e frame.time_relative -e tcp.analysis.flags</span><br></pre></td></tr></table></figure>

<h2 id="连接关闭分析"><a href="#连接关闭分析" class="headerlink" title="连接关闭分析"></a>连接关闭分析</h2><table>
<thead>
<tr>
<th>关闭类型</th>
<th>描述</th>
<th>预期数据包</th>
<th>潜在问题</th>
<th>tshark过滤器示例</th>
</tr>
</thead>
<tbody><tr>
<td>正常关闭</td>
<td>正确的4次挥手</td>
<td>FIN → ACK → FIN → ACK</td>
<td>延迟关闭，悬挂连接</td>
<td><code>tcp.flags.fin==1</code></td>
</tr>
<tr>
<td>RST关闭</td>
<td>突然终止连接</td>
<td>RST数据包</td>
<td>应用错误，超时，强制关闭</td>
<td><code>tcp.flags.reset==1</code></td>
</tr>
<tr>
<td>半关闭</td>
<td>一方关闭，另一方保持开放</td>
<td>仅一方发送FIN</td>
<td>应用协议错误，悬挂连接</td>
<td>见下方命令</td>
</tr>
<tr>
<td>超时关闭</td>
<td>连接因不活动而关闭</td>
<td>最后数据包后长时间静默</td>
<td>资源泄漏，僵尸连接</td>
<td>需要时间分析</td>
</tr>
</tbody></table>
<h3 id="连接关闭分析表"><a href="#连接关闭分析表" class="headerlink" title="连接关闭分析表"></a>连接关闭分析表</h3><table>
<thead>
<tr>
<th>问题</th>
<th>症状</th>
<th>可能原因</th>
<th>调查步骤</th>
</tr>
</thead>
<tbody><tr>
<td>过早连接关闭</td>
<td>事务完成前RST</td>
<td>服务器超时，应用错误</td>
<td>检查服务器超时设置，应用日志</td>
</tr>
<tr>
<td>客户端重置连接</td>
<td>客户端发送RST</td>
<td>客户端应用崩溃，超时</td>
<td>检查客户端应用行为</td>
</tr>
<tr>
<td>服务器重置连接</td>
<td>服务器发送RST</td>
<td>服务器过载，安全策略</td>
<td>检查服务器日志，安全策略</td>
</tr>
<tr>
<td>悬挂连接</td>
<td>无关闭数据包，连接空闲</td>
<td>应用错误，keep-alive问题</td>
<td>检查应用超时处理</td>
</tr>
<tr>
<td>不正确连接关闭</td>
<td>缺少FIN或ACK数据包</td>
<td>应用或库错误</td>
<td>检查应用的连接处理代码</td>
</tr>
</tbody></table>
<h3 id="连接关闭分析的tshark命令"><a href="#连接关闭分析的tshark命令" class="headerlink" title="连接关闭分析的tshark命令"></a>连接关闭分析的tshark命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找所有连接关闭</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.flags.fin==1 or tcp.flags.reset==1&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -e tcp.flags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找RST数据包</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.flags.reset==1&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -e tcp.flags.reset -e tcp.flags.ack</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析连接拆除序列</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.stream eq X and (tcp.flags.fin==1 or tcp.flags.reset==1)&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e ip.dst -e tcp.flags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找半关闭连接（需要手动分析）</span></span><br><span class="line">tshark -r capture.pcap -q -z <span class="string">&quot;follow,tcp,ascii&quot;</span> | grep -i <span class="string">&quot;fin\|reset\|close&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="TCP窗口问题"><a href="#TCP窗口问题" class="headerlink" title="TCP窗口问题"></a>TCP窗口问题</h2><table>
<thead>
<tr>
<th>窗口问题</th>
<th>描述</th>
<th>症状</th>
<th>潜在原因</th>
<th>tshark过滤器示例</th>
</tr>
</thead>
<tbody><tr>
<td>零窗口</td>
<td>接收方无法接受更多数据</td>
<td><code>tcp.analysis.zero_window</code>标志</td>
<td>接收方缓冲区已满，应用未读取</td>
<td><code>tcp.analysis.zero_window</code></td>
</tr>
<tr>
<td>零窗口探测</td>
<td>发送方检查窗口是否重新打开</td>
<td>零窗口期间发送小数据包</td>
<td>长时间零窗口条件</td>
<td><code>tcp.analysis.zero_window_probe</code></td>
</tr>
<tr>
<td>窗口已满</td>
<td>发送方填满接收窗口</td>
<td><code>tcp.analysis.window_full</code>标志</td>
<td>发送方传输过快</td>
<td><code>tcp.analysis.window_full</code></td>
</tr>
<tr>
<td>窗口更新</td>
<td>窗口大小变更通知</td>
<td>零&#x2F;小窗口后窗口大小增加</td>
<td>应用处理积压</td>
<td><code>tcp.analysis.window_update</code></td>
</tr>
<tr>
<td>窗口缩放</td>
<td>增加最大窗口大小</td>
<td>SYN包中的<code>tcp.options.wscale</code></td>
<td>不是问题，但对性能重要</td>
<td><code>tcp.options.wscale</code></td>
</tr>
</tbody></table>
<h3 id="窗口大小分析表"><a href="#窗口大小分析表" class="headerlink" title="窗口大小分析表"></a>窗口大小分析表</h3><table>
<thead>
<tr>
<th>问题</th>
<th>症状</th>
<th>可能原因</th>
<th>调查步骤</th>
</tr>
</thead>
<tbody><tr>
<td>持续零窗口</td>
<td>多次零窗口通知</td>
<td>接收方应用不读取数据</td>
<td>检查接收方应用性能</td>
</tr>
<tr>
<td>频繁窗口已满</td>
<td>多个窗口已满指示符</td>
<td>发送方传输过快，接收方过慢</td>
<td>检查带宽不匹配，应用处理</td>
</tr>
<tr>
<td>小窗口大小</td>
<td>窗口大小始终较小</td>
<td>应用以小块读取数据</td>
<td>优化应用缓冲</td>
</tr>
<tr>
<td>窗口缩放不匹配</td>
<td>不同的缩放因子，性能不佳</td>
<td>中间设备干扰，操作系统配置</td>
<td>检查端到端路径协议干扰</td>
</tr>
</tbody></table>
<h3 id="窗口分析的tshark命令"><a href="#窗口分析的tshark命令" class="headerlink" title="窗口分析的tshark命令"></a>窗口分析的tshark命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找零窗口条件</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.analysis.zero_window&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -e tcp.window_size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找窗口已满条件</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.analysis.window_full&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -e tcp.window_size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析窗口大小随时间变化</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.stream eq X&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e tcp.window_size -e tcp.analysis.window_update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查窗口缩放选项</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.flags.syn==1 and tcp.options.wscale&quot;</span> -T fields -e frame.number -e ip.src -e ip.dst -e tcp.options.wscale</span><br></pre></td></tr></table></figure>

<h2 id="捕获完整TCP流"><a href="#捕获完整TCP流" class="headerlink" title="捕获完整TCP流"></a>捕获完整TCP流</h2><h3 id="如何捕获和分析完整TCP流"><a href="#如何捕获和分析完整TCP流" class="headerlink" title="如何捕获和分析完整TCP流"></a>如何捕获和分析完整TCP流</h3><table>
<thead>
<tr>
<th>工具</th>
<th>命令语法</th>
<th>描述</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>tcpdump</td>
<td><code>tcpdump -i &lt;接口&gt; -s 0 -w capture.pcap host &lt;ip&gt; and port &lt;端口&gt;</code></td>
<td>将完整数据包捕获到文件</td>
<td>初始捕获</td>
</tr>
<tr>
<td>tshark流</td>
<td><code>tshark -r capture.pcap -q -z follow,tcp,ascii,&lt;流ID&gt;</code></td>
<td>提取TCP流的ASCII表示</td>
<td>基于文本的协议(HTTP, SMTP)</td>
</tr>
<tr>
<td>tshark流(十六进制)</td>
<td><code>tshark -r capture.pcap -q -z follow,tcp,hex,&lt;流ID&gt;</code></td>
<td>提取TCP流的十六进制转储</td>
<td>二进制协议</td>
</tr>
<tr>
<td>Wireshark</td>
<td>GUI: 统计 &gt; 会话 &gt; TCP &gt; 跟随流</td>
<td>交互式流跟踪</td>
<td>详细的可视化分析</td>
</tr>
<tr>
<td>tshark过滤器</td>
<td><code>tshark -r capture.pcap -Y &quot;tcp.stream eq &lt;ID&gt;&quot;</code></td>
<td>过滤特定流的数据包</td>
<td>集中分析</td>
</tr>
</tbody></table>
<h3 id="TCP流分析最佳实践"><a href="#TCP流分析最佳实践" class="headerlink" title="TCP流分析最佳实践"></a>TCP流分析最佳实践</h3><table>
<thead>
<tr>
<th>实践</th>
<th>描述</th>
<th>好处</th>
</tr>
</thead>
<tbody><tr>
<td>捕获完整数据包</td>
<td>使用tcpdump的<code>-s 0</code></td>
<td>确保捕获所有协议数据</td>
</tr>
<tr>
<td>使用BPF过滤器</td>
<td><code>host &lt;ip&gt; and port &lt;端口&gt;</code></td>
<td>减少捕获大小，专注于相关流量</td>
</tr>
<tr>
<td>存储到文件</td>
<td><code>-w capture.pcap</code></td>
<td>允许多次分析</td>
</tr>
<tr>
<td>环形缓冲区</td>
<td><code>-W 10 -C 100</code>（10个文件，每个100MB）</td>
<td>防止长时间捕获磁盘溢出</td>
</tr>
<tr>
<td>流枚举</td>
<td>首先识别流，然后分析每个流</td>
<td>复杂捕获的系统方法</td>
</tr>
<tr>
<td>协议解码</td>
<td><code>-d tcp.port==8080,http</code></td>
<td>正确的协议解释</td>
</tr>
</tbody></table>
<h3 id="常用tcpdump捕获命令"><a href="#常用tcpdump捕获命令" class="headerlink" title="常用tcpdump捕获命令"></a>常用tcpdump捕获命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 捕获特定端口上的所有TCP流量</span></span><br><span class="line">tcpdump -i eth0 -s 0 -w capture.pcap tcp port 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获特定客户端-服务器通信的流量</span></span><br><span class="line">tcpdump -i eth0 -s 0 -w capture.pcap host 192.168.1.10 and host 192.168.1.20 and tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用5元组过滤器捕获（协议，源IP，源端口，目标IP，目标端口）</span></span><br><span class="line">tcpdump -i eth0 -s 0 -w capture.pcap tcp and host 192.168.1.10 and port 80 and host 192.168.1.20 and port 12345</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用轮换文件捕获（10个文件，每个100MB）</span></span><br><span class="line">tcpdump -i eth0 -s 0 -W 10 -C 100 -w capture.pcap tcp port 80</span><br></pre></td></tr></table></figure>

<h3 id="常用tshark分析命令"><a href="#常用tshark分析命令" class="headerlink" title="常用tshark分析命令"></a>常用tshark分析命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出捕获中的所有TCP流</span></span><br><span class="line">tshark -r capture.pcap -q -z conv,tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取特定TCP流的ASCII表示</span></span><br><span class="line">tshark -r capture.pcap -q -z follow,tcp,ascii,0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取所有HTTP请求和响应</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -e http.request.method -e http.request.uri -e http.response.code</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析特定流的TCP序列号</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.stream eq 0&quot;</span> -T fields -e frame.number -e frame.time_relative -e tcp.seq -e tcp.ack -e tcp.len</span><br></pre></td></tr></table></figure>

<h2 id="常用命令示例"><a href="#常用命令示例" class="headerlink" title="常用命令示例"></a>常用命令示例</h2><p>本节提供常见故障排查场景的即用命令模板。</p>
<h3 id="一般网络故障排查"><a href="#一般网络故障排查" class="headerlink" title="一般网络故障排查"></a>一般网络故障排查</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 捕获eth0接口上的所有流量</span></span><br><span class="line">tcpdump -i eth0 -s 0 -w capture.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅捕获端口80（HTTP）或443（HTTPS）上的TCP流量</span></span><br><span class="line">tcpdump -i eth0 -s 0 -w capture.pcap <span class="string">&#x27;tcp port 80 or tcp port 443&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕获特定主机的流量</span></span><br><span class="line">tcpdump -i eth0 -s 0 -w capture.pcap host 192.168.1.10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析数据包长度分布</span></span><br><span class="line">tshark -r capture.pcap -q -z plen,tree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有IP会话</span></span><br><span class="line">tshark -r capture.pcap -q -z conv,ip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示HTTP响应时间统计</span></span><br><span class="line">tshark -r capture.pcap -q -z http,tree</span><br></pre></td></tr></table></figure>

<h3 id="性能故障排查"><a href="#性能故障排查" class="headerlink" title="性能故障排查"></a>性能故障排查</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找缓慢的HTTP响应（&gt;500ms）</span></span><br><span class="line">tshark -r capture.pcap -q -z io,<span class="built_in">stat</span>,0.5,<span class="string">&quot;COUNT(http.time) http.time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析TCP吞吐量随时间变化（1秒间隔）</span></span><br><span class="line">tshark -r capture.pcap -q -z io,<span class="built_in">stat</span>,1,<span class="string">&quot;SUM(frame.len)frame.len&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找数据包丢失指标</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.analysis.retransmission or tcp.analysis.duplicate_ack&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e ip.dst</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测网络延迟问题</span></span><br><span class="line">tshark -r capture.pcap -q -z io,<span class="built_in">stat</span>,1,<span class="string">&quot;AVG(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找TCP窗口限制</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.analysis.window_full or tcp.analysis.zero_window&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e ip.dst -e tcp.window_size</span><br></pre></td></tr></table></figure>

<h3 id="HTTP错误故障排查"><a href="#HTTP错误故障排查" class="headerlink" title="HTTP错误故障排查"></a>HTTP错误故障排查</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找所有HTTP错误</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http.response.code &gt;= 400&quot;</span> -T fields -e frame.number -e frame.time_relative -e http.response.code -e http.request.uri</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取有错误的完整HTTP会话</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http.response.code &gt;= 400&quot;</span> -T fields -e frame.number -e tcp.stream | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | <span class="built_in">sort</span> -u | xargs -I&#123;&#125; tshark -r capture.pcap -Y <span class="string">&quot;tcp.stream eq &#123;&#125;&quot;</span> -T fields -e frame.number -e frame.time_relative -e http.request.method -e http.request.uri -e http.response.code</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查HTTP协议违规</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http.response.code == 400&quot;</span> -T fields -e tcp.stream | <span class="built_in">sort</span> -u | xargs -I&#123;&#125; tshark -r capture.pcap -q -z follow,tcp,ascii,&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析特定请求的HTTP头</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;http.request.uri contains \&quot;/api/resource\&quot;&quot;</span> -T fields -e http.request.full_uri -e http.request.method -e http.user_agent -e http.authorization -e http.cookie</span><br></pre></td></tr></table></figure>

<h3 id="TCP连接问题"><a href="#TCP连接问题" class="headerlink" title="TCP连接问题"></a>TCP连接问题</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找失败的连接尝试</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.flags.syn==1 and !tcp.flags.ack==1 and !(tcp.flags.syn==1 and tcp.flags.ack==1)&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找连接重置</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.flags.reset==1&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析TCP连接状态</span></span><br><span class="line">tshark -r capture.pcap -q -z <span class="string">&quot;conv,tcp&quot;</span> | <span class="built_in">sort</span> -n -r -k 11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查半开放连接</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.flags.syn==1 and !tcp.ack&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport | awk <span class="string">&#x27;&#123;print $4,$6&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找异常终止的连接</span></span><br><span class="line">tshark -r capture.pcap -q -z <span class="string">&quot;follow,tcp,ascii&quot;</span> | grep -i <span class="string">&quot;reset\|refused\|aborted&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="高级协议分析"><a href="#高级协议分析" class="headerlink" title="高级协议分析"></a>高级协议分析</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分析TLS握手问题</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;ssl.handshake.type == 2 or ssl.handshake.type == 11 or ssl.alert&quot;</span> -T fields -e frame.number -e frame.time_relative -e ssl.handshake.type -e ssl.alert_message</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找DNS解析问题</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;dns.flags.rcode != 0&quot;</span> -T fields -e frame.number -e frame.time_relative -e dns.qry.name -e dns.flags.rcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># 识别分片问题</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;ip.flags.mf == 1 or ip.frag_offset &gt; 0&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e ip.dst -e ip.frag_offset -e ip.flags.mf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查TCP时间戳（对性能很重要）</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;tcp.options.timestamp.tsval&quot;</span> -T fields -e frame.number -e tcp.options.timestamp.tsval -e tcp.options.timestamp.tsecr | <span class="built_in">head</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找带IP选项的数据包（潜在网络问题）</span></span><br><span class="line">tshark -r capture.pcap -Y <span class="string">&quot;ip.options&quot;</span> -T fields -e frame.number -e frame.time_relative -e ip.src -e ip.dst -e ip.options</span><br></pre></td></tr></table></figure>

<h2 id="故障排查方法论"><a href="#故障排查方法论" class="headerlink" title="故障排查方法论"></a>故障排查方法论</h2><ol>
<li><p><strong>捕获正确的数据</strong>:</p>
<ul>
<li>识别受影响的主机&#x2F;服务</li>
<li>使用适当的BPF过滤器专注于相关流量</li>
<li>确保使用<code>-s 0</code>进行完整数据包捕获</li>
<li>在问题发生期间进行捕获</li>
</ul>
</li>
<li><p><strong>初步分析</strong>:</p>
<ul>
<li>检查HTTP错误（4xx&#x2F;5xx状态码）</li>
<li>查找TCP连接问题（建立失败，重置）</li>
<li>识别重传和重复ACK</li>
<li>检查响应时间和吞吐量</li>
</ul>
</li>
<li><p><strong>深入具体问题</strong>:</p>
<ul>
<li>按发生问题的特定TCP流进行过滤</li>
<li>分析完整的请求&#x2F;响应周期</li>
<li>检查窗口大小和缩放因子</li>
<li>查找应用层错误</li>
</ul>
</li>
<li><p><strong>性能分析</strong>:</p>
<ul>
<li>计算关键数据包之间的响应时间</li>
<li>测量吞吐量随时间变化</li>
<li>检查窗口限制</li>
<li>查找协议低效情况</li>
</ul>
</li>
<li><p><strong>记录发现</strong>:</p>
<ul>
<li>记录关键事件的数据包编号和时间戳</li>
<li>记录正常与异常行为</li>
<li>将网络观察与应用症状相关联</li>
<li>基于发现提出具体解决方案</li>
</ul>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.tcpdump.org/manpages/tcpdump.1.html">tcpdump手册</a></li>
<li><a href="https://www.wireshark.org/docs/man-pages/tshark.html">tshark手册</a></li>
<li><a href="https://www.wireshark.org/docs/man-pages/wireshark-filter.html">Wireshark显示过滤器</a></li>
<li><a href="https://biot.com/capstats/bpf.html">Berkeley数据包过滤器语法</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">HTTP状态码</a></li>
<li><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Protocol_operation">TCP状态机</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>大型PCAP文件分析最佳实践</title>
    <url>/2025/08/11/%E5%A4%A7%E5%9E%8BPCAP%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="大型PCAP文件分析最佳实践"><a href="#大型PCAP文件分析最佳实践" class="headerlink" title="大型PCAP文件分析最佳实践"></a>大型PCAP文件分析最佳实践</h1><p>本文档提供了分析大型PCAP（数据包捕获）文件的结构化方法，特别是如何根据特定时间定位问题。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E5%88%86%E6%9E%90%E5%A4%A7%E5%9E%8Bpcap%E6%96%87%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4">分析大型PCAP文件的步骤</a></li>
<li><a href="#%E6%A0%B9%E6%8D%AE%E7%89%B9%E5%AE%9A%E6%97%B6%E9%97%B4%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98">根据特定时间定位问题</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%92%8C%E5%91%BD%E4%BB%A4">常用工具和命令</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE">性能优化建议</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95">常见问题分析方法</a></li>
</ul>
<h2 id="分析大型PCAP文件的步骤"><a href="#分析大型PCAP文件的步骤" class="headerlink" title="分析大型PCAP文件的步骤"></a>分析大型PCAP文件的步骤</h2><p>大型PCAP文件分析应该遵循从宏观到微观的策略，先了解整体情况，再深入具体问题：</p>
<h3 id="1-预处理和初步了解"><a href="#1-预处理和初步了解" class="headerlink" title="1. 预处理和初步了解"></a>1. 预处理和初步了解</h3><ul>
<li><p><strong>检查文件基本信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">capinfos large_capture.pcap</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看数据包统计信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -r large_capture.pcap -qn | <span class="built_in">wc</span> -l  <span class="comment"># 计算总数据包数</span></span><br><span class="line">tcpdump -r large_capture.pcap -qtnp | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | <span class="built_in">sort</span> -nr  <span class="comment"># 查看IP地址分布</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取捕获的时间范围</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r large_capture.pcap -T fields -e frame.time | <span class="built_in">head</span> -1  <span class="comment"># 捕获开始时间</span></span><br><span class="line">tshark -r large_capture.pcap -T fields -e frame.time | <span class="built_in">tail</span> -1  <span class="comment"># 捕获结束时间</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-分割和提取"><a href="#2-分割和提取" class="headerlink" title="2. 分割和提取"></a>2. 分割和提取</h3><ul>
<li><p><strong>按时间分割大文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">editcap -A <span class="string">&quot;2025-08-11 15:30:00&quot;</span> -B <span class="string">&quot;2025-08-11 15:35:00&quot;</span> large_capture.pcap time_window.pcap</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>按协议提取特定流量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -r large_capture.pcap -w http_only.pcap <span class="string">&#x27;tcp port 80 or tcp port 443&#x27;</span></span><br><span class="line">tcpdump -r large_capture.pcap -w dns_only.pcap <span class="string">&#x27;udp port 53&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>按会话提取特定流量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -r large_capture.pcap -w specific_conv.pcap <span class="string">&#x27;host 192.168.1.100 and host 192.168.1.200&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-初步分析"><a href="#3-初步分析" class="headerlink" title="3. 初步分析"></a>3. 初步分析</h3><ul>
<li><p><strong>识别主要协议分布</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r large_capture.pcap -q -z io,phs</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>识别高流量主机</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r large_capture.pcap -q -z endpoints,ip</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查找错误和异常</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r large_capture.pcap -Y <span class="string">&quot;tcp.analysis.flags&quot;</span> -T fields -e frame.number -e frame.time -e ip.src -e ip.dst -e tcp.analysis.flags</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-深入分析"><a href="#4-深入分析" class="headerlink" title="4. 深入分析"></a>4. 深入分析</h3><ul>
<li><p><strong>分析特定连接</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r large_capture.pcap -Y <span class="string">&quot;ip.addr==192.168.1.100 &amp;&amp; ip.addr==192.168.1.200&quot;</span> -O tcp</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提取应用层数据</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r large_capture.pcap -Y <span class="string">&quot;http&quot;</span> -T fields -e frame.time -e ip.src -e http.request.method -e http.request.uri -e http.response.code</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分析TCP会话性能</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r large_capture.pcap -q -z conv,tcp</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-可视化和图形分析"><a href="#5-可视化和图形分析" class="headerlink" title="5. 可视化和图形分析"></a>5. 可视化和图形分析</h3><ul>
<li><strong>使用Wireshark图形界面</strong>进行交互式分析</li>
<li><strong>使用termshark</strong>进行终端内图形分析</li>
<li><strong>构建流量图表</strong>：使用tshark导出数据后利用Python或R进行可视化</li>
</ul>
<h2 id="根据特定时间定位问题"><a href="#根据特定时间定位问题" class="headerlink" title="根据特定时间定位问题"></a>根据特定时间定位问题</h2><p>在网络问题排查中，时间是关键线索。以下是根据时间定位问题的有效方法：</p>
<h3 id="1-时间窗口提取"><a href="#1-时间窗口提取" class="headerlink" title="1. 时间窗口提取"></a>1. 时间窗口提取</h3><ul>
<li><p><strong>提取特定时间窗口的流量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提取2025年8月11日15:30到15:35之间的所有数据包</span></span><br><span class="line">editcap -A <span class="string">&quot;2025-08-11 15:30:00&quot;</span> -B <span class="string">&quot;2025-08-11 15:35:00&quot;</span> large_capture.pcap time_window.pcap</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过精确的开始结束时间戳提取</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提取时间戳在1691757000到1691757300之间的数据包</span></span><br><span class="line">tcpdump -r large_capture.pcap -w time_slice.pcap <span class="string">&quot;frame.time_epoch &gt;= 1691757000 and frame.time_epoch &lt;= 1691757300&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-基于时间的过滤"><a href="#2-基于时间的过滤" class="headerlink" title="2. 基于时间的过滤"></a>2. 基于时间的过滤</h3><ul>
<li><strong>使用tcpdump过滤特定时间点附近的数据包</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看特定时间点前后5秒的数据包</span></span><br><span class="line">tshark -r large_capture.pcap -Y <span class="string">&quot;frame.time &gt;= \&quot;2025-08-11 15:30:45\&quot; and frame.time &lt;= \&quot;2025-08-11 15:30:55\&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-构建时间轴分析"><a href="#3-构建时间轴分析" class="headerlink" title="3. 构建时间轴分析"></a>3. 构建时间轴分析</h3><ul>
<li><p><strong>生成关键事件的时间轴</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提取HTTP错误响应并按时间排序</span></span><br><span class="line">tshark -r large_capture.pcap -Y <span class="string">&quot;http.response.code &gt;= 400&quot;</span> -T fields -e frame.time -e ip.src -e http.response.code -e http.request.uri</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分析特定时间前后的TCP重传</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找目标时间段内的TCP重传</span></span><br><span class="line">tshark -r large_capture.pcap -Y <span class="string">&quot;tcp.analysis.retransmission and frame.time &gt;= \&quot;2025-08-11 15:30:00\&quot; and frame.time &lt;= \&quot;2025-08-11 15:31:00\&quot;&quot;</span> -T fields -e frame.time -e ip.src -e ip.dst</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-并行事件分析"><a href="#4-并行事件分析" class="headerlink" title="4. 并行事件分析"></a>4. 并行事件分析</h3><ul>
<li><strong>比较不同协议在同一时间窗口的行为</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提取相同时间段内的DNS查询和HTTP请求</span></span><br><span class="line">tshark -r large_capture.pcap -Y <span class="string">&quot;(dns or http) and frame.time &gt;= \&quot;2025-08-11 15:30:00\&quot; and frame.time &lt;= \&quot;2025-08-11 15:31:00\&quot;&quot;</span> -T fields -e frame.time -e frame.protocols</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-识别时间异常"><a href="#5-识别时间异常" class="headerlink" title="5. 识别时间异常"></a>5. 识别时间异常</h3><ul>
<li><strong>找出响应时间异常的请求</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分析HTTP请求-响应对，找出延迟高的交互</span></span><br><span class="line">tshark -r large_capture.pcap -q -z http,tree</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="常用工具和命令"><a href="#常用工具和命令" class="headerlink" title="常用工具和命令"></a>常用工具和命令</h2><h3 id="基础工具"><a href="#基础工具" class="headerlink" title="基础工具"></a>基础工具</h3><ol>
<li><p><strong>tcpdump</strong> - 命令行数据包分析器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">tcpdump -r file.pcap [filter]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看HTTP流量</span></span><br><span class="line">tcpdump -r file.pcap -s 0 -A <span class="string">&#x27;tcp port 80&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加时间戳</span></span><br><span class="line">tcpdump -r file.pcap -tttt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>tshark</strong> - Wireshark的命令行版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">tshark -r file.pcap [options] [filter]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取特定字段</span></span><br><span class="line">tshark -r file.pcap -T fields -e ip.src -e ip.dst -e tcp.srcport -e tcp.dstport</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计分析</span></span><br><span class="line">tshark -r file.pcap -q -z io,phs</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Wireshark</strong> - 图形界面分析工具</p>
<ul>
<li>强大的过滤功能</li>
<li>色彩编码的数据包</li>
<li>协议解析</li>
<li>会话追踪功能</li>
</ul>
</li>
<li><p><strong>termshark</strong> - 终端中的类Wireshark界面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">termshark -r file.pcap</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>tcpflow</strong> - 重建和提取TCP会话</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpflow -r file.pcap -o output_dir</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="专业工具"><a href="#专业工具" class="headerlink" title="专业工具"></a>专业工具</h3><ol>
<li><p><strong>editcap</strong> - 编辑和转换捕获文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按时间分割</span></span><br><span class="line">editcap -A <span class="string">&quot;2025-08-11 15:30:00&quot;</span> -B <span class="string">&quot;2025-08-11 15:35:00&quot;</span> input.pcap output.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按数量分割</span></span><br><span class="line">editcap -c 1000 input.pcap output.pcap</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>capinfos</strong> - 显示捕获文件信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">capinfos file.pcap</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mergecap</strong> - 合并捕获文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mergecap -w merged.pcap input1.pcap input2.pcap</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>TraceWrangler</strong> - 大型捕获文件处理工具</p>
</li>
<li><p><strong>NetworkMiner</strong> - 网络取证分析工具</p>
</li>
</ol>
<h2 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h2><p>处理大型PCAP文件时的性能优化：</p>
<ol>
<li><p><strong>硬件考虑</strong></p>
<ul>
<li>使用SSD存储加速读取</li>
<li>增加RAM以处理大文件</li>
<li>利用多核处理器进行并行分析</li>
</ul>
</li>
<li><p><strong>分析策略</strong></p>
<ul>
<li>先分割成小文件再分析</li>
<li>使用命令行工具替代图形界面处理初步分析</li>
<li>限制提取的数据包数量和字段</li>
</ul>
</li>
<li><p><strong>索引和缓存</strong></p>
<ul>
<li>为大型PCAP文件创建索引<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用Wireshark创建索引</span></span><br><span class="line">tshark -r large_capture.pcap -o <span class="string">&quot;gui.column.format:\&quot;Time\&quot;,\&quot;%t\&quot;&quot;</span> -w indexed_capture.pcapng</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用流式处理</strong></p>
<ul>
<li>避免一次性加载整个文件</li>
<li>利用管道处理数据<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpdump -r large_capture.pcap | grep <span class="string">&quot;pattern&quot;</span> | <span class="built_in">head</span> -100</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="常见问题分析方法"><a href="#常见问题分析方法" class="headerlink" title="常见问题分析方法"></a>常见问题分析方法</h2><h3 id="网络延迟问题"><a href="#网络延迟问题" class="headerlink" title="网络延迟问题"></a>网络延迟问题</h3><ol>
<li><p><strong>TCP往返时间分析</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r large_capture.pcap -q -z io,<span class="built_in">stat</span>,0.1,<span class="string">&quot;SUM(tcp.analysis.ack_rtt)tcp.analysis.ack_rtt&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查找连接建立延迟</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r large_capture.pcap -Y <span class="string">&quot;tcp.flags.syn==1&quot;</span> -T fields -e frame.time -e tcp.time_delta</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="连接问题"><a href="#连接问题" class="headerlink" title="连接问题"></a>连接问题</h3><ol>
<li><p><strong>查找TCP重置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r large_capture.pcap -Y <span class="string">&quot;tcp.flags.reset==1&quot;</span> -T fields -e frame.time -e ip.src -e ip.dst</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分析TCP连接建立失败</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r large_capture.pcap -Y <span class="string">&quot;tcp.flags.syn==1 and !tcp.analysis.duplicate_ack&quot;</span> -T fields -e frame.number -e frame.time -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="应用层问题"><a href="#应用层问题" class="headerlink" title="应用层问题"></a>应用层问题</h3><ol>
<li><p><strong>HTTP错误分析</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r large_capture.pcap -Y <span class="string">&quot;http.response.code &gt;= 400&quot;</span> -T fields -e frame.time -e ip.src -e http.response.code -e http.request.uri</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DNS解析问题</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tshark -r large_capture.pcap -Y <span class="string">&quot;dns.flags.rcode != 0&quot;</span> -T fields -e frame.time -e ip.src -e dns.qry.name -e dns.flags.rcode</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>tcpkill工作原理</title>
    <url>/2025/08/13/tcpkill%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="tcpkill-工作原理"><a href="#tcpkill-工作原理" class="headerlink" title="tcpkill 工作原理"></a>tcpkill 工作原理</h2><p><code>tcpkill</code> 是一个网络工具，用于强制终止 TCP 连接。其工作机制如下：</p>
<ol>
<li><strong>监听网络流量</strong>：在指定网络接口上监听符合过滤条件的数据包</li>
<li><strong>伪造 RST 包</strong>：当检测到目标连接的数据包时，立即伪造 TCP RST（Reset）包</li>
<li><strong>双向发送</strong>：同时向连接的两端发送 RST 包，确保连接被彻底终止</li>
</ol>
<h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装 sudo yun install -y dsniff</span></span><br><span class="line"><span class="built_in">sudo</span> tcpkill -i eth0 host 11.123.253.133 and port 80</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-i eth0</code>：在 eth0 网络接口上监听</li>
<li><code>host 11.123.253.133 and port 80</code>：过滤条件，只处理涉及 IP 11.123.253.133 且端口为 80 的连接</li>
</ul>
<h2 id="tcpkill-输出解释"><a href="#tcpkill-输出解释" class="headerlink" title="tcpkill 输出解释"></a>tcpkill 输出解释</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpkill: listening on eth0 [host 11.123.253.133 and port 80]</span><br><span class="line">11.123.253.133:80 &gt; 172.22.3.89:46890: R 434213725:434213725(0) win 0</span><br><span class="line">11.123.253.133:80 &gt; 172.22.3.89:46890: R 434214227:434214227(0) win 0</span><br><span class="line">11.123.253.133:80 &gt; 172.22.3.89:46890: R 434215231:434215231(0) win 0</span><br><span class="line">172.22.3.89:46890 &gt; 11.123.253.133:80: R 599879870:599879870(0) win 0</span><br><span class="line">172.22.3.89:46890 &gt; 11.123.253.133:80: R 599880372:599880372(0) win 0</span><br><span class="line">172.22.3.89:46890 &gt; 11.123.253.133:80: R 599881376:599881376(0) win 0</span><br></pre></td></tr></table></figure>

<p>每行格式：<code>源IP:端口 &gt; 目标IP:端口: R 序列号:序列号(数据长度) win 窗口大小</code></p>
<ul>
<li><code>R</code>：表示 RST（Reset）标志位</li>
<li>序列号：TCP 序列号，tcpkill 会尝试不同的序列号以确保 RST 包被接受</li>
<li><code>(0)</code>：数据长度为 0</li>
<li><code>win 0</code>：窗口大小为 0</li>
</ul>
<h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>从您提供的抓包数据可以看出完整的攻击过程：</p>
<h3 id="1-正常通信阶段"><a href="#1-正常通信阶段" class="headerlink" title="1. 正常通信阶段"></a>1. 正常通信阶段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:40:00.911181 - 服务器发送 HTTP 数据 (73 字节)</span><br><span class="line">11:40:00.911221 - 客户端发送 ACK 确认</span><br></pre></td></tr></table></figure>

<h3 id="2-RST-攻击阶段"><a href="#2-RST-攻击阶段" class="headerlink" title="2. RST 攻击阶段"></a>2. RST 攻击阶段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:40:01.310146 开始 - tcpkill 发送多个 RST 包</span><br></pre></td></tr></table></figure>

<p><strong>关键观察点</strong>：</p>
<ol>
<li><strong>TTL 变化</strong>：正常包 TTL&#x3D;51，RST 包 TTL&#x3D;64，说明 RST 包是本地伪造的</li>
<li><strong>序列号策略</strong>：tcpkill 发送多个不同序列号的 RST 包，增加成功率</li>
<li><strong>双向攻击</strong>：既伪造服务器向客户端发送 RST，也伪造客户端向服务器发送 RST</li>
<li><strong>时间差</strong>：RST 包在正常通信后约 0.4 秒发送</li>
</ol>
<h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><p><strong>为什么发送多个 RST 包？</strong></p>
<ul>
<li>TCP 只接受序列号在有效窗口范围内的 RST 包</li>
<li>tcpkill 通过发送不同序列号的 RST 包来提高成功概率</li>
<li>从抓包可见，序列号呈递增趋势（434213725 → 434214227 → 434215231）</li>
</ul>
<p><strong>双向攻击的意义</strong>：</p>
<ul>
<li>确保连接两端都收到 RST 包</li>
<li>即使一方的 RST 包被过滤，另一方仍可能生效</li>
<li>提高攻击成功率</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>网络故障模拟工具及常用命令</title>
    <url>/2025/08/13/%E7%BD%91%E7%BB%9C%E6%95%85%E9%9A%9C%E6%A8%A1%E6%8B%9F%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="网络故障模拟工具与常用命令"><a href="#网络故障模拟工具与常用命令" class="headerlink" title="网络故障模拟工具与常用命令"></a>网络故障模拟工具与常用命令</h1><p>本文档提供了一系列网络故障模拟工具和常用命令，用于测试应用程序在各种网络条件下的行为，特别是长连接（如SSE、WebSocket）的稳定性测试。</p>
<h2 id="1-常用网络故障模拟工具对比"><a href="#1-常用网络故障模拟工具对比" class="headerlink" title="1. 常用网络故障模拟工具对比"></a>1. 常用网络故障模拟工具对比</h2><table>
<thead>
<tr>
<th>工具名称</th>
<th>主要功能</th>
<th>优势</th>
<th>局限性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>tc&#x2F;netem</strong></td>
<td>延迟、丢包、重排、复制、损坏</td>
<td>内置Linux内核，精确控制</td>
<td>配置较复杂</td>
<td>全面的网络条件模拟</td>
</tr>
<tr>
<td><strong>iptables</strong></td>
<td>过滤、拦截、重定向</td>
<td>灵活精确，低级别控制</td>
<td>语法复杂</td>
<td>精确控制特定连接</td>
</tr>
<tr>
<td><strong>tcpkill</strong></td>
<td>中断TCP连接</td>
<td>简单直接</td>
<td>功能单一</td>
<td>模拟连接中断</td>
</tr>
<tr>
<td><strong>Comcast</strong></td>
<td>延迟、带宽限制、丢包等</td>
<td>简单易用，GUI工具也有</td>
<td>精度不如tc</td>
<td>快速简易测试</td>
</tr>
<tr>
<td><strong>toxiproxy</strong></td>
<td>延迟、带宽限制、超时、中断等</td>
<td>提供API，易于集成</td>
<td>需要单独部署</td>
<td>CI&#x2F;CD集成测试</td>
</tr>
<tr>
<td><strong>Charles&#x2F;Fiddler</strong></td>
<td>流量拦截、修改、限速</td>
<td>图形界面，易于使用</td>
<td>主要针对HTTP(S)</td>
<td>应用层协议测试</td>
</tr>
<tr>
<td><strong>WANem</strong></td>
<td>全面网络模拟</td>
<td>开箱即用，界面友好</td>
<td>需要独立设备&#x2F;VM</td>
<td>完整WAN环境模拟</td>
</tr>
</tbody></table>
<h2 id="2-tc-Traffic-Control-详解"><a href="#2-tc-Traffic-Control-详解" class="headerlink" title="2. tc (Traffic Control) 详解"></a>2. tc (Traffic Control) 详解</h2><p><code>tc</code>是Linux内核的流量控制工具，通过<code>netem</code>模块可以模拟各种网络条件。这是最强大、最灵活的网络故障模拟工具。</p>
<h3 id="基本使用模式"><a href="#基本使用模式" class="headerlink" title="基本使用模式"></a>基本使用模式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查找 dnf search iproute</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install iproute-tc -y</span><br><span class="line">tc -V</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">tc qdisc add dev INTERFACE root netem PARAMETER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换现有规则</span></span><br><span class="line">tc qdisc change dev INTERFACE root netem PARAMETER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除规则</span></span><br><span class="line">tc qdisc del dev INTERFACE root</span><br></pre></td></tr></table></figure>

<h3 id="模拟常见网络问题的命令"><a href="#模拟常见网络问题的命令" class="headerlink" title="模拟常见网络问题的命令"></a>模拟常见网络问题的命令</h3><h4 id="1-延迟模拟"><a href="#1-延迟模拟" class="headerlink" title="1. 延迟模拟"></a>1. 延迟模拟</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加固定延迟(100ms)</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 100ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加延迟及抖动(100ms ±10ms)</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 100ms 10ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加正态分布的延迟</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 100ms 20ms distribution normal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加相关性延迟(上一个包的延迟对当前包有25%影响)</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 100ms 10ms 25%</span><br></pre></td></tr></table></figure>

<h4 id="2-丢包模拟"><a href="#2-丢包模拟" class="headerlink" title="2. 丢包模拟"></a>2. 丢包模拟</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机丢包(10%)</span></span><br><span class="line">tc qdisc add dev eth0 root netem loss 10%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于状态的丢包模型(Gilbert-Elliott)</span></span><br><span class="line">tc qdisc add dev eth0 root netem loss gemodel 10% 50% 70% 20%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 丢包与成功相关</span></span><br><span class="line">tc qdisc add dev eth0 root netem loss 10% 25%</span><br></pre></td></tr></table></figure>

<h4 id="3-数据包损坏"><a href="#3-数据包损坏" class="headerlink" title="3. 数据包损坏"></a>3. 数据包损坏</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机损坏5%的数据包</span></span><br><span class="line">tc qdisc add dev eth0 root netem corrupt 5%</span><br></pre></td></tr></table></figure>

<h4 id="4-数据包重复"><a href="#4-数据包重复" class="headerlink" title="4. 数据包重复"></a>4. 数据包重复</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机重复1%的数据包</span></span><br><span class="line">tc qdisc add dev eth0 root netem duplicate 1%</span><br></pre></td></tr></table></figure>

<h4 id="5-数据包乱序"><a href="#5-数据包乱序" class="headerlink" title="5. 数据包乱序"></a>5. 数据包乱序</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 25%的数据包将被延迟10ms以造成乱序</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 10ms reorder 25% 50%</span><br></pre></td></tr></table></figure>

<h4 id="6-带宽限制"><a href="#6-带宽限制" class="headerlink" title="6. 带宽限制"></a>6. 带宽限制</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 限制带宽为1Mbit/s</span></span><br><span class="line">tc qdisc add dev eth0 root tbf rate 1mbit burst 32kbit latency 400ms</span><br></pre></td></tr></table></figure>

<h4 id="7-组合多种故障"><a href="#7-组合多种故障" class="headerlink" title="7. 组合多种故障"></a>7. 组合多种故障</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 组合延迟、丢包和乱序</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 100ms 10ms distribution normal loss 5% reorder 25%</span><br></pre></td></tr></table></figure>

<h4 id="8-精确模拟TCP重传"><a href="#8-精确模拟TCP重传" class="headerlink" title="8. 精确模拟TCP重传"></a>8. 精确模拟TCP重传</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过组合延迟和随机丢包来触发重传</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 200ms loss random 15%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟网络拥塞</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 100ms 50ms loss 5% 25%</span><br></pre></td></tr></table></figure>

<h3 id="针对特定流量的故障模拟"><a href="#针对特定流量的故障模拟" class="headerlink" title="针对特定流量的故障模拟"></a>针对特定流量的故障模拟</h3><p>使用tc与iptables结合，可以只对特定流量应用网络故障模拟：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建标记特定流量的iptables规则</span></span><br><span class="line">iptables -A FORWARD -t mangle -p tcp --dport 80 -j MARK --set-mark 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为标记的流量创建队列规则</span></span><br><span class="line">tc qdisc add dev eth0 root handle 1: prio</span><br><span class="line">tc qdisc add dev eth0 parent 1:3 handle 30: netem delay 100ms loss 10%</span><br><span class="line">tc filter add dev eth0 protocol ip parent 1:0 prio 3 handle 1 fw flowid 1:3</span><br></pre></td></tr></table></figure>

<h2 id="3-iptables-模拟网络故障"><a href="#3-iptables-模拟网络故障" class="headerlink" title="3. iptables 模拟网络故障"></a>3. iptables 模拟网络故障</h2><p>iptables可以用于模拟网络层面的多种故障，尤其擅长精确控制特定连接。</p>
<h3 id="RST包和连接重置"><a href="#RST包和连接重置" class="headerlink" title="RST包和连接重置"></a>RST包和连接重置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向特定连接发送RST包</span></span><br><span class="line">iptables -A OUTPUT -p tcp -d 192.168.1.100 --dport 80 -j REJECT --reject-with tcp-reset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只针对特定条件的连接发送RST</span></span><br><span class="line">iptables -A OUTPUT -p tcp -d 192.168.1.100 --dport 80 -m statistic --mode random --probability 0.3 -j REJECT --reject-with tcp-reset</span><br></pre></td></tr></table></figure>

<h3 id="丢弃数据包"><a href="#丢弃数据包" class="headerlink" title="丢弃数据包"></a>丢弃数据包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 丢弃所有发往特定主机端口的数据包</span></span><br><span class="line">iptables -A FORWARD -p tcp -d 192.168.1.100 --dport 80 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 丢弃30%的数据包(随机)</span></span><br><span class="line">iptables -A FORWARD -p tcp -d 192.168.1.100 -m statistic --mode random --probability 0.3 -j DROP</span><br></pre></td></tr></table></figure>

<h3 id="限制连接数"><a href="#限制连接数" class="headerlink" title="限制连接数"></a>限制连接数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 限制同时连接数</span></span><br><span class="line">iptables -A FORWARD -p tcp --syn --dport 80 -m connlimit --connlimit-above 10 -j DROP</span><br></pre></td></tr></table></figure>

<h3 id="模拟防火墙策略变更"><a href="#模拟防火墙策略变更" class="headerlink" title="模拟防火墙策略变更"></a>模拟防火墙策略变更</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 突然阻断所有连接</span></span><br><span class="line">iptables -I FORWARD 1 -j DROP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 之后移除此规则恢复连接</span></span><br><span class="line">iptables -D FORWARD 1</span><br></pre></td></tr></table></figure>

<h2 id="4-tcpkill-及相关工具详解"><a href="#4-tcpkill-及相关工具详解" class="headerlink" title="4. tcpkill 及相关工具详解"></a>4. tcpkill 及相关工具详解</h2><p>tcpkill属于dsniff工具集，主要用于中断TCP连接，但功能相对单一。同一工具集的其他工具可以模拟更多类型的网络攻击。</p>
<h3 id="tcpkill-基本用法"><a href="#tcpkill-基本用法" class="headerlink" title="tcpkill 基本用法"></a>tcpkill 基本用法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 中断所有到达特定主机和端口的连接</span></span><br><span class="line">tcpkill -i eth0 host 192.168.1.100 and port 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中断指定协议的连接</span></span><br><span class="line">tcpkill -i eth0 port 443 and tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中断特定源IP发起的连接</span></span><br><span class="line">tcpkill -i eth0 src 10.0.0.1 and dst port 22</span><br></pre></td></tr></table></figure>

<h3 id="tcpkill-能模拟的其他攻击"><a href="#tcpkill-能模拟的其他攻击" class="headerlink" title="tcpkill 能模拟的其他攻击"></a>tcpkill 能模拟的其他攻击</h3><p>tcpkill本身功能有限，主要用于发送RST包中断连接。但dsniff工具集中的其他工具可以模拟更多攻击：</p>
<ol>
<li><p><strong>tcpnice</strong>: 通过操纵TCP窗口大小降低连接速度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcpnice -i eth0 host target.example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>filesnarf</strong>: 捕获NFS文件传输</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filesnarf -i eth0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mailsnarf</strong>: 捕获邮件内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mailsnarf -i eth0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>msgsnarf</strong>: 捕获即时通讯消息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msgsnarf -i eth0</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="tcpreplay-回放捕获的数据包"><a href="#tcpreplay-回放捕获的数据包" class="headerlink" title="tcpreplay: 回放捕获的数据包"></a>tcpreplay: 回放捕获的数据包</h3><p>tcpreplay可以重放之前捕获的数据包，用于模拟各种网络场景：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回放之前捕获的数据包</span></span><br><span class="line">tcpreplay -i eth0 capture.pcap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整回放速度</span></span><br><span class="line">tcpreplay -M 10.0 -i eth0 capture.pcap  <span class="comment"># 10倍速播放</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环播放</span></span><br><span class="line">tcpreplay -l 5 -i eth0 capture.pcap  <span class="comment"># 播放5次</span></span><br></pre></td></tr></table></figure>

<h2 id="5-其他高级网络模拟工具"><a href="#5-其他高级网络模拟工具" class="headerlink" title="5. 其他高级网络模拟工具"></a>5. 其他高级网络模拟工具</h2><h3 id="1-Toxiproxy"><a href="#1-Toxiproxy" class="headerlink" title="1. Toxiproxy"></a>1. Toxiproxy</h3><p>Toxiproxy是一个为测试设计的代理服务，可以模拟各种网络条件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动toxiproxy服务</span></span><br><span class="line">toxiproxy-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建代理</span></span><br><span class="line">toxiproxy-cli create myproxy --listen 0.0.0.0:8474 --upstream example.com:80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加延迟</span></span><br><span class="line">toxiproxy-cli toxic add myproxy -t latency -a latency=1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加随机延迟</span></span><br><span class="line">toxiproxy-cli toxic add myproxy -t latency -a jitter=500</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制带宽</span></span><br><span class="line">toxiproxy-cli toxic add myproxy -t bandwidth -a rate=100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟断开连接</span></span><br><span class="line">toxiproxy-cli toxic add myproxy -t <span class="built_in">timeout</span> -a <span class="built_in">timeout</span>=5000</span><br></pre></td></tr></table></figure>

<h3 id="2-Comcast"><a href="#2-Comcast" class="headerlink" title="2. Comcast"></a>2. Comcast</h3><p>一个简单易用的网络条件模拟工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">go get github.com/tylertreat/comcast</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加延迟和丢包</span></span><br><span class="line">comcast --device=eth0 --latency=250 --packet-loss=10%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止模拟</span></span><br><span class="line">comcast --stop</span><br></pre></td></tr></table></figure>

<h3 id="3-pumba-Docker环境"><a href="#3-pumba-Docker环境" class="headerlink" title="3. pumba (Docker环境)"></a>3. pumba (Docker环境)</h3><p>专门为Docker容器设计的网络混沌测试工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为指定容器添加延迟</span></span><br><span class="line">pumba netem --interface eth0 delay --time 3000 my_container</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟网络中断</span></span><br><span class="line">pumba netem --interface eth0 loss --percent 100 --correlation 100 my_container</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制带宽</span></span><br><span class="line">pumba netem --interface eth0 rate --rate 1kbit my_container</span><br></pre></td></tr></table></figure>

<h3 id="4-Chaos-Mesh-Kubernetes环境"><a href="#4-Chaos-Mesh-Kubernetes环境" class="headerlink" title="4. Chaos Mesh (Kubernetes环境)"></a>4. Chaos Mesh (Kubernetes环境)</h3><p>为Kubernetes设计的混沌工程平台：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网络延迟示例</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">chaos-mesh.org/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkChaos</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">network-delay-example</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">action:</span> <span class="string">delay</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">one</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">namespaces:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">labelSelectors:</span></span><br><span class="line">      <span class="attr">&quot;app&quot;:</span> <span class="string">&quot;web-server&quot;</span></span><br><span class="line">  <span class="attr">delay:</span></span><br><span class="line">    <span class="attr">latency:</span> <span class="string">&quot;10ms&quot;</span></span><br><span class="line">    <span class="attr">correlation:</span> <span class="string">&quot;100&quot;</span></span><br><span class="line">    <span class="attr">jitter:</span> <span class="string">&quot;0ms&quot;</span></span><br><span class="line">  <span class="attr">duration:</span> <span class="string">&quot;30s&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-具体网络问题模拟方案"><a href="#6-具体网络问题模拟方案" class="headerlink" title="6. 具体网络问题模拟方案"></a>6. 具体网络问题模拟方案</h2><h3 id="模拟TCP重传"><a href="#模拟TCP重传" class="headerlink" title="模拟TCP重传"></a>模拟TCP重传</h3><p>TCP重传通常是由丢包、超时或网络拥塞引起的。要模拟TCP重传：</p>
<h4 id="使用tc模拟"><a href="#使用tc模拟" class="headerlink" title="使用tc模拟:"></a>使用tc模拟:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机丢包引起的重传</span></span><br><span class="line">tc qdisc add dev eth0 root netem loss random 10%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拥塞引起的重传</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 100ms 40ms distribution normal loss 5% 25%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅对特定流量引起重传</span></span><br><span class="line">tc qdisc add dev eth0 root handle 1: prio</span><br><span class="line">tc qdisc add dev eth0 parent 1:3 handle 30: netem loss 15%</span><br><span class="line">tc filter add dev eth0 parent 1: protocol ip prio 3 u32 match ip dport 80 0xffff flowid 1:3</span><br></pre></td></tr></table></figure>

<h4 id="验证重传是否发生"><a href="#验证重传是否发生" class="headerlink" title="验证重传是否发生:"></a>验证重传是否发生:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用tcpdump观察重传</span></span><br><span class="line">tcpdump -i eth0 -nn <span class="string">&quot;tcp[tcpflags] &amp; (tcp-syn|tcp-fin|tcp-rst|tcp-push) != 0 and port 80&quot;</span> -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找标记为&quot;retransmission&quot;的数据包</span></span><br><span class="line">tcpdump -i eth0 -v tcp | grep -i retransmission</span><br></pre></td></tr></table></figure>

<h3 id="模拟网络分区"><a href="#模拟网络分区" class="headerlink" title="模拟网络分区"></a>模拟网络分区</h3><p>网络分区是指网络被分割成多个无法相互通信的部分：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用iptables模拟网络分区</span></span><br><span class="line">iptables -A FORWARD -s 192.168.1.0/24 -d 192.168.2.0/24 -j DROP</span><br><span class="line">iptables -A FORWARD -s 192.168.2.0/24 -d 192.168.1.0/24 -j DROP</span><br></pre></td></tr></table></figure>

<h3 id="模拟慢启动和拥塞控制"><a href="#模拟慢启动和拥塞控制" class="headerlink" title="模拟慢启动和拥塞控制"></a>模拟慢启动和拥塞控制</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 限制初始拥塞窗口大小</span></span><br><span class="line">ip route change default via 192.168.1.1 dev eth0 initcwnd 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复默认设置</span></span><br><span class="line">ip route change default via 192.168.1.1 dev eth0 initcwnd 10</span><br></pre></td></tr></table></figure>

<h3 id="模拟网络风暴"><a href="#模拟网络风暴" class="headerlink" title="模拟网络风暴"></a>模拟网络风暴</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用hping3模拟SYN泛洪</span></span><br><span class="line">hping3 -S --flood -p 80 target.example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用iperf3模拟高流量</span></span><br><span class="line">iperf3 -c target.example.com -b 1G -t 60</span><br></pre></td></tr></table></figure>

<h2 id="7-常用命令总结"><a href="#7-常用命令总结" class="headerlink" title="7. 常用命令总结"></a>7. 常用命令总结</h2><h3 id="基本网络故障模拟命令"><a href="#基本网络故障模拟命令" class="headerlink" title="基本网络故障模拟命令"></a>基本网络故障模拟命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 添加延迟</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 100ms 10ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 丢包率</span></span><br><span class="line">tc qdisc add dev eth0 root netem loss 10%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 限制带宽</span></span><br><span class="line">tc qdisc add dev eth0 root tbf rate 1mbit burst 32kbit latency 400ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 数据包损坏</span></span><br><span class="line">tc qdisc add dev eth0 root netem corrupt 5%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 模拟RST包</span></span><br><span class="line">iptables -A OUTPUT -p tcp -d 192.168.1.100 --dport 80 -j REJECT --reject-with tcp-reset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 中断特定连接</span></span><br><span class="line">tcpkill -i eth0 host 192.168.1.100 and port 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 模拟TCP重传</span></span><br><span class="line">tc qdisc add dev eth0 root netem loss random 15% delay 200ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 重置所有网络模拟</span></span><br><span class="line">tc qdisc del dev eth0 root</span><br><span class="line">iptables -F</span><br></pre></td></tr></table></figure>

<h3 id="监控网络问题命令"><a href="#监控网络问题命令" class="headerlink" title="监控网络问题命令"></a>监控网络问题命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看TCP重传和其他统计信息</span></span><br><span class="line">netstat -s | grep -i retrans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络接口统计</span></span><br><span class="line">netstat -i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时监控特定主机的网络连接</span></span><br><span class="line">watch -n 1 <span class="string">&quot;netstat -tunapl | grep 192.168.1.100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用tcpdump查看重传</span></span><br><span class="line">tcpdump -i eth0 -nn <span class="string">&quot;tcp[tcpflags] &amp; (tcp-syn|tcp-fin|tcp-rst|tcp-push) != 0&quot;</span> -v | grep -i retransmission</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查丢包情况</span></span><br><span class="line">ping -c 100 192.168.1.100 | grep <span class="string">&quot;packet loss&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络路由</span></span><br><span class="line">traceroute -T 192.168.1.100</span><br></pre></td></tr></table></figure>

<h3 id="常用组合场景命令"><a href="#常用组合场景命令" class="headerlink" title="常用组合场景命令"></a>常用组合场景命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 场景1: 不稳定的网络连接</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 100ms 50ms distribution normal loss 5% 25% duplicate 1% corrupt 2%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景2: 移动网络环境模拟</span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 200ms 100ms loss 3% reorder 5% rate 1mbit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景3: 高丢包率环境下的TCP重传测试</span></span><br><span class="line">tc qdisc add dev eth0 root netem loss 20% delay 100ms 30ms &amp;&amp; \</span><br><span class="line">tcpdump -i eth0 -nn <span class="string">&quot;host 192.168.1.100&quot;</span> -v | grep -i retransmission</span><br><span class="line"></span><br><span class="line"><span class="comment"># 场景4: 周期性网络抖动(脚本示例)</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="comment"># 网络正常</span></span><br><span class="line">  tc qdisc del dev eth0 root</span><br><span class="line">  <span class="built_in">sleep</span> 30</span><br><span class="line">  <span class="comment"># 网络抖动</span></span><br><span class="line">  tc qdisc add dev eth0 root netem delay 500ms 200ms loss 10%</span><br><span class="line">  <span class="built_in">sleep</span> 10</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="8-总结与最佳实践"><a href="#8-总结与最佳实践" class="headerlink" title="8. 总结与最佳实践"></a>8. 总结与最佳实践</h2><p>在测试SSE或WebSocket等长连接时，应考虑以下方面：</p>
<ol>
<li><p><strong>模拟不同类型的网络中断</strong>：</p>
<ul>
<li>使用FIN包的优雅关闭 (应用层主动关闭)</li>
<li>使用RST包的强制中断 (网络异常导致)</li>
<li>临时网络不可达 (数据包丢失)</li>
</ul>
</li>
<li><p><strong>测试客户端重连机制</strong>：</p>
<ul>
<li>指数退避重连</li>
<li>区分不同类型的连接错误</li>
<li>维持会话状态</li>
</ul>
</li>
<li><p><strong>测试服务端优雅降级</strong>：</p>
<ul>
<li>连接突然断开时的资源清理</li>
<li>部分网络可达时的服务降级</li>
<li>高负载下的连接管理</li>
</ul>
</li>
<li><p><strong>常见问题及解决方案</strong>：</p>
<ul>
<li>僵尸连接：设置合理的keepalive和超时</li>
<li>资源泄漏：确保连接正确关闭</li>
<li>重连风暴：客户端实现退避机制</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Content-Type 类型与使用场景</title>
    <url>/2025/08/14/Content-Type-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="消息体的数据格式"><a href="#消息体的数据格式" class="headerlink" title="消息体的数据格式"></a>消息体的数据格式</h2><table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>application/json</code></td>
<td><code>Content-Type: application/json</code></td>
<td>传输结构化数据（API 常用，如 REST 接口）。</td>
</tr>
<tr>
<td><code>application/xml</code></td>
<td><code>Content-Type: application/xml</code></td>
<td>传输 XML 格式数据（老系统或 SOAP 协议）。</td>
</tr>
<tr>
<td><code>text/plain</code></td>
<td><code>Content-Type: text/plain; charset=utf-8</code></td>
<td>传输纯文本（调试、日志、简单字符串）。</td>
</tr>
<tr>
<td><code>text/html</code></td>
<td><code>Content-Type: text/html; charset=utf-8</code></td>
<td>传输 HTML 文档（网页响应）。</td>
</tr>
<tr>
<td><code>application/x-www-form-urlencoded</code></td>
<td><code>Content-Type: application/x-www-form-urlencoded</code></td>
<td>表单提交（HTML form 的默认提交格式）。</td>
</tr>
<tr>
<td><code>multipart/form-data</code></td>
<td><code>Content-Type: multipart/form-data; boundary=----xxxx</code></td>
<td>文件上传（表单 + 文件混合提交）。</td>
</tr>
<tr>
<td><code>application/octet-stream</code></td>
<td><code>Content-Type: application/octet-stream</code></td>
<td>二进制数据（文件下载、任意二进制传输）。</td>
</tr>
<tr>
<td><code>text/event-stream</code></td>
<td><code>Content-Type: text/event-stream</code></td>
<td><strong>SSE（Server-Sent Events）长连接</strong>，服务器持续推送事件给客户端。</td>
</tr>
<tr>
<td><code>application/grpc</code></td>
<td><code>Content-Type: application/grpc</code></td>
<td>gRPC RPC 协议，基于 HTTP&#x2F;2 的二进制传输。</td>
</tr>
</tbody></table>
<h2 id="SSE-vs-chunked-JSON"><a href="#SSE-vs-chunked-JSON" class="headerlink" title="SSE vs chunked JSON"></a>SSE vs chunked JSON</h2><table>
<thead>
<tr>
<th>特性</th>
<th>SSE (text&#x2F;event-stream)</th>
<th>JSON + chunked (K8s watch)</th>
</tr>
</thead>
<tbody><tr>
<td>格式</td>
<td><code>data:</code> 行，纯文本</td>
<td>每个 chunk 独立 JSON 对象</td>
</tr>
<tr>
<td>使用场景</td>
<td>前端实时推送</td>
<td>后端 API 实时变更通知</td>
</tr>
<tr>
<td>浏览器支持</td>
<td>原生支持（EventSource）</td>
<td>需要手动解析</td>
</tr>
<tr>
<td>优势</td>
<td>易读、简单</td>
<td>结构化数据、后端友好</td>
</tr>
<tr>
<td>缺点</td>
<td>数据结构简单</td>
<td>需要解析 JSON 流</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>特性</th>
<th>K8s watch (chunked JSON)</th>
<th>SSE</th>
</tr>
</thead>
<tbody><tr>
<td>Content-Type</td>
<td><code>application/json</code></td>
<td><code>text/event-stream</code></td>
</tr>
<tr>
<td>数据格式</td>
<td>JSON</td>
<td>自定义事件流（以 <code>data:</code> 开头）</td>
</tr>
<tr>
<td>保持方式</td>
<td>HTTP&#x2F;1.1 长连接 + chunked</td>
<td>HTTP&#x2F;1.1 长连接 + 流式传输</td>
</tr>
<tr>
<td>客户端解析</td>
<td>JSON decoder</td>
<td>SSE parser</td>
</tr>
<tr>
<td>应用场景</td>
<td>Kubernetes API 事件</td>
<td>浏览器端推送消息</td>
</tr>
</tbody></table>
<hr>
<h2 id="keep-alive-类别"><a href="#keep-alive-类别" class="headerlink" title="keep-alive 类别"></a>keep-alive 类别</h2><table>
<thead>
<tr>
<th>类型</th>
<th>层级</th>
<th>特征</th>
</tr>
</thead>
<tbody><tr>
<td><strong>TCP keep-alive</strong></td>
<td>TCP 协议层</td>
<td>操作系统内核发的探测包（仅几个字节），目的是探测连接是否还活着。</td>
</tr>
<tr>
<td><strong>HTTP keep-alive</strong></td>
<td>HTTP 应用层</td>
<td>通过 <code>Connection: keep-alive</code> 维持 TCP 连接，后续请求共用同一 TCP 通道。</td>
</tr>
</tbody></table>
<hr>
<h2 id="SSE-理论-vs-K8s-watch-的实际连接时长"><a href="#SSE-理论-vs-K8s-watch-的实际连接时长" class="headerlink" title="SSE 理论 vs K8s watch 的实际连接时长"></a><strong>SSE 理论 vs K8s watch 的实际连接时长</strong></h2><ul>
<li><p><strong>SSE（text&#x2F;event-stream）</strong>：理论上无限长，只要网络不断开，服务器不重启，就能一直推送。</p>
</li>
<li><p><strong>K8s watch</strong>：</p>
<ul>
<li><p>实际受限于 <code>--min-request-timeout</code> 和 API Server &#x2F; 反向代理 &#x2F; LB 的空闲连接超时。</p>
</li>
<li><p>常见原因导致断开：</p>
<ol>
<li>kube-apiserver 超时（默认 30 分钟）。</li>
<li>API Server 节点重启或滚动升级。</li>
<li>前面有 nginx &#x2F; ELB &#x2F; F5 等，配置了 idle timeout（可能只有 60 秒、300 秒等）。</li>
<li>客户端自己设了超时（例如 kubectl 默认超时时间）。</li>
</ol>
</li>
<li><p>因此 K8s 客户端都会实现 <strong>自动重连</strong>（比如 client-go 会带上 <code>resourceVersion</code> 重连）。</p>
</li>
</ul>
</li>
</ul>
<h2 id="k8s-watch保持长连接机制"><a href="#k8s-watch保持长连接机制" class="headerlink" title="k8s watch保持长连接机制"></a>k8s watch保持长连接机制</h2><p>它的核心机制：</p>
<ol>
<li><p><strong>HTTP&#x2F;1.1 持久连接（Persistent Connection）</strong></p>
<ul>
<li>TCP 层连接不关闭。</li>
<li>HTTP 请求和响应在同一条 TCP 连接上传输。</li>
</ul>
</li>
<li><p><strong>Chunked Transfer Encoding</strong></p>
<ul>
<li>服务端不一次性返回全部数据，而是分多次“分块”推送。</li>
<li>每个分块前会有一个 16 进制的长度标识。</li>
<li>客户端读取到数据就处理，而不是等到连接结束。</li>
</ul>
</li>
<li><p><strong>K8s watch 特性</strong></p>
<ul>
<li>API Server 接收到 <code>watch=true</code> 请求后，会一直监听资源变化。</li>
<li>每当资源变化，就向这个连接推送一条 JSON。</li>
<li>没有变化时，不会发数据（可能会有周期性心跳，取决于实现）。</li>
</ul>
</li>
<li><p><strong>连接保活</strong></p>
<ul>
<li>TCP 层可能会开启 keep-alive 探测（由 OS 配置，比如 Linux <code>/proc/sys/net/ipv4/tcp_keepalive_*</code>）。</li>
<li>API Server 层会通过 <code>--min-request-timeout</code> 决定最小存活时长（默认 30 分钟）。</li>
<li>客户端（如 kubectl &#x2F; client-go）会自动在断开后重连。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>常见流程图类型及用途</title>
    <url>/2025/08/14/%E5%B8%B8%E8%A7%81%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%94%A8%E9%80%94/</url>
    <content><![CDATA[<h2 id="流程图类型及用途"><a href="#流程图类型及用途" class="headerlink" title="流程图类型及用途"></a>流程图类型及用途</h2><table>
<thead>
<tr>
<th>图类型</th>
<th>适用场景</th>
<th>是否常用</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>时序图（Sequence Diagram）</strong></td>
<td>展示系统组件之间随时间推移的交互</td>
<td>✅ 非常常用</td>
<td>强调<strong>时间顺序</strong>和消息流</td>
</tr>
<tr>
<td><strong>流程图（Flowchart）</strong></td>
<td>展示操作&#x2F;决策的逻辑流程</td>
<td>✅ 最常见</td>
<td>适合描述<strong>决策逻辑</strong></td>
</tr>
<tr>
<td><strong>活动图（Activity Diagram）</strong></td>
<td>类似流程图，更关注流程中的并发与分支</td>
<td>✅ 常用</td>
<td>更偏向于<strong>行为建模</strong></td>
</tr>
<tr>
<td><strong>状态图（State Machine Diagram）</strong></td>
<td>展示对象状态随事件变化</td>
<td>⚠️ 特定场景</td>
<td>适用于<strong>有限状态机</strong>描述</td>
</tr>
<tr>
<td><strong>组件图（Component Diagram）</strong></td>
<td>展示系统结构及组件依赖</td>
<td>✅ 架构设计常用</td>
<td>显示模块、接口和依赖</td>
</tr>
<tr>
<td><strong>部署图（Deployment Diagram）</strong></td>
<td>展示物理部署架构</td>
<td>✅ DevOps 场景常见</td>
<td>描述服务器、容器部署</td>
</tr>
<tr>
<td><strong>时序交互图（Interaction Overview Diagram）</strong></td>
<td>结合流程图和时序图</td>
<td>⚠️ 较少用</td>
<td>适合大系统多子流程交互</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>部署kube-prometheus-stack</title>
    <url>/2025/09/01/%E9%83%A8%E7%BD%B2kube-prometheus-stack/</url>
    <content><![CDATA[<h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><h3 id="1、加载仓库"><a href="#1、加载仓库" class="headerlink" title="1、加载仓库"></a>1、加载仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo add prometheus-community https://prometheus-community.github.io/helm-charts</span><br><span class="line">helm search repo prometheus-community/kube-prometheus-stack </span><br><span class="line">helm pull prometheus-community/kube-prometheus-stack</span><br></pre></td></tr></table></figure>

<h3 id="2、修改镜像"><a href="#2、修改镜像" class="headerlink" title="2、修改镜像"></a>2、修改镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar zxvf kube-prometheus-stack-77.0.2.tgz</span><br><span class="line">helm template ./kube-prometheus-stack &gt; kube-prometheus-stack.yaml</span><br><span class="line"></span><br><span class="line">#查看当前镜像</span><br><span class="line">cat kube-prometheus-stack.yaml  | grep -w image:</span><br></pre></td></tr></table></figure>

<h3 id="3、替换镜像"><a href="#3、替换镜像" class="headerlink" title="3、替换镜像"></a>3、替换镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">set -euo pipefail</span><br><span class="line"></span><br><span class="line"># 目标私有仓库前缀</span><br><span class="line">HARBOR_REGISTRY=&quot;harborqa.xxx.net/xxx&quot;</span><br><span class="line"></span><br><span class="line"># 待同步的镜像列表</span><br><span class="line">IMAGES=(</span><br><span class="line">  &quot;quay.io/prometheus/node-exporter:v1.9.1&quot;</span><br><span class="line">  &quot;quay.io/kiwigrid/k8s-sidecar:1.30.3&quot;</span><br><span class="line">  &quot;docker.io/grafana/grafana:12.1.0&quot;</span><br><span class="line">  &quot;registry.k8s.io/kube-state-metrics/kube-state-metrics:v2.16.0&quot;</span><br><span class="line">  &quot;quay.io/prometheus-operator/prometheus-operator:v0.85.0&quot;</span><br><span class="line">  &quot;quay.io/prometheus-operator/prometheus-config-reloader:v0.85.0&quot;</span><br><span class="line">  &quot;quay.io/prometheus/alertmanager:v0.28.1&quot;</span><br><span class="line">  &quot;quay.io/prometheus/prometheus:v3.5.0&quot;</span><br><span class="line">  &quot;docker.io/bats/bats:v1.4.1&quot;</span><br><span class="line">  &quot;registry.k8s.io/ingress-nginx/kube-webhook-certgen:v1.6.1&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">for IMAGE in &quot;$&#123;IMAGES[@]&#125;&quot;; do</span><br><span class="line">  echo &quot;&gt;&gt;&gt; 处理镜像: $IMAGE&quot;</span><br><span class="line"></span><br><span class="line">  # 分割 repo 与 tag</span><br><span class="line">  NAME_TAG=&quot;$&#123;IMAGE##*/&#125;&quot;          # e.g. prometheus:v3.5.0</span><br><span class="line">  NAME=&quot;$&#123;NAME_TAG%%:*&#125;&quot;           # e.g. prometheus</span><br><span class="line">  TAG=&quot;$&#123;NAME_TAG##*:&#125;&quot;            # e.g. v3.5.0</span><br><span class="line"></span><br><span class="line">  # 提取仓库路径（去掉前缀 registry）</span><br><span class="line">  REPO_PATH=$(echo &quot;$IMAGE&quot; | cut -d&#x27;/&#x27; -f2- | cut -d&#x27;:&#x27; -f1)</span><br><span class="line"></span><br><span class="line">  # 构造目标镜像</span><br><span class="line">  TARGET=&quot;$&#123;HARBOR_REGISTRY&#125;/$&#123;REPO_PATH&#125;:$&#123;TAG&#125;&quot;</span><br><span class="line"></span><br><span class="line">  echo &quot;拉取镜像: $IMAGE&quot;</span><br><span class="line">  docker pull &quot;$IMAGE&quot;</span><br><span class="line"></span><br><span class="line">  echo &quot;打标签: $IMAGE -&gt; $TARGET&quot;</span><br><span class="line">  docker tag &quot;$IMAGE&quot; &quot;$TARGET&quot;</span><br><span class="line"></span><br><span class="line">  echo &quot;推送到私有仓库: $TARGET&quot;</span><br><span class="line">  docker push &quot;$TARGET&quot;</span><br><span class="line"></span><br><span class="line">  echo &quot;清理本地镜像: $IMAGE&quot;</span><br><span class="line">  docker rmi &quot;$IMAGE&quot; || true</span><br><span class="line">  echo &quot;=== 完成 $IMAGE ===&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="4、修改镜像"><a href="#4、修改镜像" class="headerlink" title="4、修改镜像"></a>4、修改镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i.bak \</span><br><span class="line">    -e &#x27;s#quay.io#harborqa.xxx.net/xxx#g&#x27; \</span><br><span class="line">    -e &#x27;s#docker.io#harborqa.xxx.net/xxx#g&#x27; \</span><br><span class="line">    -e &#x27;s#registry.k8s.io#harborqa.xxx.net/xxx#g&#x27; \</span><br><span class="line">    kube-prometheus-stack.yaml</span><br></pre></td></tr></table></figure>
<h3 id="5、安装部署"><a href="#5、安装部署" class="headerlink" title="5、安装部署"></a>5、安装部署</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k apply -f kube-prometheus-stack.yaml</span><br></pre></td></tr></table></figure>
<h3 id="6、访问grafana"><a href="#6、访问grafana" class="headerlink" title="6、访问grafana"></a>6、访问grafana</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#浏览器访问： release-name-grafana-xxx-xxx pod ip ：</span><br><span class="line">#eg: 11.123.243.66:3000</span><br><span class="line">#查看密码</span><br><span class="line">#用户名：admin</span><br><span class="line">kubectl get secret release-name-grafana -n monitoring -o jsonpath=&quot;&#123;.data.admin-password&#125;&quot; | base64 -d</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>内存回写/脏页/回收/OOM</title>
    <url>/2025/09/05/%E5%86%85%E5%AD%98%E5%9B%9E%E5%86%99-%E8%84%8F%E9%A1%B5-%E5%9B%9E%E6%94%B6-OOM/</url>
    <content><![CDATA[<h1 id="内存回写-脏页-回收-OOM-—-全流程说明与排查指南"><a href="#内存回写-脏页-回收-OOM-—-全流程说明与排查指南" class="headerlink" title="内存回写 &#x2F; 脏页 &#x2F; 回收 &#x2F; OOM — 全流程说明与排查指南"></a>内存回写 &#x2F; 脏页 &#x2F; 回收 &#x2F; OOM — 全流程说明与排查指南</h1><h2 id="概览（一句话）"><a href="#概览（一句话）" class="headerlink" title="概览（一句话）"></a>概览（一句话）</h2><p>用户进程写数据 → 数据先写入页缓存（page cache）成为 <em>dirty pages</em> → 内核异步回写（writeback）到磁盘 → 若磁盘&#x2F;后端慢或写入速率低于生成速率，dirty 将积累 → 内存回收（kswapd）尝试回收或触发写回并阻塞写者 → 若回收失败并耗尽内存，OOM killer 根据策略选择并杀死进程 &#x2F; cgroup。</p>
<hr>
<h2 id="一、关键概念（快速回顾）"><a href="#一、关键概念（快速回顾）" class="headerlink" title="一、关键概念（快速回顾）"></a>一、关键概念（快速回顾）</h2><ul>
<li>**页缓存 (page cache)**：文件&#x2F;块 IO 的缓存层，存储在内存中 <code>struct page</code>。</li>
<li><strong>Dirty pages</strong>：已修改但尚未写回到磁盘的页（占用内存，可写回）。</li>
<li><strong>Writeback</strong>：内核将 dirty page 写回存储（由 writeback kthreads &#x2F; flush workers 执行）。</li>
<li><strong>kswapd &#x2F; page reclaim</strong>：当内存紧张时回收可回收页（包括触发 writeback）。</li>
<li><strong>OOM killer</strong>：当内核无法满足分配且无法回收，选择进程作为牺牲者（基于 <code>oom_score</code>、<code>oom_score_adj</code>、cgroup）并终止之。</li>
<li><strong>cgroup v1&#x2F;v2</strong>：容器资源限制机制，内存超限会触发 cgroup OOM 行为。</li>
</ul>
<hr>
<h2 id="二、典型触发路径（更详细）"><a href="#二、典型触发路径（更详细）" class="headerlink" title="二、典型触发路径（更详细）"></a>二、典型触发路径（更详细）</h2><ol>
<li><p><strong>用户进程 write()</strong>  </p>
<ul>
<li>内核在 page cache 分配&#x2F;获取 page，复制数据到 page，然后标记为 <code>dirty</code>。</li>
<li>write 返回快（写入内存），不等磁盘写完 -&gt; 写入吞吐高但延迟低。</li>
</ul>
</li>
<li><p><strong>后台 writeback</strong>  </p>
<ul>
<li>内核周期性&#x2F;阈值触发 writeback（<code>vm.dirty_background_ratio</code> &#x2F; <code>vm.dirty_ratio</code> 或绝对量 <code>vm.dirty_bytes</code>）。</li>
<li>writeback 由内核 kthreads 执行，异步把页写到块设备或通过 NFS&#x2F;CIFS&#x2F;CSI 等上游。</li>
</ul>
</li>
<li><p><strong>当 writeback 跟不上</strong>  </p>
<ul>
<li>若产生 dirty 的速度 &gt; 写回速度（例如磁盘慢&#x2F;IO 卡住），dirty 会累积。</li>
<li>一旦达到 <code>vm.dirty_ratio</code>，写者可能被强制阻塞（同步地 flush），导致大量进程阻塞在 D (uninterruptible sleep) 状态。</li>
<li>IO 长时间阻塞会使系统响应变差（ssh 卡、syscalls 卡）。</li>
</ul>
</li>
<li><p><strong>内存回收与 OOM</strong>  </p>
<ul>
<li>kswapd&#x2F;直接分配者触发回收，回收优先回收可回收的缓存页或回写脏页。</li>
<li>如果回收仍然不能满足内存请求，内核触发 OOM killer，选择最合适的 victim（参考 oom_score, oom_score_adj, oom_badness 以及 cgroup 权重），并杀掉进程。</li>
<li>在 cgroup v2 下，若 cgroup 达到 <code>memory.max</code>，可能只杀该 cgroup 内的进程（cgroup OOM）。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="三、和-buff-cache-MemAvailable-的常见误解"><a href="#三、和-buff-cache-MemAvailable-的常见误解" class="headerlink" title="三、和 buff/cache &#x2F; MemAvailable 的常见误解"></a>三、和 <code>buff/cache</code> &#x2F; <code>MemAvailable</code> 的常见误解</h2><ul>
<li><code>buff/cache</code> 高 <strong>不等于</strong> 可用性低；<code>buff/cache</code> 是可回收的（通常）。  </li>
<li>但当脏页非常多或 slab（内核对象）泄漏时，内存是“不可回收”的 → 即便 <code>MemAvailable</code> 暂时显示不是 0，也可能回收失败导致假死。  </li>
<li>区分点：看 <code>Dirty</code>&#x2F;<code>Writeback</code> 与 <code>SReclaimable</code> &#x2F; <code>SUnreclaim</code>（<code>/proc/meminfo</code> 与 <code>slabtop</code>）。</li>
</ul>
<hr>
<h2 id="四、实操排查清单（从轻到重）"><a href="#四、实操排查清单（从轻到重）" class="headerlink" title="四、实操排查清单（从轻到重）"></a>四、实操排查清单（从轻到重）</h2><h3 id="1-快速查看内存-脏页-回写"><a href="#1-快速查看内存-脏页-回写" class="headerlink" title="1) 快速查看内存&#x2F;脏页&#x2F;回写"></a>1) 快速查看内存&#x2F;脏页&#x2F;回写</h3><pre><code class="bash">free -h
cat /proc/meminfo | egrep &#39;Dirty|Writeback|MemAvailable|Cached|Buffers|SUnreclaim|Slab|Swap&#39;
cat /proc/vmstat | egrep &#39;pgfault|pgmajfault|pgscan|pgsteal|nr_dirty|nr_writeback&#39;
</code></pre>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>cgroup/namespace vs Kata</title>
    <url>/2025/09/05/cgroup-namespace-vs-Kata/</url>
    <content><![CDATA[<h2 id="概念快速梳理"><a href="#概念快速梳理" class="headerlink" title="概念快速梳理"></a>概念快速梳理</h2><ul>
<li>namespace (PID&#x2F;NET&#x2F;IPC&#x2F;UTS&#x2F;MNT&#x2F;USER&#x2F;…) ：Linux 提供的进程隔离机制（名字空间），用于隔离进程视角（PID、网络命名空间等）。</li>
<li>cgroup (control groups) ：Linux 提供的资源控制（CPU&#x2F;memory&#x2F;io&#x2F;pids），用于限制与计量资源消耗。</li>
<li>传统容器 (Docker&#x2F;runc etc.) ：基于单一宿主机内核 + namespaces + cgroups，为应用提供轻量隔离。</li>
<li>Kata Containers：为容器提供轻量级虚拟化：每个容器或 Pod 运行在一个轻量 VM（有独立内核），兼顾 VM 的强隔离与容器的速度。</li>
</ul>
<hr>
<h2 id="关键差别（对比表）"><a href="#关键差别（对比表）" class="headerlink" title="关键差别（对比表）"></a>关键差别（对比表）</h2><table>
<thead>
<tr>
<th>维度</th>
<th align="right">Namespaces + cgroups (传统容器)</th>
<th>Kata Containers (轻量 VM)</th>
</tr>
</thead>
<tbody><tr>
<td>隔离级别</td>
<td align="right">进程级隔离，同一宿主机内核共享</td>
<td>每个 VM 有自己内核（更强的隔离）</td>
</tr>
<tr>
<td>内核 bug 影响</td>
<td align="right">宿主机内核 bug 可能影响所有容器</td>
<td>客户 VM 内核问题通常仅影响该 VM（保护宿主）</td>
</tr>
<tr>
<td>启动速度</td>
<td align="right">极快（ms ~ s）</td>
<td>较慢（s 量级，取决于 runtime&#x2F;VM）</td>
</tr>
<tr>
<td>资源开销</td>
<td align="right">很低（共享内核，少量 overhead）</td>
<td>较高（每 VM 有 qemu&#x2F;kvm 等开销）</td>
</tr>
<tr>
<td>安全边界</td>
<td align="right">用户态较弱（容器逃逸有历史）</td>
<td>更强（硬隔离，适合多租户&#x2F;不信任工作负载）</td>
</tr>
<tr>
<td>调试与运维</td>
<td align="right">与宿主一致（&#x2F;proc, cgroup）</td>
<td>VM 内&#x2F;宿主 双层调试，复杂度高</td>
</tr>
<tr>
<td>对单 Pod 内存泄漏影响</td>
<td align="right">泄漏在 host kernel&#x2F;user space，可直接影响 host</td>
<td>泄漏限制在 VM（若VM有 memory limit 则受限）</td>
</tr>
<tr>
<td>使用场景</td>
<td align="right">大多数云原生应用、CI&#x2F;CD、低延迟服务</td>
<td>多租户且对安全敏感、需要防止内核级风险或特定内核版本隔离的场景</td>
</tr>
</tbody></table>
<hr>
<h2 id="Kata-能否避免单业务导致全主机挂掉？"><a href="#Kata-能否避免单业务导致全主机挂掉？" class="headerlink" title="Kata 能否避免单业务导致全主机挂掉？"></a>Kata 能否避免单业务导致全主机挂掉？</h2><ul>
<li><strong>能显著降低风险</strong>：如果问题是<strong>内核级 bug</strong> 或需要特殊内核模块出问题（例如某些驱动、netfilter bug），在 Kata 中发生时通常只影响该 VM，不会直接影响宿主机内核和其他 VM&#x2F;容器。  </li>
<li><strong>对用户空间内存泄漏</strong>：如果单个 VM 的进程泄漏内存并且该 VM 的内存上限被设置（例如给 VM 分配 4Gi），则泄漏会耗尽该 VM 内存并导致 VM 内 OOM，但不会直接耗尽宿主整台机器的内存（只要宿主上没有被配置过大的 VM 数量）。  </li>
<li><strong>注意</strong>：大量 Kata VM 被同时启动且每个都泄漏，仍然能用尽宿主资源 —— 因此仍需上层资源限制 &amp; 调度策略。</li>
</ul>
<hr>
<h2 id="什么时候优先考虑使用-Kata？"><a href="#什么时候优先考虑使用-Kata？" class="headerlink" title="什么时候优先考虑使用 Kata？"></a>什么时候优先考虑使用 Kata？</h2><ul>
<li>多租户平台（每租户代码不信任），需要强内核隔离。  </li>
<li>运行需要自定义&#x2F;不同内核版本或特殊内核模块的 workload，避免宿主内核污染。  </li>
<li>法规或安全要求必须严格隔离（例如金融 &#x2F; 医疗 &#x2F; 隐私敏感场景）。  </li>
<li>需要兼顾容器化便捷性与 VM 级安全边界。</li>
</ul>
<hr>
<h2 id="运维与排查差异"><a href="#运维与排查差异" class="headerlink" title="运维与排查差异"></a>运维与排查差异</h2><ul>
<li><strong>传统容器</strong>：<ul>
<li>优势：直接查看宿主 <code>/sys/fs/cgroup</code>、<code>/proc</code> 来诊断 container 内资源使用（更直观）。  </li>
<li>常用工具：<code>docker ps</code>&#x2F;<code>ctr</code>、<code>systemd-cgls</code>、<code>cat cgroup memory.stat</code>。</li>
</ul>
</li>
<li><strong>Kata</strong>：<ul>
<li>你需要在<strong>宿主层</strong>和<strong>Guest VM 层</strong>都排查：宿主层看 VM 进程、资源分配，guest 内看应用行为。  </li>
<li>更复杂：两层日志、两层指标，但隔离性更好。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="实践建议（基于场景）"><a href="#实践建议（基于场景）" class="headerlink" title="实践建议（基于场景）"></a>实践建议（基于场景）</h2><ol>
<li><strong>大多数应用</strong>：先用传统容器 + 严格 cgroup &#x2F; kubelet eviction &#x2F;资源限额。  </li>
<li><strong>不信任租户 &#x2F; 强隔离</strong>：用 Kata（或 VM-based multi-tenant）并为每 VM 设置合理内存上限。  </li>
<li><strong>IO &#x2F; 存储敏感</strong>：优化后端存储、设置 <code>vm.dirty_*</code> 限额、在 runtime 层配合 QoS 限制。  </li>
<li><strong>混合部署</strong>：把高风险工作负载放 Kata，普通服务放容器，减少总体成本。</li>
</ol>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ul>
<li><code>cgroup + namespace</code> 提供高效、低开销的多租户能力，适合绝大多数云原生场景；  </li>
<li><code>Kata</code> 在<strong>强隔离</strong>与<strong>安全</strong>场景下胜出，但有成本与运维复杂度，需权衡。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>内存相关信息整理</title>
    <url>/2025/09/10/%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h2><ul>
<li>SUnreclaim（非可回收 slab）</li>
<li>SReclaimable（可回收 slab, 如 inode&#x2F;dentry cache）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#几个计算关系</span><br><span class="line">#Slab = 内核维护对象的缓存（inode、dentry、socket buffer 等）</span><br><span class="line">Slab = SReclaimable + SUnreclaim</span><br><span class="line">#含义</span><br><span class="line">SUnreclaim – Non-reclaimable slab memory (kernel objects) 占比稳定，内核不可回收部分</span><br><span class="line">SReclaimable – Potentially reclaimable slab memory (e.g., inode cache) 占比较高，内核可回收部分</span><br><span class="line"></span><br><span class="line"># buff/cache 可回收内存，SReclaimable高、回收慢可持续增高，从而出现“可回收但实际上回收不掉” </span><br><span class="line">buff/cache ≈ Buffers + Cached + SReclaimable</span><br><span class="line"></span><br><span class="line">#MemAvailable</span><br><span class="line">MemAvailable ≈ MemFree + Buffers + Cached + SReclaimable - 一些不可回收部分</span><br><span class="line"></span><br><span class="line">#观察方式：</span><br><span class="line">top</span><br><span class="line">watch -n1 &quot;grep -E &#x27;MemTotal|MemFree|MemAvailable|Cached|Slab|SReclaimable|SUnreclaim&#x27; /proc/meminfo&quot;</span><br><span class="line"></span><br><span class="line">#查看内核内存参数</span><br><span class="line">sysctl -a | grep vm</span><br><span class="line"></span><br><span class="line">#查看slab信息: cat /proc/slabinfo</span><br><span class="line">#看具体哪些 slab 类型涨得多,如果 top 几项是 dentry/inode_cache → 说明 VFS 元数据。</span><br><span class="line">cat /proc/slabinfo | egrep -i &#x27;dentry|inode|path|ext4|xfs&#x27; </span><br><span class="line"></span><br><span class="line">#或者命令</span><br><span class="line">slabtop</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存回收-vfs-cache-pressure"><a href="#内存回收-vfs-cache-pressure" class="headerlink" title="内存回收:vfs_cache_pressure"></a>内存回收:vfs_cache_pressure</h2><blockquote>
<p>参考：<a href="https://blog.csdn.net/ygq13572549874/article/details/148332587">https://blog.csdn.net/ygq13572549874/article/details/148332587</a> </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看虚拟文件系统</span><br><span class="line">cat /proc/sys/vm/vfs_cache_pressure</span><br><span class="line"></span><br><span class="line">含义：控制内核回收 inode 和 dentry 缓存的倾向程度：</span><br><span class="line">- inode 缓存：存储文件系统的元数据（如文件权限、所有者、时间戳等）</span><br><span class="line">- dentry 缓存：存储目录项缓存（如文件名到 inode 的映射关系）</span><br><span class="line"></span><br><span class="line">参数值范围为 0-1000，默认值为 100：</span><br><span class="line">- 值越小：内核越倾向于保留 inode/dentry 缓存（即使内存紧张）</span><br><span class="line">- 值越大：内核越倾向于优先回收 inode/dentry 缓存</span><br><span class="line"></span><br><span class="line">当系统内存紧张时，内核需要决定如何平衡回收不同类型的缓存：</span><br><span class="line">- 页面缓存（page cache）：文件内容的缓存</span><br><span class="line">- inode/dentry 缓存：文件系统元数据的缓存</span><br><span class="line">-交换空间（swap）：内存到磁盘的交换</span><br></pre></td></tr></table></figure>

<h2 id="drop-caches"><a href="#drop-caches" class="headerlink" title="drop caches"></a>drop caches</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#drop caches（测试是否可回收）</span><br><span class="line"># 1=pagecache, 2=dentries+inodes, 3=both</span><br><span class="line">sudo sync</span><br><span class="line">sudo sh -c &#x27;echo 2 &gt; /proc/sys/vm/drop_caches&#x27;</span><br><span class="line"># 之后重新检查 /proc/meminfo 的 Slab/SReclaimable 是否显著下降</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>基础镜像对比</title>
    <url>/2025/09/11/%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h1 id="📊-基础镜像对比（Debian-Ubuntu-Alpine-CentOS）"><a href="#📊-基础镜像对比（Debian-Ubuntu-Alpine-CentOS）" class="headerlink" title="📊 基础镜像对比（Debian &#x2F; Ubuntu &#x2F; Alpine &#x2F; CentOS）"></a>📊 基础镜像对比（Debian &#x2F; Ubuntu &#x2F; Alpine &#x2F; CentOS）</h1><table>
<thead>
<tr>
<th>系统</th>
<th>体积 (镜像大小)</th>
<th>兼容性</th>
<th>稳定性</th>
<th>生态支持</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Debian</strong></td>
<td><strong>中等</strong>（<code>slim</code> ~ 22MB，完整 ~ 124MB）</td>
<td>与 Linux 主流发行版高度兼容（glibc）</td>
<td>极高，长期支持 + 安全更新快</td>
<td>Docker 官方推荐，文档丰富，CI&#x2F;CD 常用</td>
<td>推荐大多数应用，稳定、安全、轻量</td>
</tr>
<tr>
<td><strong>Ubuntu</strong></td>
<td>中等偏大（<code>slim</code> ~ 29MB，完整 ~ 77MB）</td>
<td>与 Debian 完全兼容，额外带 Canonical 支持</td>
<td>高，LTS 版本支持 5 年</td>
<td>最流行，社区 &amp; 企业文档最全，云原生生态好</td>
<td>推荐需要 LTS 的场景，如微服务、企业应用</td>
</tr>
<tr>
<td><strong>Alpine</strong></td>
<td><strong>极小</strong>（5MB 左右）</td>
<td>使用 <code>musl libc</code> 与 <code>busybox</code>，部分库兼容性差</td>
<td>中等，滚动更新快但可能引入问题</td>
<td>文档较少，调试工具缺失，构建复杂</td>
<td>适合极简应用，静态编译 Go &#x2F; Rust &#x2F; Java 镜像</td>
</tr>
<tr>
<td><strong>CentOS</strong>（含 Rocky&#x2F;Alma）</td>
<td>大（200MB+）</td>
<td>与 RHEL 完全兼容，适合企业 RHEL 环境</td>
<td>高，企业级，生命周期长（取决于版本）</td>
<td>传统企业用得多，但云原生社区热度下降</td>
<td>适合对 <strong>RHEL 兼容性</strong> 有强需求的环境</td>
</tr>
</tbody></table>
<hr>
<h1 id="🏷-Debian-镜像-tag-说明"><a href="#🏷-Debian-镜像-tag-说明" class="headerlink" title="🏷 Debian 镜像 tag 说明"></a>🏷 Debian 镜像 tag 说明</h1><p>Debian 的 tag 比较多，我帮你分类整理：</p>
<table>
<thead>
<tr>
<th>Tag 示例</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>bookworm</code></td>
<td>Debian 12 稳定版（最新稳定版本，推荐生产环境使用）</td>
</tr>
<tr>
<td><code>bullseye</code></td>
<td>Debian 11 稳定版</td>
</tr>
<tr>
<td><code>buster</code></td>
<td>Debian 10 稳定版（老版本）</td>
</tr>
<tr>
<td><code>12</code>, <code>11</code>, <code>10</code></td>
<td>对应 Debian 主版本号，和代号等价</td>
</tr>
<tr>
<td><code>bookworm-slim</code></td>
<td>精简版，去掉 man&#x2F;info&#x2F;locale，不带多余工具，体积更小</td>
</tr>
<tr>
<td><code>bookworm-20240904</code></td>
<td>带构建日期的镜像，保证可重复构建</td>
</tr>
<tr>
<td><code>stable</code></td>
<td>当前最新的稳定版（目前是 <code>bookworm</code>）</td>
</tr>
<tr>
<td><code>testing</code></td>
<td>即将成为下一个稳定版的滚动版本，不保证完全稳定</td>
</tr>
<tr>
<td><code>unstable</code></td>
<td>永远指向 <strong>sid</strong>，开发中，不推荐生产使用</td>
</tr>
<tr>
<td><code>experimental</code></td>
<td>实验性分支，风险高</td>
</tr>
</tbody></table>
<p>👉 <strong>推荐选择</strong>：</p>
<ul>
<li>生产环境：<code>debian:bookworm-slim</code>（小而稳）</li>
<li>调试环境：<code>debian:bookworm</code>（带工具，方便排查）</li>
<li>可重复构建：<code>debian:bookworm-20240904</code>（固定快照）</li>
</ul>
<hr>
<h1 id="🏷-Ubuntu-镜像-tag-说明"><a href="#🏷-Ubuntu-镜像-tag-说明" class="headerlink" title="🏷 Ubuntu 镜像 tag 说明"></a>🏷 Ubuntu 镜像 tag 说明</h1><p>Ubuntu 的版本遵循 <strong>年.月</strong> 格式，分为 <strong>LTS（长期支持）</strong> 和 <strong>非 LTS（短期支持）</strong>：</p>
<table>
<thead>
<tr>
<th>Tag 示例</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>22.04</code>, <code>jammy</code></td>
<td>Ubuntu 22.04 LTS（支持至 2027，Extended Security 到 2032）</td>
</tr>
<tr>
<td><code>20.04</code>, <code>focal</code></td>
<td>Ubuntu 20.04 LTS（支持至 2025）</td>
</tr>
<tr>
<td><code>18.04</code>, <code>bionic</code></td>
<td>Ubuntu 18.04 LTS（支持至 2023）</td>
</tr>
<tr>
<td><code>24.04</code>, <code>noble</code></td>
<td>Ubuntu 24.04 LTS（最新 LTS，支持至 2029）</td>
</tr>
<tr>
<td><code>latest</code></td>
<td>当前最新版本（⚠️ 不推荐生产用，可能随时间变）</td>
</tr>
<tr>
<td><code>22.04-slim</code></td>
<td>精简版，体积更小</td>
</tr>
<tr>
<td><code>rolling</code></td>
<td>滚动版本，始终跟随最新稳定版</td>
</tr>
</tbody></table>
<p>👉 <strong>推荐选择</strong>：</p>
<ul>
<li>生产环境：<code>ubuntu:22.04</code> 或 <code>ubuntu:22.04-slim</code></li>
<li>长期维护：<code>ubuntu:24.04</code>（新 LTS）</li>
<li>快速试验：<code>ubuntu:latest</code>（不建议生产使用）</li>
</ul>
<hr>
<h1 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h1><ul>
<li><strong>首选</strong>：<code>debian:bookworm-slim</code>（小、稳、安全更新快）</li>
<li><strong>需要 LTS 长期支持</strong>：<code>ubuntu:22.04</code> 或 <code>ubuntu:24.04</code></li>
<li><strong>极小镜像</strong>：<code>alpine:3.20</code>，但要考虑兼容性问题</li>
<li><strong>企业 RHEL 兼容场景</strong>：<code>rockylinux:8</code> &#x2F; <code>almalinux:8</code></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>lsns命令使用指南与故障排查</title>
    <url>/2025/09/16/lsns%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%E4%B8%8E%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<h2 id="lsns基础用法"><a href="#lsns基础用法" class="headerlink" title="lsns基础用法"></a>lsns基础用法</h2><h3 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有命名空间</span></span><br><span class="line">lsns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定进程的命名空间</span></span><br><span class="line">lsns -p &lt;PID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定类型的命名空间</span></span><br><span class="line">lsns -t net        <span class="comment"># 网络命名空间</span></span><br><span class="line">lsns -t mnt        <span class="comment"># 挂载命名空间</span></span><br><span class="line">lsns -t pid        <span class="comment"># PID命名空间</span></span><br><span class="line">lsns -t user       <span class="comment"># 用户命名空间</span></span><br><span class="line">lsns -t uts        <span class="comment"># UTS命名空间</span></span><br><span class="line">lsns -t ipc        <span class="comment"># IPC命名空间</span></span><br><span class="line">lsns -t cgroup     <span class="comment"># cgroup命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示详细输出格式</span></span><br><span class="line">lsns -l            <span class="comment"># 长格式显示</span></span><br><span class="line">lsns -J            <span class="comment"># JSON格式输出</span></span><br><span class="line">lsns -r            <span class="comment"># 显示原始设备号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示特定列</span></span><br><span class="line">lsns -o NS,TYPE,NPROCS,PID,USER,NETNSID,COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不显示头部</span></span><br><span class="line">lsns -n</span><br></pre></td></tr></table></figure>

<h3 id="2-高级用法"><a href="#2-高级用法" class="headerlink" title="2. 高级用法"></a>2. 高级用法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看特定命名空间的详细信息</span></span><br><span class="line">lsns --nsfs-file /proc/1/ns/net</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按类型和进程数排序</span></span><br><span class="line">lsns -t net -o NS,TYPE,NPROCS,PID,COMMAND | <span class="built_in">sort</span> -k3 -nr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器相关的命名空间</span></span><br><span class="line">lsns | grep docker</span><br><span class="line">lsns | grep containerd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看systemd相关命名空间</span></span><br><span class="line">lsns | grep systemd</span><br></pre></td></tr></table></figure>

<h2 id="命名空间操作命令"><a href="#命名空间操作命令" class="headerlink" title="命名空间操作命令"></a>命名空间操作命令</h2><h3 id="1-进入命名空间"><a href="#1-进入命名空间" class="headerlink" title="1. 进入命名空间"></a>1. 进入命名空间</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入特定进程的网络命名空间</span></span><br><span class="line">nsenter -t &lt;PID&gt; -n bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入多个命名空间</span></span><br><span class="line">nsenter -t &lt;PID&gt; -n -p -m bash     <span class="comment"># 网络+PID+挂载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入所有命名空间</span></span><br><span class="line">nsenter -t &lt;PID&gt; -a bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ip命令进入网络命名空间</span></span><br><span class="line">ip netns <span class="built_in">exec</span> &lt;netns-name&gt; bash</span><br></pre></td></tr></table></figure>

<h3 id="2-查看命名空间详情"><a href="#2-查看命名空间详情" class="headerlink" title="2. 查看命名空间详情"></a>2. 查看命名空间详情</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看进程的命名空间文件</span></span><br><span class="line"><span class="built_in">ls</span> -la /proc/&lt;PID&gt;/ns/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络命名空间</span></span><br><span class="line">ip netns list</span><br><span class="line">ip netns show</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看挂载命名空间</span></span><br><span class="line"><span class="built_in">cat</span> /proc/&lt;PID&gt;/mounts</span><br><span class="line"><span class="built_in">cat</span> /proc/&lt;PID&gt;/mountinfo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看PID命名空间</span></span><br><span class="line"><span class="built_in">cat</span> /proc/&lt;PID&gt;/status | grep NSpid</span><br></pre></td></tr></table></figure>

<h3 id="3-命名空间监控"><a href="#3-命名空间监控" class="headerlink" title="3. 命名空间监控"></a>3. 命名空间监控</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实时监控命名空间变化</span></span><br><span class="line">watch -n 1 <span class="string">&#x27;lsns -t net&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看命名空间统计</span></span><br><span class="line">lsns | awk <span class="string">&#x27;NR&gt;1 &#123;print $2&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br></pre></td></tr></table></figure>

<h2 id="故障排查场景和命令清单"><a href="#故障排查场景和命令清单" class="headerlink" title="故障排查场景和命令清单"></a>故障排查场景和命令清单</h2><h3 id="🔍-场景1-容器网络问题"><a href="#🔍-场景1-容器网络问题" class="headerlink" title="🔍 场景1: 容器网络问题"></a>🔍 场景1: 容器网络问题</h3><p><strong>症状</strong>: 容器无法访问网络，DNS解析失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 查看容器网络命名空间</span></span><br><span class="line">docker inspect &lt;container&gt; | grep NetworkMode</span><br><span class="line">lsns -t net | grep &lt;container-pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 进入容器网络命名空间排查</span></span><br><span class="line">nsenter -t &lt;container-pid&gt; -n bash</span><br><span class="line">ip addr show                    <span class="comment"># 查看网络接口</span></span><br><span class="line">ip route show                   <span class="comment"># 查看路由表</span></span><br><span class="line"><span class="built_in">cat</span> /etc/resolv.conf            <span class="comment"># 查看DNS配置</span></span><br><span class="line">ping 8.8.8.8                    <span class="comment"># 测试网络连通性</span></span><br><span class="line">nslookup google.com             <span class="comment"># 测试DNS解析</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 对比宿主机网络</span></span><br><span class="line"><span class="built_in">exit</span>  <span class="comment"># 退出容器网络命名空间</span></span><br><span class="line">ip addr show                    <span class="comment"># 宿主机网络接口</span></span><br><span class="line">ip route show                   <span class="comment"># 宿主机路由表</span></span><br></pre></td></tr></table></figure>

<h3 id="🔍-场景2-容器文件系统问题"><a href="#🔍-场景2-容器文件系统问题" class="headerlink" title="🔍 场景2: 容器文件系统问题"></a>🔍 场景2: 容器文件系统问题</h3><p><strong>症状</strong>: 容器内文件丢失，挂载点异常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 查看挂载命名空间</span></span><br><span class="line">lsns -t mnt | grep &lt;container-pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 进入容器挂载命名空间</span></span><br><span class="line">nsenter -t &lt;container-pid&gt; -m bash</span><br><span class="line">mount | grep &lt;path&gt;             <span class="comment"># 查看特定路径挂载</span></span><br><span class="line"><span class="built_in">df</span> -h                           <span class="comment"># 查看磁盘使用</span></span><br><span class="line">findmnt                         <span class="comment"># 详细挂载信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 对比宿主机挂载</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">mount | grep &lt;container-volume&gt;</span><br><span class="line">docker inspect &lt;container&gt; | grep Mounts</span><br></pre></td></tr></table></figure>

<h3 id="🔍-场景3-进程PID问题"><a href="#🔍-场景3-进程PID问题" class="headerlink" title="🔍 场景3: 进程PID问题"></a>🔍 场景3: 进程PID问题</h3><p><strong>症状</strong>: 容器内PID冲突，进程管理异常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 查看PID命名空间</span></span><br><span class="line">lsns -t pid | grep &lt;container-pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 进入容器PID命名空间</span></span><br><span class="line">nsenter -t &lt;container-pid&gt; -p bash</span><br><span class="line">ps aux                          <span class="comment"># 查看容器内进程</span></span><br><span class="line">pstree                          <span class="comment"># 进程树</span></span><br><span class="line"><span class="built_in">cat</span> /proc/1/cmdline             <span class="comment"># 容器内PID 1进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查看宿主机视角的进程</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">ps aux | grep &lt;container-name&gt;</span><br><span class="line">pstree -p &lt;container-pid&gt;</span><br></pre></td></tr></table></figure>

<h3 id="🔍-场景4-用户权限问题"><a href="#🔍-场景4-用户权限问题" class="headerlink" title="🔍 场景4: 用户权限问题"></a>🔍 场景4: 用户权限问题</h3><p><strong>症状</strong>: 容器内用户权限异常，文件访问被拒绝</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 查看用户命名空间</span></span><br><span class="line">lsns -t user | grep &lt;container-pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 检查用户映射</span></span><br><span class="line"><span class="built_in">cat</span> /proc/&lt;container-pid&gt;/uid_map</span><br><span class="line"><span class="built_in">cat</span> /proc/&lt;container-pid&gt;/gid_map</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 进入容器用户命名空间</span></span><br><span class="line">nsenter -t &lt;container-pid&gt; -U bash</span><br><span class="line"><span class="built_in">id</span>                              <span class="comment"># 查看当前用户</span></span><br><span class="line"><span class="built_in">whoami</span></span><br><span class="line"><span class="built_in">ls</span> -la /                        <span class="comment"># 查看文件权限</span></span><br></pre></td></tr></table></figure>

<h3 id="🔍-场景5-系统调用和cgroup问题"><a href="#🔍-场景5-系统调用和cgroup问题" class="headerlink" title="🔍 场景5: 系统调用和cgroup问题"></a>🔍 场景5: 系统调用和cgroup问题</h3><p><strong>症状</strong>: 容器资源限制异常，性能问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 查看cgroup命名空间</span></span><br><span class="line">lsns -t cgroup | grep &lt;container-pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 检查cgroup配置</span></span><br><span class="line"><span class="built_in">cat</span> /proc/&lt;container-pid&gt;/cgroup</span><br><span class="line">systemd-cgls | grep &lt;container&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查看资源使用</span></span><br><span class="line">docker stats &lt;container&gt;</span><br><span class="line"><span class="built_in">cat</span> /sys/fs/cgroup/memory/docker/&lt;container-id&gt;/memory.usage_in_bytes</span><br><span class="line"><span class="built_in">cat</span> /sys/fs/cgroup/cpu/docker/&lt;container-id&gt;/cpu.shares</span><br></pre></td></tr></table></figure>

<h3 id="🔍-场景6-Kubernetes-Pod网络问题"><a href="#🔍-场景6-Kubernetes-Pod网络问题" class="headerlink" title="🔍 场景6: Kubernetes Pod网络问题"></a>🔍 场景6: Kubernetes Pod网络问题</h3><p><strong>症状</strong>: Pod间通信失败，Service访问异常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 查找Pod进程</span></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line">ps aux | grep &lt;pod-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看Pod网络命名空间</span></span><br><span class="line">PID=$(pgrep -f &lt;pod-container&gt;)</span><br><span class="line">lsns -t net | grep <span class="variable">$PID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 进入Pod网络空间排查</span></span><br><span class="line">nsenter -t <span class="variable">$PID</span> -n bash</span><br><span class="line">ip addr show                    <span class="comment"># 查看Pod IP</span></span><br><span class="line">ip route show                   <span class="comment"># 查看路由</span></span><br><span class="line">iptables -L                     <span class="comment"># 查看防火墙规则（如果有权限）</span></span><br><span class="line">nslookup kubernetes.default     <span class="comment"># 测试集群DNS</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查看CNI配置</span></span><br><span class="line"><span class="built_in">cat</span> /etc/cni/net.d/*            <span class="comment"># CNI插件配置</span></span><br><span class="line">ip <span class="built_in">link</span> show                    <span class="comment"># 网络设备</span></span><br></pre></td></tr></table></figure>

<h3 id="🔍-场景7-容器启动失败"><a href="#🔍-场景7-容器启动失败" class="headerlink" title="🔍 场景7: 容器启动失败"></a>🔍 场景7: 容器启动失败</h3><p><strong>症状</strong>: 容器启动后立即退出，状态异常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 查看容器日志</span></span><br><span class="line">docker logs &lt;container&gt;</span><br><span class="line">kubectl logs &lt;pod&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看容器命名空间状态</span></span><br><span class="line">docker inspect &lt;container&gt; | grep State -A 10</span><br><span class="line">lsns | grep &lt;container-name&gt;    <span class="comment"># 看是否还有命名空间残留</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 模拟容器环境调试</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> &lt;image&gt; bash</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">kubectl run debug-pod --image=&lt;image&gt; -it --<span class="built_in">rm</span> -- bash</span><br></pre></td></tr></table></figure>

<h2 id="命名空间排查最佳实践"><a href="#命名空间排查最佳实践" class="headerlink" title="命名空间排查最佳实践"></a>命名空间排查最佳实践</h2><h3 id="1-排查流程"><a href="#1-排查流程" class="headerlink" title="1. 排查流程"></a>1. 排查流程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Step 1: 识别问题进程</span></span><br><span class="line">ps aux | grep &lt;service-name&gt;</span><br><span class="line">pgrep -f &lt;pattern&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 2: 查看命名空间概况</span></span><br><span class="line">lsns -p &lt;PID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3: 针对性进入问题命名空间</span></span><br><span class="line">nsenter -t &lt;PID&gt; -n -p -m bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 4: 在命名空间内排查</span></span><br><span class="line"><span class="comment"># 网络: ip addr, ip route, netstat</span></span><br><span class="line"><span class="comment"># 文件系统: mount, df, ls</span></span><br><span class="line"><span class="comment"># 进程: ps, pstree</span></span><br><span class="line"><span class="comment"># 权限: id, whoami, ls -la</span></span><br></pre></td></tr></table></figure>

<h3 id="2-常用组合命令"><a href="#2-常用组合命令" class="headerlink" title="2. 常用组合命令"></a>2. 常用组合命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快速查看容器所有命名空间信息</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">container_ns_info</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> pid=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;=== 命名空间概况 ===&quot;</span></span><br><span class="line">    lsns -p <span class="variable">$pid</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\n=== 网络信息 ===&quot;</span></span><br><span class="line">    nsenter -t <span class="variable">$pid</span> -n ip addr show</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\n=== 挂载信息 ===&quot;</span></span><br><span class="line">    nsenter -t <span class="variable">$pid</span> -m mount | <span class="built_in">head</span> -10</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\n=== 进程信息 ===&quot;</span></span><br><span class="line">    nsenter -t <span class="variable">$pid</span> -p ps aux | <span class="built_in">head</span> -10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用: container_ns_info &lt;PID&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-监控脚本"><a href="#3-监控脚本" class="headerlink" title="3. 监控脚本"></a>3. 监控脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># ns_monitor.sh - 命名空间监控脚本</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=== 命名空间统计 ===&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;类型统计:&quot;</span></span><br><span class="line">lsns | awk <span class="string">&#x27;NR&gt;1 &#123;print $2&#125;&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\n进程数最多的命名空间:&quot;</span></span><br><span class="line">lsns | awk <span class="string">&#x27;NR&gt;1 &#123;print $2, $3, $5&#125;&#x27;</span> | <span class="built_in">sort</span> -k2 -nr | <span class="built_in">head</span> -5</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\n容器相关命名空间:&quot;</span></span><br><span class="line">lsns | grep -E <span class="string">&quot;(docker|containerd|runc)&quot;</span> | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>⚠️ <strong>安全提醒</strong>:</p>
<ul>
<li>使用<code>nsenter</code>需要root权限或相应的capabilities</li>
<li>进入生产容器命名空间要谨慎，避免影响业务</li>
<li>某些命名空间操作可能影响系统稳定性</li>
</ul>
<p>💡 <strong>最佳实践</strong>:</p>
<ul>
<li>先用<code>lsns</code>观察，再用<code>nsenter</code>进入</li>
<li>排查时记录操作步骤，便于复现和分析</li>
<li>结合容器编排工具的日志和状态信息</li>
<li>定期监控命名空间数量，避免泄漏</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>MTU完整指南和故障排查</title>
    <url>/2025/09/16/MTU%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97%E5%92%8C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<h2 id="🎯-MTU快速理解"><a href="#🎯-MTU快速理解" class="headerlink" title="🎯 MTU快速理解"></a>🎯 MTU快速理解</h2><h3 id="什么是MTU？"><a href="#什么是MTU？" class="headerlink" title="什么是MTU？"></a>什么是MTU？</h3><p><strong>MTU (Maximum Transmission Unit)</strong> &#x3D; 网络接口一次能传输的最大数据包大小（字节）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简单类比：</span><br><span class="line">MTU就像货车的载重限制</span><br><span class="line">- 货车限重5吨，装6吨就超载了</span><br><span class="line">- 网卡MTU=1500，发送1600字节包就会有问题</span><br></pre></td></tr></table></figure>

<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">标准以太网MTU = 1500字节</span><br><span class="line">├── IP头: 20字节</span><br><span class="line">├── TCP头: 20字节  </span><br><span class="line">└── 数据载荷: 最大1460字节</span><br><span class="line"></span><br><span class="line">虚拟化环境MTU &lt; 1500字节</span><br><span class="line">├── 原始数据: 1460字节</span><br><span class="line">├── TCP/IP头: 40字节</span><br><span class="line">├── 虚拟化开销: 50字节</span><br><span class="line">└── 总计: 1550字节 &gt; 1500字节 ❌超出限制</span><br></pre></td></tr></table></figure>

<h2 id="🔍-MTU检测和查看命令"><a href="#🔍-MTU检测和查看命令" class="headerlink" title="🔍 MTU检测和查看命令"></a>🔍 MTU检测和查看命令</h2><h3 id="1-查看当前MTU值"><a href="#1-查看当前MTU值" class="headerlink" title="1. 查看当前MTU值"></a>1. 查看当前MTU值</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有网络接口MTU</span></span><br><span class="line">ip <span class="built_in">link</span> show</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定接口</span></span><br><span class="line">ip <span class="built_in">link</span> show eth0</span><br><span class="line">ip <span class="built_in">link</span> show docker0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一行命令查看所有接口MTU</span></span><br><span class="line">ip -o <span class="built_in">link</span> show | awk <span class="string">&#x27;&#123;print $2, $5&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-测试MTU大小"><a href="#2-测试MTU大小" class="headerlink" title="2. 测试MTU大小"></a>2. 测试MTU大小</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ping测试MTU (Linux)</span></span><br><span class="line">ping -M <span class="keyword">do</span> -s 1472 8.8.8.8    <span class="comment"># 1472 + 28(ICMP头) = 1500</span></span><br><span class="line">ping -M <span class="keyword">do</span> -s 1500 8.8.8.8    <span class="comment"># 会失败，因为加上头部超过MTU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Windows下测试</span></span><br><span class="line">ping -f -l 1472 8.8.8.8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动发现路径MTU</span></span><br><span class="line">tracepath google.com</span><br></pre></td></tr></table></figure>

<h3 id="3-Docker-MTU查看"><a href="#3-Docker-MTU查看" class="headerlink" title="3. Docker MTU查看"></a>3. Docker MTU查看</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看Docker网络MTU</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line">docker network inspect bridge | grep -i mtu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器网络MTU</span></span><br><span class="line">docker <span class="built_in">exec</span> &lt;container&gt; ip <span class="built_in">link</span> show eth0</span><br></pre></td></tr></table></figure>

<h2 id="⚙️-MTU配置方法"><a href="#⚙️-MTU配置方法" class="headerlink" title="⚙️ MTU配置方法"></a>⚙️ MTU配置方法</h2><h3 id="1-临时修改MTU"><a href="#1-临时修改MTU" class="headerlink" title="1. 临时修改MTU"></a>1. 临时修改MTU</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改网络接口MTU</span></span><br><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev eth0 mtu 1450</span><br><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev docker0 mtu 1450</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改Docker桥接MTU</span></span><br><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev docker0 down</span><br><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev docker0 mtu 1450</span><br><span class="line"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev docker0 up</span><br></pre></td></tr></table></figure>

<h3 id="2-永久配置MTU"><a href="#2-永久配置MTU" class="headerlink" title="2. 永久配置MTU"></a>2. 永久配置MTU</h3><h4 id="Docker-daemon配置"><a href="#Docker-daemon配置" class="headerlink" title="Docker daemon配置"></a>Docker daemon配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mtu&quot;</span>: 1450,</span><br><span class="line">  <span class="string">&quot;bridge&quot;</span>: <span class="string">&quot;docker0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启Docker服务</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="系统网络接口配置"><a href="#系统网络接口配置" class="headerlink" title="系统网络接口配置"></a>系统网络接口配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CentOS/RHEL: /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">MTU=1450</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu: /etc/netplan/01-netcfg.yaml</span></span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  ethernets:</span><br><span class="line">    eth0:</span><br><span class="line">      mtu: 1450</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用配置</span></span><br><span class="line"><span class="built_in">sudo</span> netplan apply</span><br></pre></td></tr></table></figure>

<h3 id="3-Kubernetes环境MTU配置"><a href="#3-Kubernetes环境MTU配置" class="headerlink" title="3. Kubernetes环境MTU配置"></a>3. Kubernetes环境MTU配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CNI插件配置 (以Calico为例)</span></span><br><span class="line"><span class="comment"># /etc/cni/net.d/10-calico.conf</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;k8s-pod-network&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cniVersion&quot;</span>: <span class="string">&quot;0.3.1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;calico&quot;</span>,</span><br><span class="line">      <span class="string">&quot;mtu&quot;</span>: 1450</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="🚨-需要关注MTU的场景"><a href="#🚨-需要关注MTU的场景" class="headerlink" title="🚨 需要关注MTU的场景"></a>🚨 需要关注MTU的场景</h2><h3 id="1-虚拟化环境-⭐⭐⭐"><a href="#1-虚拟化环境-⭐⭐⭐" class="headerlink" title="1. 虚拟化环境 ⭐⭐⭐"></a>1. 虚拟化环境 ⭐⭐⭐</h3><p><strong>场景</strong>: VMware、KVM、Hyper-V等虚拟机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查命令</span></span><br><span class="line">ip <span class="built_in">link</span> show | grep mtu</span><br><span class="line">ping -M <span class="keyword">do</span> -s 1472 &lt;target&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常见问题</span></span><br><span class="line">- VM网卡MTU=1500，但物理网卡实际支持&lt;1500</span><br><span class="line">- 多层虚拟化叠加导致MTU递减</span><br><span class="line">- VXLAN/GRE隧道额外开销</span><br></pre></td></tr></table></figure>

<h3 id="2-容器环境-⭐⭐⭐"><a href="#2-容器环境-⭐⭐⭐" class="headerlink" title="2. 容器环境 ⭐⭐⭐"></a>2. 容器环境 ⭐⭐⭐</h3><p><strong>场景</strong>: Docker、Kubernetes、容器网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查命令</span></span><br><span class="line">docker network inspect bridge</span><br><span class="line">kubectl get nodes -o custom-columns=<span class="string">&quot;NAME:.metadata.name,MTU:.status.addresses[0].type&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常见问题</span></span><br><span class="line">- Docker桥接网络MTU不匹配</span><br><span class="line">- Overlay网络额外封装</span><br><span class="line">- CNI插件配置错误</span><br></pre></td></tr></table></figure>

<h3 id="3-云环境-⭐⭐"><a href="#3-云环境-⭐⭐" class="headerlink" title="3. 云环境 ⭐⭐"></a>3. 云环境 ⭐⭐</h3><p><strong>场景</strong>: AWS、阿里云、腾讯云等公有云</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查命令</span></span><br><span class="line">curl -s http://169.254.169.254/latest/meta-data/network/interfaces/macs/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常见问题</span></span><br><span class="line">- 云主机默认MTU可能&lt;1500</span><br><span class="line">- VPC网络间MTU不一致</span><br><span class="line">- 跨可用区网络MTU差异</span><br></pre></td></tr></table></figure>

<h3 id="4-SD-WAN-隧道网络-⭐⭐"><a href="#4-SD-WAN-隧道网络-⭐⭐" class="headerlink" title="4. SD-WAN&#x2F;隧道网络 ⭐⭐"></a>4. SD-WAN&#x2F;隧道网络 ⭐⭐</h3><p><strong>场景</strong>: VPN、专线、隧道连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查命令</span></span><br><span class="line">tracepath &lt;remote-host&gt;</span><br><span class="line">mtr --report &lt;remote-host&gt;</span><br><span class="line">mtr -rn www.baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#参考</span></span><br><span class="line">https://www.cnblogs.com/xzongblogs/p/15062134.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常见问题</span></span><br><span class="line">- VPN隧道额外开销</span><br><span class="line">- MPLS网络MTU限制</span><br><span class="line">- 跨运营商网络MTU不统一</span><br></pre></td></tr></table></figure>

<h2 id="🛠️-MTU故障排查流程"><a href="#🛠️-MTU故障排查流程" class="headerlink" title="🛠️ MTU故障排查流程"></a>🛠️ MTU故障排查流程</h2><h3 id="阶段1-症状识别"><a href="#阶段1-症状识别" class="headerlink" title="阶段1: 症状识别"></a>阶段1: 症状识别</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常见症状</span></span><br><span class="line">✓ 大文件传输失败或很慢</span><br><span class="line">✓ SSH连接建立后命令执行卡死</span><br><span class="line">✓ HTTP请求间歇性失败</span><br><span class="line">✓ 数据库连接超时</span><br><span class="line">✓ 文件上传失败</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速检测命令</span></span><br><span class="line">ping -M <span class="keyword">do</span> -s 1472 &lt;target&gt;     <span class="comment"># 测试是否能通</span></span><br><span class="line">ping -M <span class="keyword">do</span> -s 1400 &lt;target&gt;     <span class="comment"># 降低测试</span></span><br></pre></td></tr></table></figure>

<h3 id="阶段2-MTU路径发现"><a href="#阶段2-MTU路径发现" class="headerlink" title="阶段2: MTU路径发现"></a>阶段2: MTU路径发现</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1: tracepath (推荐)</span></span><br><span class="line">tracepath google.com</span><br><span class="line"><span class="comment"># 输出会显示路径上的MTU值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2: ping二分法测试</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">find_mtu</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> host=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> low=1</span><br><span class="line">    <span class="built_in">local</span> high=1500</span><br><span class="line">    <span class="keyword">while</span> [ <span class="variable">$low</span> -lt <span class="variable">$high</span> ]; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">local</span> mid=$(( (low + high + <span class="number">1</span>) / <span class="number">2</span> ))</span><br><span class="line">        <span class="keyword">if</span> ping -c 1 -M <span class="keyword">do</span> -s <span class="variable">$mid</span> <span class="variable">$host</span> &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">            low=<span class="variable">$mid</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high=$((mid - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;最大MTU: <span class="subst">$((low + 28)</span>)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用: find_mtu google.com</span></span><br></pre></td></tr></table></figure>

<h3 id="阶段3-分层排查"><a href="#阶段3-分层排查" class="headerlink" title="阶段3: 分层排查"></a>阶段3: 分层排查</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 主机网络层</span></span><br><span class="line">ip <span class="built_in">link</span> show                    <span class="comment"># 查看接口MTU</span></span><br><span class="line"><span class="built_in">cat</span> /proc/net/route             <span class="comment"># 查看路由表</span></span><br><span class="line">netstat -i                      <span class="comment"># 查看网络统计</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 虚拟化层</span></span><br><span class="line"><span class="comment"># VMware</span></span><br><span class="line">vmware-toolbox-cmd <span class="built_in">stat</span> speed</span><br><span class="line"><span class="comment"># KVM</span></span><br><span class="line">virsh domiflist &lt;vm-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 容器层</span></span><br><span class="line">docker network inspect bridge</span><br><span class="line">kubectl describe node | grep -i mtu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 应用层</span></span><br><span class="line">ss -i                           <span class="comment"># 查看TCP连接信息</span></span><br><span class="line">netstat -s | grep -i fragment   <span class="comment"># 查看分片统计</span></span><br></pre></td></tr></table></figure>

<h3 id="阶段4-性能验证"><a href="#阶段4-性能验证" class="headerlink" title="阶段4: 性能验证"></a>阶段4: 性能验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试脚本</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># mtu_test.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=== MTU性能测试 ===&quot;</span></span><br><span class="line"><span class="keyword">for</span> size <span class="keyword">in</span> 1400 1450 1472 1500; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -n <span class="string">&quot;测试 MTU <span class="variable">$size</span>: &quot;</span></span><br><span class="line">    <span class="keyword">if</span> ping -c 3 -M <span class="keyword">do</span> -s $((size-<span class="number">28</span>)) 8.8.8.8 &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;✓ 通过&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;✗ 失败&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h2 id="📊-不同场景的MTU推荐值"><a href="#📊-不同场景的MTU推荐值" class="headerlink" title="📊 不同场景的MTU推荐值"></a>📊 不同场景的MTU推荐值</h2><h3 id="标准网络环境"><a href="#标准网络环境" class="headerlink" title="标准网络环境"></a>标准网络环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">以太网: 1500          <span class="comment"># 标准值</span></span><br><span class="line">千兆以太网: 9000      <span class="comment"># Jumbo Frame</span></span><br><span class="line">Wi-Fi: 1500           <span class="comment"># 通常与以太网相同</span></span><br></pre></td></tr></table></figure>

<h3 id="虚拟化环境"><a href="#虚拟化环境" class="headerlink" title="虚拟化环境"></a>虚拟化环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VMware vSphere: 1450-1480    <span class="comment"># 考虑VXLAN开销</span></span><br><span class="line">KVM/QEMU: 1450               <span class="comment"># 保守值</span></span><br><span class="line">Hyper-V: 1500                <span class="comment"># 通常支持标准值</span></span><br><span class="line">Docker: 1450-1480            <span class="comment"># 取决于底层网络</span></span><br></pre></td></tr></table></figure>

<h3 id="云环境"><a href="#云环境" class="headerlink" title="云环境"></a>云环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AWS EC2: 1500 (enhanced networking)</span><br><span class="line">       : 1500-9000 (placement group)</span><br><span class="line">阿里云ECS: 1500</span><br><span class="line">腾讯云CVM: 1500</span><br><span class="line">Azure VM: 1500</span><br></pre></td></tr></table></figure>

<h3 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Docker bridge: 1450-1480</span><br><span class="line">Kubernetes:</span><br><span class="line">  - Flannel: 1450</span><br><span class="line">  - Calico: 1440-1480  </span><br><span class="line">  - Weave: 1376</span><br><span class="line">  - Cilium: 1450</span><br></pre></td></tr></table></figure>

<h2 id="🔧-自动化MTU管理脚本"><a href="#🔧-自动化MTU管理脚本" class="headerlink" title="🔧 自动化MTU管理脚本"></a>🔧 自动化MTU管理脚本</h2><h3 id="MTU检测脚本"><a href="#MTU检测脚本" class="headerlink" title="MTU检测脚本"></a>MTU检测脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># auto_mtu_detect.sh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">detect_optimal_mtu</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> target=<span class="variable">$&#123;1:-8.8.8.8&#125;</span></span><br><span class="line">    <span class="built_in">local</span> max_mtu=1500</span><br><span class="line">    <span class="built_in">local</span> min_mtu=1200</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;正在检测到 <span class="variable">$target</span> 的最优MTU...&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ((mtu=max_mtu; mtu&gt;=min_mtu; mtu-=<span class="number">50</span>)); <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> ping -c 2 -M <span class="keyword">do</span> -s $((mtu-<span class="number">28</span>)) <span class="variable">$target</span> &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;发现可用MTU: <span class="variable">$mtu</span>&quot;</span></span><br><span class="line">            <span class="comment"># 精确搜索</span></span><br><span class="line">            <span class="keyword">for</span> ((i=mtu; i&lt;=mtu+<span class="number">50</span>; i++)); <span class="keyword">do</span></span><br><span class="line">                <span class="keyword">if</span> ! ping -c 1 -M <span class="keyword">do</span> -s $((i-<span class="number">28</span>)) <span class="variable">$target</span> &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">echo</span> <span class="string">&quot;最优MTU: <span class="subst">$((i-1)</span>)&quot;</span></span><br><span class="line">                    <span class="built_in">return</span></span><br><span class="line">                <span class="keyword">fi</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;未能检测到合适的MTU值&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">detect_optimal_mtu</span><br></pre></td></tr></table></figure>

<h3 id="系统MTU配置脚本"><a href="#系统MTU配置脚本" class="headerlink" title="系统MTU配置脚本"></a>系统MTU配置脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># set_system_mtu.sh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">set_system_mtu</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> mtu=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> interface=<span class="variable">$&#123;2:-eth0&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;设置 <span class="variable">$interface</span> MTU为 <span class="variable">$mtu</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 临时设置</span></span><br><span class="line">    <span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev <span class="variable">$interface</span> mtu <span class="variable">$mtu</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 永久设置 (Ubuntu)</span></span><br><span class="line">    <span class="keyword">if</span> [[ -f /etc/netplan/01-netcfg.yaml ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">sudo</span> sed -i <span class="string">&quot;/mtu:/d&quot;</span> /etc/netplan/01-netcfg.yaml</span><br><span class="line">        <span class="built_in">sudo</span> sed -i <span class="string">&quot;/dhcp4: true/a\\      mtu: <span class="variable">$mtu</span>&quot;</span> /etc/netplan/01-netcfg.yaml</span><br><span class="line">        <span class="built_in">sudo</span> netplan apply</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Docker配置</span></span><br><span class="line">    <span class="keyword">if</span> systemctl is-active --quiet docker; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;配置Docker MTU...&quot;</span></span><br><span class="line">        <span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&#x27;&#123;&quot;mtu&quot;: &#x27;</span><span class="variable">$mtu</span><span class="string">&#x27;&#125;&#x27;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json</span><br><span class="line">        <span class="built_in">sudo</span> systemctl restart docker</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;MTU配置完成&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用: set_system_mtu 1450</span></span><br></pre></td></tr></table></figure>

<h2 id="⚠️-注意事项和最佳实践"><a href="#⚠️-注意事项和最佳实践" class="headerlink" title="⚠️ 注意事项和最佳实践"></a>⚠️ 注意事项和最佳实践</h2><h3 id="安全注意事项"><a href="#安全注意事项" class="headerlink" title="安全注意事项"></a>安全注意事项</h3><ul>
<li><strong>生产环境修改要谨慎</strong>: MTU修改可能导致网络中断</li>
<li><strong>逐步调整</strong>: 从小值开始，逐步调整到最优值</li>
<li><strong>备份配置</strong>: 修改前备份网络配置文件</li>
<li><strong>测试验证</strong>: 修改后充分测试网络连通性</li>
</ul>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li><strong>自动发现优于手动配置</strong>: 使用工具自动检测最优MTU</li>
<li><strong>分层一致性</strong>: 确保各网络层MTU配置一致</li>
<li><strong>监控告警</strong>: 监控网络分片和丢包情况</li>
<li><strong>文档记录</strong>: 记录MTU配置的原因和数值</li>
</ol>
<h3 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h3><p>❌ <strong>认为MTU越大越好</strong>: 不是的，要匹配网络环境<br>❌ <strong>只设置应用层MTU</strong>: 需要全链路一致<br>❌ <strong>忽略虚拟化开销</strong>: 虚拟环境需要预留开销<br>❌ <strong>设置后不验证</strong>: 必须通过实际测试验证效果</p>
]]></content>
  </entry>
  <entry>
    <title>容器文件系统挂载</title>
    <url>/2025/09/19/%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="1-查看挂载情况"><a href="#1-查看挂载情况" class="headerlink" title="1. 查看挂载情况"></a>1. 查看挂载情况</h2><ul>
<li><p><strong>看挂载情况</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount | grep /run/containerd/io.containerd.runtime.v2.task/k8s.io</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>看是否有进程占用</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y psmisc</span><br><span class="line">fuser -vm /run/containerd/io.containerd.runtime.v2.task/k8s.io/200ab1146de738bcbe79e3e976eada34003b61de007a61d4b29f007eb5381bf9</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof | grep 200ab1146de</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>看 containerd 里是否有残留 metadata</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctr -n k8s.io containers list | grep 200ab1146de</span><br><span class="line">ctr -n k8s.io tasks list | grep 200ab1146de</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><strong><code>ctr -n k8s.io tasks list | grep 200ab1146de</code> → 状态 STOPPED</strong></li>
<li><strong><code>fuser -vm</code> 显示很多 <code>containerd-shim</code>、<code>qemu-system-x86</code>、<code>virtiofsd</code> 等进程引用这个目录</strong><ul>
<li>说明这个目录（mountpoint）仍然被多个进程占用着。</li>
<li>注意：这里的 “F.c..” &#x2F; “frc..” 表示打开了这个目录的 <strong>文件描述符</strong>，并且有读写&#x2F;控制引用。</li>
</ul>
</li>
<li><strong>整体情况</strong><ul>
<li>内核 <code>overlayfs</code> 挂载点还在，inode 没回收。</li>
<li>容器已经 “STOPPED”（不可用），但是挂载点被其他 shim &#x2F; qemu &#x2F; virtiofsd 引用，所以无法自动卸载。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-mount-l-命令含义："><a href="#2-mount-l-命令含义：" class="headerlink" title="2. mount -l 命令含义："></a>2. mount -l 命令含义：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount | grep <span class="string">&#x27;/run/containerd/io.containerd.runtime.v2.task/k8s.io&#x27;</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> | xargs -r <span class="built_in">sudo</span> umount -l</span><br></pre></td></tr></table></figure>

<h3 id="这个命令会做什么？"><a href="#这个命令会做什么？" class="headerlink" title="这个命令会做什么？"></a>这个命令会做什么？</h3><ul>
<li>找出所有挂载在 <code>/run/containerd/io.containerd.runtime.v2.task/k8s.io/*</code> 下的 mount point。</li>
<li>对它们执行 <code>umount -l</code>（lazy umount）。</li>
</ul>
<p><strong>lazy umount 含义</strong>：</p>
<ul>
<li>马上把挂载点从 mount namespace 里“摘掉”，进程不再能通过路径访问它。</li>
<li>如果有进程仍然持有 fd，会等它们关闭 fd 之后再真正释放资源（inode、dentry、slab）。</li>
<li>这样避免了 <code>umount</code> 报错 “busy”，算是比较温和的方式。</li>
</ul>
<hr>
<h2 id="3-对当前系统的影响"><a href="#3-对当前系统的影响" class="headerlink" title="3. 对当前系统的影响"></a>3. 对当前系统的影响</h2><ul>
<li><p><strong>如果容器仍然活跃</strong>：对应 Pod 会立刻失效，因为 rootfs 被摘掉了，里面的文件系统消失。</p>
</li>
<li><p><strong>如果容器已经 STOPPED</strong>（像你这种）：</p>
<ul>
<li>大多数情况下影响有限，等价于清理垃圾挂载点。</li>
<li>不过要小心：如果 containerd metadata 里还记录这个容器存在，containerd 在后续 GC 或者回收时可能会发现找不到挂载点，从而报错。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-建议操作顺序"><a href="#4-建议操作顺序" class="headerlink" title="4. 建议操作顺序"></a>4. 建议操作顺序</h2><p>更温和的方案可以这样分级：</p>
<ol>
<li><p><strong>优先让 containerd 清理</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctr -n k8s.io tasks <span class="built_in">rm</span> 200ab1146de738bcbe79e3e976eada34003b61de007a61d4b29f007eb5381bf9</span><br><span class="line">ctr -n k8s.io containers <span class="built_in">rm</span> 200ab1146de738bcbe79e3e976eada34003b61de007a61d4b29f007eb5381bf9</span><br></pre></td></tr></table></figure>

<p>（如果卡住，说明 shim&#x2F;进程依赖还在）</p>
</li>
<li><p><strong>确认 mount</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount | grep 200ab1146de</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>再 lazy umount</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> umount -l /run/containerd/io.containerd.runtime.v2.task/k8s.io/200ab1146de738bcbe79e3e976eada34003b61de007a61d4b29f007eb5381bf9/rootfs</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>最后清理目录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /run/containerd/io.containerd.runtime.v2.task/k8s.io/200ab1146de738bcbe79e3e976eada34003b61de007a61d4b29f007eb5381bf9</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如果有大量残留</strong>，你那个 <code>awk | xargs umount -l</code> 可以作为批量清理手段，但最好在确认这些容器都已经 STOPPED 或已被 K8s 删除的前提下做。</p>
</li>
</ol>
<hr>
<p>✅ 结论：</p>
<ul>
<li>你的 <code>umount -l</code> 是温和可行的，不会直接 kill 进程，但会让容器 rootfs 消失。</li>
<li><strong>如果只是清理 STOPPED 的残留容器</strong>，几乎没副作用，还能回收 inode&#x2F;slab。</li>
<li>建议 <strong>先用 ctr rm</strong> 尝试让 containerd 自己清理，再手动 umount + rm 兜底。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>bash_profile配置</title>
    <url>/2025/09/23/bash-profile%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="bash-profile配置"><a href="#bash-profile配置" class="headerlink" title=".bash_profile配置"></a>.bash_profile配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">############################</span><br><span class="line"># 基础工具增强</span><br><span class="line">############################</span><br><span class="line">alias grep=&#x27;grep --color=auto&#x27;</span><br><span class="line">alias fgrep=&#x27;fgrep --color=auto&#x27;</span><br><span class="line">alias egrep=&#x27;egrep --color=auto&#x27;</span><br><span class="line">alias lzd=&#x27;lazydocker&#x27;   # 轻量级 Docker 管理工具</span><br><span class="line"></span><br><span class="line">############################</span><br><span class="line"># Kubernetes 基础命令</span><br><span class="line">############################</span><br><span class="line">alias k=&#x27;kubecolor&#x27;                         # 彩色 kubectl 输出</span><br><span class="line">alias kn=&#x27;k get nodes&#x27;                      # 查看节点</span><br><span class="line">alias knw=&#x27;k get nodes -o wide&#x27;             # 查看节点详情</span><br><span class="line">alias kp=&#x27;k get pod -o wide&#x27;                # 当前命名空间 Pod</span><br><span class="line">alias kpa=&#x27;k get pod -A -o wide&#x27;            # 所有命名空间 Pod</span><br><span class="line">alias kgn=&#x27;k get ns&#x27;                        # 命名空间</span><br><span class="line">alias kgs=&#x27;k get secret&#x27;                    # Secret</span><br><span class="line">alias ki=&#x27;k get ing&#x27;                        # Ingress</span><br><span class="line">alias kio=&#x27;k get ing -o yaml&#x27;               # Ingress 详细</span><br><span class="line"></span><br><span class="line">############################</span><br><span class="line"># Kubernetes 配置管理</span><br><span class="line">############################</span><br><span class="line">alias kcg=&#x27;k config get-contexts&#x27;           # 查看所有 context</span><br><span class="line">alias kcc=&#x27;k config current-context&#x27;        # 当前 context</span><br><span class="line">alias kcu=&#x27;kubectl config use-context &#x27;     # 切换 context</span><br><span class="line">alias kv=&#x27;k config view&#x27;                    # 查看配置</span><br><span class="line">alias kcn=&#x27;k config view --minify --output &quot;jsonpath=&#123;..namespace&#125;&quot; &#x27;  # 当前 namespace</span><br><span class="line">alias kapi=&#x27;k api-resources --sort-by=name&#x27; # API 资源列表</span><br><span class="line"></span><br><span class="line"># 扩展：krew 插件、kubectl neat 等</span><br><span class="line">alias kk=&#x27;kubectl krew &#x27;                    # krew 插件管理</span><br><span class="line">alias kns=&#x27;kubectl config set-context --current --namespace &#x27;  # 切换 namespace</span><br><span class="line">alias knw=&#x27;k get nodes -o wide&#x27;</span><br><span class="line">alias kn=&#x27;k get nodes&#x27;</span><br><span class="line">alias knyaml=&#x27;k neat -o yaml&#x27;               # 输出格式化 yaml</span><br><span class="line"></span><br><span class="line">############################</span><br><span class="line"># Kubernetes 解释与调试</span><br><span class="line">############################</span><br><span class="line">alias ke=&#x27;kubectl explain &#x27;                 # 解释资源</span><br><span class="line">alias ker=&#x27;kubectl explain --recursive &#x27;    # 递归解释</span><br><span class="line">alias kdr=&#x27;kubectl --dry-run=client -o yaml&#x27; # 生成 yaml 草稿</span><br><span class="line"></span><br><span class="line">############################</span><br><span class="line"># 自定义封装</span><br><span class="line">############################</span><br><span class="line"># 添加 kubeconfig context，简化切换</span><br><span class="line">kcadd() &#123; kubectl kc add -cf /home/shijianpeng/.kube/$1.conf --context-name $1; &#125;</span><br><span class="line">pingt() &#123;</span><br><span class="line">    ping &quot;$@&quot; | ts &#x27;[%Y-%m-%d %H:%M:%S]&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 常用 kc 扩展</span><br><span class="line">alias kc=&#x27;kubectl kc&#x27;</span><br><span class="line">alias kcl=&#x27;kubectl kc list&#x27;</span><br><span class="line">alias kcs=&#x27;kubectl kc switch&#x27;</span><br><span class="line"></span><br><span class="line">############################</span><br><span class="line"># 集群信息</span><br><span class="line">############################</span><br><span class="line">alias kci=&#x27;k cluster-info&#x27;   # 集群信息</span><br><span class="line"># kubectl version</span><br><span class="line"># kubectl api-resources</span><br><span class="line"># kubectl api-versions</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>清理docker缓存数据</title>
    <url>/2025/10/16/%E6%B8%85%E7%90%86docker%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="现象：构建镜像设备无空间"><a href="#现象：构建镜像设备无空间" class="headerlink" title="现象：构建镜像设备无空间"></a>现象：构建镜像设备无空间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#docker build xxx</span><br><span class="line">...</span><br><span class="line">mkdir /tmp/go-build1189934179/b521/: no space left on device</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#查看设备存储</span><br><span class="line">#df -lh</span><br><span class="line">/dev/sda1        99G   54G   41G  57% /</span><br><span class="line">/dev/sdb        100G  100G  945M 100% /data</span><br><span class="line"></span><br><span class="line">#查看docker资源占用情况</span><br><span class="line">#docker system df</span><br><span class="line">TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE</span><br><span class="line">Images          69        15        13.21GB   10.8GB (81%)</span><br><span class="line">Containers      25        0         24.54MB   24.54MB (100%)</span><br><span class="line">Local Volumes   43        1         2.966GB   2.958GB (99%)</span><br><span class="line">Build Cache     376       0         85.73GB   85.73GB</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="🧭-一、总体分析"><a href="#🧭-一、总体分析" class="headerlink" title="🧭 一、总体分析"></a>🧭 一、总体分析</h2><table>
<thead>
<tr>
<th>类型</th>
<th>占用</th>
<th>可回收</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Images</strong></td>
<td>13.21 GB</td>
<td>10.8 GB (81%)</td>
<td>很多旧镜像未使用</td>
</tr>
<tr>
<td><strong>Containers</strong></td>
<td>24 MB</td>
<td>100% 可回收</td>
<td>停止容器未清理</td>
</tr>
<tr>
<td><strong>Local Volumes</strong></td>
<td>2.96 GB</td>
<td>99% 可回收</td>
<td>旧卷未使用</td>
</tr>
<tr>
<td><strong>Build Cache</strong></td>
<td><strong>85.73 GB</strong></td>
<td><strong>85.73 GB (巨量)</strong></td>
<td>Docker build 中产生的大量中间层缓存</td>
</tr>
</tbody></table>
<h2 id="🧹-二、分级清理策略"><a href="#🧹-二、分级清理策略" class="headerlink" title="🧹 二、分级清理策略"></a>🧹 二、分级清理策略</h2><blockquote>
<p>✅ 建议分三步执行，从“安全”到“彻底”。</p>
</blockquote>
<h3 id="1️⃣-安全清理（释放最多空间，低风险）"><a href="#1️⃣-安全清理（释放最多空间，低风险）" class="headerlink" title="1️⃣ 安全清理（释放最多空间，低风险）"></a>1️⃣ 安全清理（释放最多空间，低风险）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除无用 build cache（推荐第一步）</span></span><br><span class="line">docker builder prune</span><br></pre></td></tr></table></figure>

<blockquote>
<p>交互时输入 <code>y</code> 确认即可，通常能释放 80GB 以上空间。<br>不影响现有镜像或运行中的容器。</p>
</blockquote>
<hr>
<h3 id="2️⃣-深度清理（删除所有未使用的镜像、容器、卷）"><a href="#2️⃣-深度清理（删除所有未使用的镜像、容器、卷）" class="headerlink" title="2️⃣ 深度清理（删除所有未使用的镜像、容器、卷）"></a>2️⃣ 深度清理（删除所有未使用的镜像、容器、卷）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker system prune -a --volumes</span><br></pre></td></tr></table></figure>

<p>含义：</p>
<ul>
<li><code>-a</code>：删除所有未被容器使用的镜像（包括悬空镜像 <code>&lt;none&gt;</code>）。</li>
<li><code>--volumes</code>：删除未被挂载的卷。</li>
<li><code>system prune</code>：同时清理 network &#x2F; container &#x2F; build cache。</li>
</ul>
<p>💡 <strong>慎用</strong><br>此命令会删掉所有旧镜像，下次构建会重新拉取（时间成本较高，但可彻底释放空间）。</p>
<hr>
<h3 id="3️⃣-针对性清理（更精细控制）"><a href="#3️⃣-针对性清理（更精细控制）" class="headerlink" title="3️⃣ 针对性清理（更精细控制）"></a>3️⃣ 针对性清理（更精细控制）</h3><h4 id="清理无用镜像"><a href="#清理无用镜像" class="headerlink" title="清理无用镜像"></a>清理无用镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image prune -a</span><br></pre></td></tr></table></figure>

<h4 id="清理停止容器"><a href="#清理停止容器" class="headerlink" title="清理停止容器"></a>清理停止容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure>

<h4 id="清理未使用的卷"><a href="#清理未使用的卷" class="headerlink" title="清理未使用的卷"></a>清理未使用的卷</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure>

<h4 id="清理构建缓存（所有构建器实例）"><a href="#清理构建缓存（所有构建器实例）" class="headerlink" title="清理构建缓存（所有构建器实例）"></a>清理构建缓存（所有构建器实例）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker builder prune --all</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔍-三、查看清理效果"><a href="#🔍-三、查看清理效果" class="headerlink" title="🔍 三、查看清理效果"></a>🔍 三、查看清理效果</h2><p>执行完后再检查空间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker system df</span></span><br><span class="line">TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE</span><br><span class="line">Images          69        15        13.21GB   10.8GB (81%)</span><br><span class="line">Containers      25        0         24.54MB   24.54MB (100%)</span><br><span class="line">Local Volumes   43        1         2.966GB   2.958GB (99%)</span><br><span class="line">Build Cache     63        0         0B        0B</span><br></pre></td></tr></table></figure>

<p>通常 Build Cache 会从 85 GB 降到 &lt;5 GB，磁盘释放非常明显。</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>numactl使用指南</title>
    <url>/2025/10/31/numactl%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="numactl-完整使用指南"><a href="#numactl-完整使用指南" class="headerlink" title="numactl 完整使用指南"></a>numactl 完整使用指南</h1><blockquote>
<p><a href="https://www.cnblogs.com/Xinenhui/p/18316326">https://www.cnblogs.com/Xinenhui/p/18316326</a></p>
</blockquote>
<h2 id="一、numactl-是什么"><a href="#一、numactl-是什么" class="headerlink" title="一、numactl 是什么"></a>一、numactl 是什么</h2><p><strong>numactl</strong> 是一个控制 NUMA 策略和内存分配的工具，允许你：</p>
<ul>
<li>将进程绑定到特定 NUMA 节点</li>
<li>控制进程的内存分配策略</li>
<li>查看 NUMA 拓扑和统计信息</li>
<li>优化多核服务器性能</li>
</ul>
<hr>
<h2 id="二、安装-numactl"><a href="#二、安装-numactl" class="headerlink" title="二、安装 numactl"></a>二、安装 numactl</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CentOS / RHEL</span></span><br><span class="line">yum install -y numactl</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu / Debian</span></span><br><span class="line">apt-get install -y numactl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">numactl --version</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、查看-NUMA-信息"><a href="#三、查看-NUMA-信息" class="headerlink" title="三、查看 NUMA 信息"></a>三、查看 NUMA 信息</h2><h3 id="3-1-查看-NUMA-节点数量"><a href="#3-1-查看-NUMA-节点数量" class="headerlink" title="3.1 查看 NUMA 节点数量"></a>3.1 查看 NUMA 节点数量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法 1: 使用 lscpu</span></span><br><span class="line">lscpu | grep NUMA</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例:</span></span><br><span class="line"><span class="comment"># NUMA node(s):            2</span></span><br><span class="line"><span class="comment"># NUMA node0 CPU(s):       0-15,32-47</span></span><br><span class="line"><span class="comment"># NUMA node1 CPU(s):       16-31,48-63</span></span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>:</p>
<ul>
<li><code>NUMA node(s): 2</code> - 系统有 2 个 NUMA 节点</li>
<li><code>NUMA node0 CPU(s): 0-15,32-47</code> - 节点 0 包含 CPU 0-15 和 32-47（超线程）</li>
<li><code>NUMA node1 CPU(s): 16-31,48-63</code> - 节点 1 包含 CPU 16-31 和 48-63</li>
</ul>
<h3 id="3-2-查看详细-NUMA-拓扑"><a href="#3-2-查看详细-NUMA-拓扑" class="headerlink" title="3.2 查看详细 NUMA 拓扑"></a>3.2 查看详细 NUMA 拓扑</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">numactl --hardware</span><br><span class="line"><span class="comment"># 或简写</span></span><br><span class="line">numactl -H</span><br></pre></td></tr></table></figure>

<p><strong>输出示例</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">available: 2 nodes (0-1)</span><br><span class="line">node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</span><br><span class="line">node 0 size: 65536 MB</span><br><span class="line">node 0 free: 32768 MB</span><br><span class="line">node 1 cpus: 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31</span><br><span class="line">node 1 size: 65536 MB</span><br><span class="line">node 1 free: 45678 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0   1 </span><br><span class="line">  0:  10  21 </span><br><span class="line">  1:  21  10</span><br></pre></td></tr></table></figure>

<p><strong>关键信息解读</strong>:</p>
<ul>
<li><code>node 0 cpus</code> - 节点 0 的 CPU 编号</li>
<li><code>node 0 size</code> - 节点 0 的总内存</li>
<li><code>node 0 free</code> - 节点 0 的空闲内存</li>
<li><code>node distances</code> - 节点间访问成本（10&#x3D;本地，21&#x3D;远程）</li>
</ul>
<h3 id="3-3-查看当前进程的-NUMA-策略"><a href="#3-3-查看当前进程的-NUMA-策略" class="headerlink" title="3.3 查看当前进程的 NUMA 策略"></a>3.3 查看当前进程的 NUMA 策略</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看指定进程的 NUMA 策略</span></span><br><span class="line">numactl --show</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例:</span></span><br><span class="line"><span class="comment"># policy: default</span></span><br><span class="line"><span class="comment"># preferred node: current</span></span><br><span class="line"><span class="comment"># physcpubind: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31</span></span><br><span class="line"><span class="comment"># cpubind: 0 1</span></span><br><span class="line"><span class="comment"># nodebind: 0 1</span></span><br><span class="line"><span class="comment"># membind: 0 1</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、核心功能和常用命令"><a href="#四、核心功能和常用命令" class="headerlink" title="四、核心功能和常用命令"></a>四、核心功能和常用命令</h2><h3 id="4-1-绑定进程到指定-NUMA-节点"><a href="#4-1-绑定进程到指定-NUMA-节点" class="headerlink" title="4.1 绑定进程到指定 NUMA 节点"></a>4.1 绑定进程到指定 NUMA 节点</h3><h4 id="✅-绑定到节点-0"><a href="#✅-绑定到节点-0" class="headerlink" title="✅ 绑定到节点 0"></a>✅ 绑定到节点 0</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将进程绑定到 NUMA 节点 0 的 CPU 和内存</span></span><br><span class="line">numactl --cpunodebind=0 --membind=0 &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例: 在节点 0 运行 nginx</span></span><br><span class="line">numactl --cpunodebind=0 --membind=0 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例: 在节点 1 运行 MySQL</span></span><br><span class="line">numactl --cpunodebind=1 --membind=1 mysqld</span><br></pre></td></tr></table></figure>

<h4 id="✅-绑定到特定-CPU"><a href="#✅-绑定到特定-CPU" class="headerlink" title="✅ 绑定到特定 CPU"></a>✅ 绑定到特定 CPU</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绑定到 CPU 0-7</span></span><br><span class="line">numactl --physcpubind=0-7 --membind=0 &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定到特定 CPU 列表</span></span><br><span class="line">numactl --physcpubind=0,2,4,6 &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-内存分配策略"><a href="#4-2-内存分配策略" class="headerlink" title="4.2 内存分配策略"></a>4.2 内存分配策略</h3><h4 id="策略-1-本地分配（默认）"><a href="#策略-1-本地分配（默认）" class="headerlink" title="策略 1: 本地分配（默认）"></a>策略 1: 本地分配（默认）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># localalloc - 优先从进程运行的节点分配内存</span></span><br><span class="line">numactl --localalloc &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="策略-2-交错分配"><a href="#策略-2-交错分配" class="headerlink" title="策略 2: 交错分配"></a>策略 2: 交错分配</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># interleave - 在所有节点间轮询分配内存（适合大内存应用）</span></span><br><span class="line">numactl --interleave=all &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在特定节点间交错</span></span><br><span class="line">numactl --interleave=0,1 &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="策略-3-优先节点"><a href="#策略-3-优先节点" class="headerlink" title="策略 3: 优先节点"></a>策略 3: 优先节点</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># preferred - 优先从指定节点分配，不足时使用其他节点</span></span><br><span class="line">numactl --preferred=0 &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="策略-4-严格绑定"><a href="#策略-4-严格绑定" class="headerlink" title="策略 4: 严格绑定"></a>策略 4: 严格绑定</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># membind - 严格只从指定节点分配（内存不足会失败）</span></span><br><span class="line">numactl --membind=0 &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-查看网卡的-NUMA-节点"><a href="#4-3-查看网卡的-NUMA-节点" class="headerlink" title="4.3 查看网卡的 NUMA 节点"></a>4.3 查看网卡的 NUMA 节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法 1: 直接查看</span></span><br><span class="line"><span class="built_in">cat</span> /sys/class/net/eth0/device/numa_node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出: 0 (表示在 NUMA 节点 0)</span></span><br><span class="line"><span class="comment"># 输出: -1 (表示未绑定或不支持)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法 2: 查看所有网卡</span></span><br><span class="line"><span class="keyword">for</span> nic <span class="keyword">in</span> /sys/class/net/*; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$nic</span>/device/numa_node&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(basename $nic)</span>: <span class="subst">$(cat $nic/device/numa_node)</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例:</span></span><br><span class="line"><span class="comment"># eth0: 0</span></span><br><span class="line"><span class="comment"># eth1: 1</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-查看-NUMA-统计信息"><a href="#4-4-查看-NUMA-统计信息" class="headerlink" title="4.4 查看 NUMA 统计信息"></a>4.4 查看 NUMA 统计信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 NUMA 内存统计</span></span><br><span class="line">numastat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例:</span></span><br><span class="line"><span class="comment">#                            node0           node1</span></span><br><span class="line"><span class="comment"># numa_hit              1234567890      9876543210</span></span><br><span class="line"><span class="comment"># numa_miss                  12345           54321</span></span><br><span class="line"><span class="comment"># numa_foreign               54321           12345</span></span><br><span class="line"><span class="comment"># interleave_hit              1234            5678</span></span><br><span class="line"><span class="comment"># local_node            1234500000      9876500000</span></span><br><span class="line"><span class="comment"># other_node                 67890           43210</span></span><br></pre></td></tr></table></figure>

<p><strong>关键指标</strong>:</p>
<ul>
<li><code>numa_hit</code> - 进程从本地节点分配内存的次数（✅ 越高越好）</li>
<li><code>numa_miss</code> - 进程从远程节点分配内存的次数（❌ 应该低）</li>
<li><code>numa_foreign</code> - 其他进程访问本节点内存的次数</li>
<li><code>local_node</code> - 进程在本地节点运行并访问本地内存</li>
<li><code>other_node</code> - 进程在本地节点运行但访问远程内存（❌ 性能杀手）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按进程查看 NUMA 统计</span></span><br><span class="line">numastat -p &lt;pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按进程名查看</span></span><br><span class="line">numastat nginx</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、实战场景"><a href="#五、实战场景" class="headerlink" title="五、实战场景"></a>五、实战场景</h2><h3 id="场景-1-网络服务优化（Nginx）"><a href="#场景-1-网络服务优化（Nginx）" class="headerlink" title="场景 1: 网络服务优化（Nginx）"></a>场景 1: 网络服务优化（Nginx）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 查看网卡所在节点</span></span><br><span class="line">NUMA_NODE=$(<span class="built_in">cat</span> /sys/class/net/eth0/device/numa_node)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;eth0 在 NUMA 节点: <span class="variable">$NUMA_NODE</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 绑定 Nginx 到相同节点</span></span><br><span class="line">numactl --cpunodebind=<span class="variable">$NUMA_NODE</span> --membind=<span class="variable">$NUMA_NODE</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 验证</span></span><br><span class="line">ps aux | grep nginx</span><br><span class="line">numactl --show $(pidof nginx | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="场景-2-数据库优化（MySQL-PostgreSQL）"><a href="#场景-2-数据库优化（MySQL-PostgreSQL）" class="headerlink" title="场景 2: 数据库优化（MySQL&#x2F;PostgreSQL）"></a>场景 2: 数据库优化（MySQL&#x2F;PostgreSQL）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设数据库在节点 1</span></span><br><span class="line">numactl --cpunodebind=1 --membind=1 --interleave=1 mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明:</span></span><br><span class="line"><span class="comment"># --cpunodebind=1: CPU 绑定到节点 1</span></span><br><span class="line"><span class="comment"># --membind=1: 内存从节点 1 分配</span></span><br><span class="line"><span class="comment"># --interleave=1: 在节点 1 内交错分配（大内存应用）</span></span><br></pre></td></tr></table></figure>

<h3 id="场景-3-高性能计算"><a href="#场景-3-高性能计算" class="headerlink" title="场景 3: 高性能计算"></a>场景 3: 高性能计算</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将计算任务均匀分布到所有节点</span></span><br><span class="line">numactl --interleave=all ./my_app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 适用于:</span></span><br><span class="line"><span class="comment"># - 大规模矩阵运算</span></span><br><span class="line"><span class="comment"># - 科学计算</span></span><br><span class="line"><span class="comment"># - 大数据处理</span></span><br></pre></td></tr></table></figure>

<h3 id="场景-4-网卡中断绑核配合-NUMA"><a href="#场景-4-网卡中断绑核配合-NUMA" class="headerlink" title="场景 4: 网卡中断绑核配合 NUMA"></a>场景 4: 网卡中断绑核配合 NUMA</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 优化网络性能：中断和应用都绑定到网卡所在节点</span></span><br><span class="line"></span><br><span class="line">NIC=<span class="string">&quot;eth0&quot;</span></span><br><span class="line">NUMA_NODE=$(<span class="built_in">cat</span> /sys/class/net/<span class="variable">$NIC</span>/device/numa_node)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$NUMA_NODE</span>&quot;</span> = <span class="string">&quot;-1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;网卡未绑定 NUMA 节点&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;网卡 <span class="variable">$NIC</span> 在 NUMA 节点 <span class="variable">$NUMA_NODE</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 获取该节点的 CPU 列表</span></span><br><span class="line">NODE_CPUS=$(<span class="built_in">cat</span> /sys/devices/system/node/node<span class="variable">$&#123;NUMA_NODE&#125;</span>/cpulist)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;节点 <span class="variable">$NUMA_NODE</span> 的 CPU: <span class="variable">$NODE_CPUS</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 绑定网卡中断到该节点的前 8 个 CPU</span></span><br><span class="line">START_CPU=$(<span class="built_in">echo</span> <span class="variable">$NODE_CPUS</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;-&#x27;</span> -f1)</span><br><span class="line">END_CPU=$((START_CPU + <span class="number">7</span>))</span><br><span class="line">IRQ_CPUS=<span class="string">&quot;<span class="variable">$&#123;START_CPU&#125;</span>-<span class="variable">$&#123;END_CPU&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;绑定中断到 CPU: <span class="variable">$IRQ_CPUS</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> irq <span class="keyword">in</span> $(grep <span class="variable">$NIC</span> /proc/interrupts | awk -F: <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27; &#x27;</span>); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$IRQ_CPUS</span> &gt; /proc/irq/<span class="variable">$irq</span>/smp_affinity_list</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;IRQ <span class="variable">$irq</span> -&gt; CPU <span class="variable">$IRQ_CPUS</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 启动应用程序到相同节点</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;启动应用到 NUMA 节点 <span class="variable">$NUMA_NODE</span>&quot;</span></span><br><span class="line">numactl --cpunodebind=<span class="variable">$NUMA_NODE</span> --membind=<span class="variable">$NUMA_NODE</span> ./my_network_app</span><br></pre></td></tr></table></figure>

<h3 id="场景-5-容器化应用"><a href="#场景-5-容器化应用" class="headerlink" title="场景 5: 容器化应用"></a>场景 5: 容器化应用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker 容器绑定 NUMA</span></span><br><span class="line">docker run --cpuset-cpus=<span class="string">&quot;0-15&quot;</span> --cpuset-mems=<span class="string">&quot;0&quot;</span> \</span><br><span class="line">    --name my-app nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># Kubernetes Pod 配置 (添加到 pod spec)</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-numa</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    resources:</span><br><span class="line">      limits:</span><br><span class="line">        cpu: <span class="string">&quot;16&quot;</span></span><br><span class="line">        memory: <span class="string">&quot;64Gi&quot;</span></span><br><span class="line">  <span class="comment"># 使用 node selector 选择特定 NUMA 配置的节点</span></span><br><span class="line">  nodeSelector:</span><br><span class="line">    numa.topology: <span class="string">&quot;2-nodes&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、性能测试对比"><a href="#六、性能测试对比" class="headerlink" title="六、性能测试对比"></a>六、性能测试对比</h2><h3 id="测试-1-本地-vs-远程内存访问"><a href="#测试-1-本地-vs-远程内存访问" class="headerlink" title="测试 1: 本地 vs 远程内存访问"></a>测试 1: 本地 vs 远程内存访问</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 对比本地和远程内存访问性能</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试本地访问（节点 0）</span></span><br><span class="line">numactl --cpunodebind=0 --membind=0 sysbench memory \</span><br><span class="line">    --memory-block-size=1M \</span><br><span class="line">    --memory-total-size=10G run &gt; local.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试远程访问（CPU在节点0，内存在节点1）</span></span><br><span class="line">numactl --cpunodebind=0 --membind=1 sysbench memory \</span><br><span class="line">    --memory-block-size=1M \</span><br><span class="line">    --memory-total-size=10G run &gt; remote.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对比结果</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;本地访问:&quot;</span></span><br><span class="line">grep <span class="string">&quot;transferred&quot;</span> local.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;远程访问:&quot;</span></span><br><span class="line">grep <span class="string">&quot;transferred&quot;</span> remote.txt</span><br></pre></td></tr></table></figure>

<p><strong>典型结果</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本地访问: 10240.00 MiB transferred (25600.00 MiB/sec)</span><br><span class="line">远程访问: 10240.00 MiB transferred (12800.00 MiB/sec)</span><br><span class="line">性能差异: 2倍</span><br></pre></td></tr></table></figure>

<h3 id="测试-2-iperf3-配合-NUMA"><a href="#测试-2-iperf3-配合-NUMA" class="headerlink" title="测试 2: iperf3 配合 NUMA"></a>测试 2: iperf3 配合 NUMA</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端：绑定到网卡所在节点</span></span><br><span class="line">NUMA_NODE=$(<span class="built_in">cat</span> /sys/class/net/eth0/device/numa_node)</span><br><span class="line">numactl --cpunodebind=<span class="variable">$NUMA_NODE</span> --membind=<span class="variable">$NUMA_NODE</span> \</span><br><span class="line">    iperf3 -s -p 5201</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端：同样绑定</span></span><br><span class="line">numactl --cpunodebind=<span class="variable">$NUMA_NODE</span> --membind=<span class="variable">$NUMA_NODE</span> \</span><br><span class="line">    iperf3 -c &lt;server_ip&gt; -t 60 -P 10</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、监控和调试"><a href="#七、监控和调试" class="headerlink" title="七、监控和调试"></a>七、监控和调试</h2><h3 id="7-1-实时监控-NUMA-状态"><a href="#7-1-实时监控-NUMA-状态" class="headerlink" title="7.1 实时监控 NUMA 状态"></a>7.1 实时监控 NUMA 状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 持续监控 NUMA 统计</span></span><br><span class="line">watch -n 1 <span class="string">&#x27;numastat&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控特定进程</span></span><br><span class="line">watch -n 1 <span class="string">&#x27;numastat -p $(pidof nginx | head -n1)&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-查看进程的-NUMA-内存映射"><a href="#7-2-查看进程的-NUMA-内存映射" class="headerlink" title="7.2 查看进程的 NUMA 内存映射"></a>7.2 查看进程的 NUMA 内存映射</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看进程在各节点的内存分布</span></span><br><span class="line"><span class="built_in">cat</span> /proc/&lt;pid&gt;/numa_maps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例输出:</span></span><br><span class="line"><span class="comment"># 7f8a00000000 default file=/lib/x86_64-linux-gnu/libc-2.31.so mapped=200 N0=150 N1=50</span></span><br><span class="line"><span class="comment"># 说明: 该内存区域在节点0有150页，节点1有50页</span></span><br></pre></td></tr></table></figure>

<h3 id="7-3-检测-NUMA-不均衡"><a href="#7-3-检测-NUMA-不均衡" class="headerlink" title="7.3 检测 NUMA 不均衡"></a>7.3 检测 NUMA 不均衡</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 检测系统是否存在 NUMA 不均衡</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=== NUMA 不均衡检测 ===&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 检查 numa_miss</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\n1. NUMA Miss 率:&quot;</span></span><br><span class="line">numastat | awk <span class="string">&#x27;/numa_miss/&#123;print &quot;Node 0:&quot;, $2, &quot;Node 1:&quot;, $3&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 检查远程访问</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\n2. 远程内存访问:&quot;</span></span><br><span class="line">numastat | awk <span class="string">&#x27;/other_node/&#123;print &quot;Node 0:&quot;, $2, &quot;Node 1:&quot;, $3&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 计算不均衡度</span></span><br><span class="line">LOCAL0=$(numastat | awk <span class="string">&#x27;/local_node/&#123;print $2&#125;&#x27;</span>)</span><br><span class="line">OTHER0=$(numastat | awk <span class="string">&#x27;/other_node/&#123;print $2&#125;&#x27;</span>)</span><br><span class="line">RATIO=$(awk <span class="string">&quot;BEGIN &#123;print (<span class="variable">$OTHER0</span> / (<span class="variable">$LOCAL0</span> + <span class="variable">$OTHER0</span>)) * 100&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\n3. 远程访问占比: <span class="variable">$&#123;RATIO&#125;</span>%&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (( $(echo &quot;<span class="variable">$RATIO</span> &gt; <span class="number">10</span>&quot; | bc -l) )); <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;⚠️  警告: 远程访问超过10%，存在 NUMA 不均衡&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;✅ 正常: NUMA 访问模式良好&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、常见问题和解决方案"><a href="#八、常见问题和解决方案" class="headerlink" title="八、常见问题和解决方案"></a>八、常见问题和解决方案</h2><h3 id="Q1-如何确定网卡应该绑定到哪个-NUMA-节点？"><a href="#Q1-如何确定网卡应该绑定到哪个-NUMA-节点？" class="headerlink" title="Q1: 如何确定网卡应该绑定到哪个 NUMA 节点？"></a>Q1: 如何确定网卡应该绑定到哪个 NUMA 节点？</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看网卡的物理位置</span></span><br><span class="line">lspci -v -s $(ethtool -i eth0 | grep <span class="string">&quot;bus-info&quot;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或直接查看</span></span><br><span class="line"><span class="built_in">cat</span> /sys/class/net/eth0/device/numa_node</span><br></pre></td></tr></table></figure>

<h3 id="Q2-进程运行时可以改变-NUMA-策略吗？"><a href="#Q2-进程运行时可以改变-NUMA-策略吗？" class="headerlink" title="Q2: 进程运行时可以改变 NUMA 策略吗？"></a>Q2: 进程运行时可以改变 NUMA 策略吗？</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以，使用 numactl 和 taskset</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 查找进程 PID</span></span><br><span class="line">PID=$(pidof nginx | <span class="built_in">head</span> -n1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 迁移到节点 1</span></span><br><span class="line">numactl --cpunodebind=1 --membind=1 -p <span class="variable">$PID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：已分配的内存不会迁移，只影响新分配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改运行中进程的 CPU 亲和性</span></span><br><span class="line">❌ 不能直接通过 numactl 修改一个已经运行的进程的 CPU 亲和性。</span><br><span class="line">•numactl 是在 进程启动前 设置 NUMA 策略或 CPU 绑定策略；</span><br><span class="line">•它通过 sched_setaffinity() 和 mbind() 在启动时对目标进程/线程生效；</span><br><span class="line">•一旦进程已经启动，就无法再通过 numactl 修改它的绑定。</span><br><span class="line"></span><br><span class="line">✅ 可行的替代方案：</span><br><span class="line">taskset -<span class="built_in">cp</span> &lt;cpu_list&gt; &lt;pid&gt;</span><br><span class="line">eg:</span><br><span class="line">taskset -<span class="built_in">cp</span> 0-3 12345</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Q3-如何处理-NUMA-节点内存不均衡？"><a href="#Q3-如何处理-NUMA-节点内存不均衡？" class="headerlink" title="Q3: 如何处理 NUMA 节点内存不均衡？"></a>Q3: 如何处理 NUMA 节点内存不均衡？</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 查看各节点内存使用</span></span><br><span class="line">numastat -m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 如果某节点内存不足，可以：</span></span><br><span class="line"><span class="comment">#    a) 迁移部分进程到其他节点</span></span><br><span class="line"><span class="comment">#    b) 使用 interleave 策略</span></span><br><span class="line"><span class="comment">#    c) 重启应用并重新绑定</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 临时清理页缓存（谨慎使用）</span></span><br><span class="line"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="九、最佳实践总结"><a href="#九、最佳实践总结" class="headerlink" title="九、最佳实践总结"></a>九、最佳实践总结</h2><h3 id="✅-推荐做法"><a href="#✅-推荐做法" class="headerlink" title="✅ 推荐做法"></a>✅ 推荐做法</h3><ol>
<li><p><strong>网络密集型应用</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绑定到网卡所在 NUMA 节点</span></span><br><span class="line">numactl --cpunodebind=&lt;node&gt; --membind=&lt;node&gt; &lt;app&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内存密集型应用</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 interleave 分布内存</span></span><br><span class="line">numactl --interleave=all &lt;app&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>混合负载</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不同服务绑定到不同节点</span></span><br><span class="line">numactl --cpunodebind=0 --membind=0 nginx &amp;</span><br><span class="line">numactl --cpunodebind=1 --membind=1 mysql &amp;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="❌-避免的做法"><a href="#❌-避免的做法" class="headerlink" title="❌ 避免的做法"></a>❌ 避免的做法</h3><ol>
<li><p><strong>跨 NUMA 访问</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 错误: CPU 在节点 0，内存在节点 1</span></span><br><span class="line">numactl --cpunodebind=0 --membind=1 &lt;app&gt;  <span class="comment"># ❌</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>忽略网卡位置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网卡在节点 0，但进程在节点 1</span></span><br><span class="line"><span class="comment"># 导致所有网络数据跨节点传输  # ❌</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>过度绑定</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将太多进程绑定到单个节点</span></span><br><span class="line"><span class="comment"># 导致该节点过载，其他节点空闲  # ❌</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="十、快速参考表"><a href="#十、快速参考表" class="headerlink" title="十、快速参考表"></a>十、快速参考表</h2><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>numactl --hardware</code></td>
<td>查看 NUMA 拓扑</td>
</tr>
<tr>
<td><code>numactl --show</code></td>
<td>查看当前 NUMA 策略</td>
</tr>
<tr>
<td><code>numastat</code></td>
<td>查看 NUMA 统计</td>
</tr>
<tr>
<td><code>numactl --cpunodebind=N &lt;cmd&gt;</code></td>
<td>CPU 绑定到节点 N</td>
</tr>
<tr>
<td><code>numactl --membind=N &lt;cmd&gt;</code></td>
<td>内存绑定到节点 N</td>
</tr>
<tr>
<td><code>numactl --interleave=all &lt;cmd&gt;</code></td>
<td>内存交错分配</td>
</tr>
<tr>
<td><code>numactl --localalloc &lt;cmd&gt;</code></td>
<td>本地内存优先</td>
</tr>
<tr>
<td><code>numactl --preferred=N &lt;cmd&gt;</code></td>
<td>优先节点 N</td>
</tr>
<tr>
<td><code>cat /sys/class/net/*/device/numa_node</code></td>
<td>查看网卡节点</td>
</tr>
<tr>
<td><code>numastat -p &lt;pid&gt;</code></td>
<td>查看进程 NUMA 统计</td>
</tr>
</tbody></table>
<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># CPU 信息</span><br><span class="line">lscpu</span><br><span class="line">nproc  # 查看核心数</span><br><span class="line"></span><br><span class="line"># NUMA 拓扑</span><br><span class="line">lscpu | grep NUMA</span><br><span class="line">numactl --hardware</span><br><span class="line"></span><br><span class="line"># 网卡信息</span><br><span class="line">lspci | grep -i ethernet</span><br><span class="line">ip link show</span><br><span class="line">ethtool eth0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看当前队列配置</span><br><span class="line">ethtool -l eth0</span><br><span class="line"></span><br><span class="line"># 查看 RSS 配置</span><br><span class="line">ethtool -x eth0</span><br><span class="line"></span><br><span class="line"># 查看网卡统计</span><br><span class="line">ethtool -S eth0</span><br><span class="line"></span><br><span class="line"># 查看网卡所在 NUMA 节点</span><br><span class="line">cat /sys/class/net/eth0/device/numa_node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 终端 1: 监控中断</span><br><span class="line">watch -n 1 &#x27;cat /proc/interrupts | grep -E &quot;(CPU|eth)&quot; | head -n 20&#x27;</span><br><span class="line"></span><br><span class="line"># 终端 2: 监控 CPU</span><br><span class="line">mpstat -P ALL 1</span><br><span class="line"></span><br><span class="line"># 终端 3: 监控网络</span><br><span class="line">sar -n DEV 1</span><br></pre></td></tr></table></figure>

<h2 id="🎯-快速参考命令"><a href="#🎯-快速参考命令" class="headerlink" title="🎯 快速参考命令"></a>🎯 快速参考命令</h2><h3 id="信息查询"><a href="#信息查询" class="headerlink" title="信息查询"></a>信息查询</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NUMA 拓扑</span></span><br><span class="line">lscpu | grep NUMA</span><br><span class="line">numactl --hardware</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网卡队列</span></span><br><span class="line">ethtool -l eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中断亲和性</span></span><br><span class="line">grep eth0 /proc/interrupts</span><br><span class="line"><span class="built_in">cat</span> /proc/irq/120/smp_affinity_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 网卡 NUMA 节点</span></span><br><span class="line"><span class="built_in">cat</span> /sys/class/net/eth0/device/numa_node</span><br><span class="line"></span><br><span class="line"><span class="comment"># NUMA 统计</span></span><br><span class="line">numastat</span><br><span class="line">numastat -p $(pidof nginx)</span><br></pre></td></tr></table></figure>


<h4 id="2-1-启动监控（另一个终端）"><a href="#2-1-启动监控（另一个终端）" class="headerlink" title="2.1 启动监控（另一个终端）"></a>2.1 启动监控（另一个终端）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 终端 1: 监控中断</span></span><br><span class="line">watch -n 1 <span class="string">&#x27;cat /proc/interrupts | grep -E &quot;(CPU|eth)&quot; | head -n 20&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 终端 2: 监控 CPU</span></span><br><span class="line">mpstat -P ALL 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终端 3: 监控网络</span></span><br><span class="line">sar -n DEV 1</span><br></pre></td></tr></table></figure>
<h4 id="2-2-客户端测试（测试客户端）"><a href="#2-2-客户端测试（测试客户端）" class="headerlink" title="2.2 客户端测试（测试客户端）"></a>2.2 客户端测试（测试客户端）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 服务端：绑定到网卡所在节点</span></span><br><span class="line"><span class="comment">#NUMA_NODE=$(cat /sys/class/net/eth0/device/numa_node)</span></span><br><span class="line"><span class="comment">#numactl --cpunodebind=$NUMA_NODE --membind=$NUMA_NODE \</span></span><br><span class="line">    iperf3 -s -p 5201</span><br><span class="line"></span><br><span class="line"><span class="comment">#numactl --cpunodebind=$NUMA_NODE --membind=$NUMA_NODE \</span></span><br><span class="line">    iperf3 -c 10.120.64.218 -t 60 -P 10</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;✅ 基准测试完成，记录吞吐量和重传次数&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-记录关键指标"><a href="#2-3-记录关键指标" class="headerlink" title="2.3 记录关键指标"></a>2.3 记录关键指标</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提取关键数据</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;=== 基准性能 ===&quot;</span> &gt; performance_baseline.txt</span><br><span class="line">grep <span class="string">&quot;sender&quot;</span> baseline_*.txt &gt;&gt; performance_baseline.txt</span><br><span class="line">grep <span class="string">&quot;Retr&quot;</span> baseline_*.txt &gt;&gt; performance_baseline.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否有性能问题</span></span><br><span class="line"><span class="comment"># 问题信号:</span></span><br><span class="line"><span class="comment"># 1. 多流吞吐量远低于单流 (&lt; 80%)</span></span><br><span class="line"><span class="comment"># 2. 重传次数高 (&gt; 1000)</span></span><br><span class="line"><span class="comment"># 3. CPU 集中在少数核心</span></span><br><span class="line"><span class="comment"># 4. 有丢包 (UDP 测试)</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="中断类型详解"><a href="#中断类型详解" class="headerlink" title="中断类型详解"></a>中断类型详解</h2><h3 id="中断分类表"><a href="#中断分类表" class="headerlink" title="中断分类表"></a>中断分类表</h3><table>
<thead>
<tr>
<th>中断类型</th>
<th>编号范围</th>
<th>触发方式</th>
<th>典型用途</th>
<th>处理优先级</th>
<th>性能影响</th>
</tr>
</thead>
<tbody><tr>
<td><strong>硬件中断(IRQ)</strong></td>
<td>0-255+</td>
<td>硬件触发</td>
<td>设备通知CPU</td>
<td>高</td>
<td>直接影响延迟</td>
</tr>
<tr>
<td><strong>软中断(Softirq)</strong></td>
<td>0-9</td>
<td>软件触发</td>
<td>延迟处理</td>
<td>中</td>
<td>影响吞吐量</td>
</tr>
<tr>
<td><strong>网络中断(NET_RX)</strong></td>
<td>softirq 3</td>
<td>网卡接收</td>
<td>数据包接收</td>
<td>高</td>
<td>高负载场景瓶颈</td>
</tr>
<tr>
<td><strong>网络中断(NET_TX)</strong></td>
<td>softirq 4</td>
<td>网卡发送</td>
<td>数据包发送</td>
<td>中</td>
<td>影响发送性能</td>
</tr>
<tr>
<td><strong>块设备中断</strong></td>
<td>变化</td>
<td>磁盘I&#x2F;O</td>
<td>磁盘读写完成</td>
<td>中</td>
<td>影响I&#x2F;O性能</td>
</tr>
<tr>
<td><strong>定时器中断</strong></td>
<td>softirq 1</td>
<td>周期触发</td>
<td>系统时钟</td>
<td>中</td>
<td>系统级影响</td>
</tr>
<tr>
<td><strong>调度中断</strong></td>
<td>softirq 7</td>
<td>调度触发</td>
<td>进程调度</td>
<td>中</td>
<td>影响响应时间</td>
</tr>
<tr>
<td><strong>RCU中断</strong></td>
<td>softirq 8,9</td>
<td>内核同步</td>
<td>内存回收</td>
<td>低</td>
<td>后台影响</td>
</tr>
</tbody></table>
<h3 id="网络中断处理流程"><a href="#网络中断处理流程" class="headerlink" title="网络中断处理流程"></a>网络中断处理流程</h3><table>
<thead>
<tr>
<th>阶段</th>
<th>类型</th>
<th>处理位置</th>
<th>关键操作</th>
<th>可优化点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1. 硬中断</strong></td>
<td>Hardware IRQ</td>
<td>中断处理程序(ISR)</td>
<td>通知内核、禁止中断</td>
<td>IRQ亲和性绑定</td>
</tr>
<tr>
<td><strong>2. 软中断</strong></td>
<td>NET_RX_SOFTIRQ</td>
<td>ksoftirqd线程</td>
<td>数据包处理、协议栈</td>
<td>RPS&#x2F;RFS配置</td>
</tr>
<tr>
<td><strong>3. 应用层</strong></td>
<td>系统调用</td>
<td>用户空间</td>
<td>数据读取</td>
<td>SO_REUSEPORT</td>
</tr>
</tbody></table>
<h3 id="I-O中断类型对比"><a href="#I-O中断类型对比" class="headerlink" title="I&#x2F;O中断类型对比"></a>I&#x2F;O中断类型对比</h3><table>
<thead>
<tr>
<th>对比项</th>
<th>网络中断</th>
<th>磁盘I&#x2F;O中断</th>
<th>NVMe中断</th>
</tr>
</thead>
<tbody><tr>
<td><strong>频率</strong></td>
<td>极高(百万级&#x2F;秒)</td>
<td>中等(万级&#x2F;秒)</td>
<td>高(十万级&#x2F;秒)</td>
</tr>
<tr>
<td><strong>延迟敏感度</strong></td>
<td>极高</td>
<td>中等</td>
<td>高</td>
</tr>
<tr>
<td><strong>CPU占用</strong></td>
<td>高</td>
<td>中</td>
<td>中高</td>
</tr>
<tr>
<td><strong>优化方法</strong></td>
<td>中断合并、NAPI</td>
<td>I&#x2F;O调度器</td>
<td>中断绑核、轮询</td>
</tr>
<tr>
<td><strong>队列数</strong></td>
<td>多队列(RSS)</td>
<td>单队列&#x2F;多队列</td>
<td>多队列(NVMe队列)</td>
</tr>
</tbody></table>
<h3 id="🎯-核心概念"><a href="#🎯-核心概念" class="headerlink" title="🎯 核心概念"></a>🎯 核心概念</h3><ol>
<li><p><strong>硬中断 vs 软中断</strong></p>
<ul>
<li>**硬中断(IRQ)**：硬件直接触发，处理快速，不可睡眠</li>
<li>**软中断(Softirq)**：延迟处理，可以被调度，处理复杂逻辑</li>
</ul>
</li>
<li><p><strong>RSS vs RPS vs RFS</strong></p>
<ul>
<li><strong>RSS</strong>（硬件）：网卡硬件根据哈希将数据包分发到不同队列</li>
<li><strong>RPS</strong>（软件）：内核软件层面分发软中断到不同CPU</li>
<li><strong>RFS</strong>（流感知）：将数据包分发到应用程序所在的CPU核心</li>
</ul>
</li>
<li><p><strong>NAPI机制</strong></p>
<ul>
<li>高负载时从中断模式切换到轮询模式</li>
<li>减少中断次数，提高吞吐量</li>
<li>降低CPU中断开销</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>系统分析</title>
    <url>/2025/11/04/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="系统分析"><a href="#系统分析" class="headerlink" title="系统分析"></a>系统分析</h2><blockquote>
<p>覆盖了网卡、NUMA、中断、CPU绑定、CPU软中断分布、I&#x2F;O负载(pidstat&#x2F;iostat)、队列与中断绑定分析</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># ------------------------------------------------------------</span><br><span class="line"># 网络 + NUMA + CPU + 中断 综合排查脚本</span><br><span class="line"># ------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">NIC=$&#123;1:-eth2&#125;   # 默认网卡 eth2，可通过参数指定</span><br><span class="line">echo -e &quot;\n\033[1;36m&gt;&gt;&gt; 开始分析网卡: $NIC\033[0m&quot;</span><br><span class="line">echo &quot;------------------------------------------------------------&quot;</span><br><span class="line"></span><br><span class="line"># ========== 1. 基础硬件与NUMA结构 ==========</span><br><span class="line">echo -e &quot;\n\033[1;33m[1] NUMA与CPU拓扑信息\033[0m&quot;</span><br><span class="line">lscpu | egrep &quot;Model name|Socket|Core|Thread|NUMA&quot;</span><br><span class="line">echo</span><br><span class="line">numactl --hardware | grep -E &quot;available:|node [0-9]+ cpus:&quot;</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">if [ -f &quot;/sys/class/net/$NIC/device/numa_node&quot; ]; then</span><br><span class="line">    NUMA_NODE=$(cat /sys/class/net/$NIC/device/numa_node)</span><br><span class="line">    echo &quot;🧩 网卡 $NIC 属于 NUMA 节点: $NUMA_NODE&quot;</span><br><span class="line">    NODE_CPUS=$(cat /sys/devices/system/node/node$&#123;NUMA_NODE&#125;/cpulist)</span><br><span class="line">    echo &quot;🧠 对应 NUMA 节点CPU列表: $NODE_CPUS&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;⚠️ 未找到 $NIC 的 NUMA 节点信息&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># ========== 2. 网卡硬件与队列信息 ==========</span><br><span class="line">echo -e &quot;\n\033[1;33m[2] 网卡硬件参数与队列情况\033[0m&quot;</span><br><span class="line">ethtool -i $NIC | grep -E &quot;driver|version|firmware&quot;</span><br><span class="line">ethtool -l $NIC | grep -A1 &quot;Combined&quot;</span><br><span class="line">echo</span><br><span class="line">echo &quot;队列列表:&quot;</span><br><span class="line">ls /sys/class/net/$NIC/queues/ 2&gt;/dev/null || echo &quot;无队列目录&quot;</span><br><span class="line">echo</span><br><span class="line">ethtool -x $NIC 2&gt;/dev/null | head -20 || echo &quot;该网卡不支持RSS映射查看&quot;</span><br><span class="line"></span><br><span class="line"># ========== 3. 中断分布与绑定 ==========</span><br><span class="line">echo -e &quot;\n\033[1;33m[3] 中断与CPU绑定关系\033[0m&quot;</span><br><span class="line">echo &quot;👉 $NIC 的中断号分布：&quot;</span><br><span class="line">grep $NIC /proc/interrupts | awk &#x27;&#123;print $1 &quot;\t&quot; $NF&#125;&#x27; | tr -d &#x27;:&#x27; | column -t</span><br><span class="line"></span><br><span class="line">echo -e &quot;\n👉 每个中断号绑定CPU信息:&quot;</span><br><span class="line">grep $NIC /proc/interrupts | cut -d: -f1 | while read irq; do</span><br><span class="line">    [ -n &quot;$irq&quot; ] &amp;&amp; printf &quot;IRQ %-4s -&gt; CPU(s): %s\n&quot; &quot;$irq&quot; &quot;$(cat /proc/irq/$irq/smp_affinity_list 2&gt;/dev/null)&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># ========== 4. 网卡接收性能参数 ==========</span><br><span class="line">echo -e &quot;\n\033[1;33m[4] 网卡接收性能参数\033[0m&quot;</span><br><span class="line">sysctl -a 2&gt;/dev/null | grep &quot;net.core.netdev_max_backlog&quot;</span><br><span class="line">ethtool -S $NIC 2&gt;/dev/null | egrep &quot;rx_|tx_&quot; | head -20</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line"># ========== 5. CPU中断与软中断负载 ==========</span><br><span class="line">echo -e &quot;\n\033[1;33m[5] CPU中断与软中断统计\033[0m&quot;</span><br><span class="line">echo -e &quot;\n🧮 查看单核CPU的软中断(top前几项)：&quot;</span><br><span class="line">mpstat -P ALL 1 1 | grep -v &quot;Average&quot; | grep -v &quot;^$&quot; | head -15</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">echo -e &quot;\n🧩 /proc/softirqs 前20行：&quot;</span><br><span class="line">head -20 /proc/softirqs</span><br><span class="line"></span><br><span class="line"># ========== 6. 机器整体性能快照 ==========</span><br><span class="line">echo -e &quot;\n\033[1;33m[6] 系统整体性能快照\033[0m&quot;</span><br><span class="line">echo -e &quot;\n📊 CPU使用率：&quot;</span><br><span class="line">mpstat 1 1 | tail -10</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">echo -e &quot;\n💾 磁盘I/O负载：&quot;</span><br><span class="line">iostat -x -d 1 1 | grep -v &quot;^$&quot;</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">echo -e &quot;\n📈 网络流量速率：&quot;</span><br><span class="line">sar -n DEV 1 1 | grep $NIC</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">echo -e &quot;\n👀 进程级CPU/IO统计（前5名）：&quot;</span><br><span class="line">pidstat -dru 1 1 | head -20</span><br><span class="line"></span><br><span class="line"># ========== 7. 附加建议 ==========</span><br><span class="line">echo -e &quot;\n\033[1;33m[7] 附加建议命令（可选手动执行）\033[0m&quot;</span><br><span class="line">cat &lt;&lt;EOF</span><br><span class="line"># 查看中断平衡服务状态（IRQBalance）</span><br><span class="line">systemctl status irqbalance</span><br><span class="line"></span><br><span class="line"># 查看RSS配置与中断CPU亲和性调整建议</span><br><span class="line">grep . /sys/class/net/$NIC/queues/*/rps_cpus</span><br><span class="line">grep . /sys/class/net/$NIC/queues/*/xps_cpus</span><br><span class="line"></span><br><span class="line"># 查看当前活跃连接数</span><br><span class="line">ss -s</span><br><span class="line"></span><br><span class="line"># 实时监控单核CPU中断变化（示例）</span><br><span class="line">watch -n1 &#x27;cat /proc/softirqs | head -20&#x27;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">echo -e &quot;\n\033[1;32m✅ 完成，以上为网卡与NUMA性能诊断信息。\033[0m&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>🧩 输出逻辑概览（排查顺序）</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>主要目的</th>
<th>核心命令</th>
</tr>
</thead>
<tbody><tr>
<td>1️⃣ NUMA与CPU拓扑</td>
<td>了解CPU与内存结构</td>
<td><code>lscpu</code>, <code>numactl</code></td>
</tr>
<tr>
<td>2️⃣ 网卡硬件与队列</td>
<td>确认网卡队列、RSS能力</td>
<td><code>ethtool -l</code>, <code>ethtool -x</code></td>
</tr>
<tr>
<td>3️⃣ 中断绑定关系</td>
<td>分析IRQ与CPU的分布</td>
<td><code>/proc/interrupts</code>, <code>/proc/irq/</code></td>
</tr>
<tr>
<td>4️⃣ 网络性能参数</td>
<td>核心队列与缓冲</td>
<td><code>ethtool -S</code>, <code>sysctl net.core</code></td>
</tr>
<tr>
<td>5️⃣ CPU软中断分析</td>
<td>检查软中断瓶颈</td>
<td><code>mpstat</code>, <code>/proc/softirqs</code></td>
</tr>
<tr>
<td>6️⃣ 系统性能快照</td>
<td>看系统整体健康度</td>
<td><code>pidstat</code>, <code>iostat</code>, <code>sar</code></td>
</tr>
<tr>
<td>7️⃣ 附加优化</td>
<td>手动调整指引</td>
<td>RSS&#x2F;XPS, irqbalance</td>
</tr>
</tbody></table>
<h2 id="irqtop-与-lsirq"><a href="#irqtop-与-lsirq" class="headerlink" title="irqtop 与 lsirq"></a>irqtop 与 lsirq</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cat /proc/interrupts 格式不够良好</span><br><span class="line">#默认util-linux-2.38才集成了irqtop与lsirq，升级util-linux有一定风险，仅编译安装两个工具</span><br><span class="line">#rpm -q util-linux</span><br><span class="line">util-linux-2.32.1-22.0.1.an8.x86_64</span><br><span class="line"></span><br><span class="line">#Anolis OS 8.2 编译安装</span><br><span class="line">git clone https://github.com/util-linux/util-linux.git</span><br><span class="line">cd util-linux/</span><br><span class="line">./autogen.sh</span><br><span class="line"></span><br><span class="line">#两个工具依赖libsmartcols</span><br><span class="line">./configure --enable-libsmartcols --disable-all-programs --enable-lsirq --enable-irqtop</span><br><span class="line">make</span><br><span class="line">cp lsirq /usr/local/bin/</span><br><span class="line">cp irqtop /usr/local/bin/</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>设备信息汇总</title>
    <url>/2025/11/05/%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="NUMA架构lstopo显示系统拓扑"><a href="#NUMA架构lstopo显示系统拓扑" class="headerlink" title="NUMA架构lstopo显示系统拓扑"></a>NUMA架构lstopo显示系统拓扑</h2><blockquote>
<p><a href="https://cloud-atlas.readthedocs.io/zh-cn/latest/kernel/memory/numa/lstopo.html">https://cloud-atlas.readthedocs.io/zh-cn/latest/kernel/memory/numa/lstopo.html</a> </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y hwloc hwloc-gui</span><br><span class="line"></span><br><span class="line">#查看摘要，文字表述</span><br><span class="line">lstopo</span><br><span class="line">lstopo -s</span><br><span class="line">lstopo-no-graphics</span><br><span class="line"></span><br><span class="line">#ascii art 格式输出,物理索引</span><br><span class="line">lstopo --of ascii -p</span><br><span class="line"></span><br><span class="line">#逻辑索引</span><br><span class="line">lstopo --of ascii -l</span><br><span class="line"></span><br><span class="line"># 生成 PNG 图片</span><br><span class="line">lstopo --of png /root/topo.png</span><br><span class="line"></span><br><span class="line"># 或者更简单的写法（自动根据后缀识别格式）</span><br><span class="line">lstopo /root/topo.png</span><br><span class="line"></span><br><span class="line"># 生成 SVG 矢量图（推荐，清晰且可放大）</span><br><span class="line">lstopo /root/topo.svg</span><br><span class="line"></span><br><span class="line"># 生成 PDF 格式</span><br><span class="line">lstopo /root/topo.pdf</span><br><span class="line"></span><br><span class="line"># 拓扑包含所有 PCIe / 网卡设备信息</span><br><span class="line">lstopo --whole-io topo-full.svg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#生成一张带编号、整齐布局的图：</span><br><span class="line">lstopo --whole-io --rect --fontsize 9 --gridsize 8 /root/topo.svg</span><br><span class="line"></span><br><span class="line"># 生成带网卡的完整 NUMA + PCIe 拓扑图</span><br><span class="line">sudo lstopo --whole-system --whole-io --rect --fontsize 9 --gridsize 8 /root/topo.svg</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="可选美化与调整参数"><a href="#可选美化与调整参数" class="headerlink" title="可选美化与调整参数"></a>可选美化与调整参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>--fontsize 10</code></td>
<td>调整字体大小</td>
</tr>
<tr>
<td><code>--gridsize 10</code></td>
<td>控制元素间距</td>
</tr>
<tr>
<td><code>--rect</code></td>
<td>使用矩形布局（更规整）</td>
</tr>
<tr>
<td><code>--horiz</code> &#x2F; <code>--vert</code></td>
<td>强制水平或垂直布局</td>
</tr>
<tr>
<td><code>--physical</code></td>
<td>显示物理 CPU 核编号</td>
</tr>
<tr>
<td><code>--logical</code></td>
<td>显示逻辑编号（默认）</td>
</tr>
</tbody></table>
<h3 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PU P# 是处理单元处理器</span><br><span class="line">L#i 代表指令高速缓存。</span><br><span class="line">L#d 代表数据高速缓存。</span><br><span class="line">L1 代表1级缓存。</span><br><span class="line">L2 代表第2级高速缓存。</span><br><span class="line">L3 代表三级缓存</span><br></pre></td></tr></table></figure>

<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y numactl </span><br><span class="line"></span><br><span class="line">numactl --hardware</span><br><span class="line">lscpu</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>iperf压测带宽</title>
    <url>/2025/11/07/iperf%E5%8E%8B%E6%B5%8B%E5%B8%A6%E5%AE%BD/</url>
    <content><![CDATA[<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 iperf3</span></span><br><span class="line">yum install -y iperf3  <span class="comment"># CentOS/RHEL</span></span><br><span class="line"><span class="comment">#查看系统架构及版本</span></span><br><span class="line"><span class="built_in">uname</span> -m &amp;&amp; <span class="built_in">cat</span> /etc/os-release | egrep <span class="string">&quot;NAME|VERSION&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------</span></span><br><span class="line"><span class="comment"># 1. 启动 iperf3 服务端</span></span><br><span class="line"><span class="comment"># ---------------------------</span></span><br><span class="line">iperf3 -s -p 5201</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或后台运行</span></span><br><span class="line">iperf3 -s -D</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改为实际服务器 IP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------</span></span><br><span class="line"><span class="comment"># 2. 客户端梯度压测</span></span><br><span class="line"><span class="comment"># ---------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打满带宽：单线程 TCP 测试</span></span><br><span class="line">iperf3 -c &lt;server_ip&gt; -t 30</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程（并发10连接）</span></span><br><span class="line">iperf3 -c &lt;server_ip&gt; -P 10 -t 30</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度测试（1G、5G、10G）</span></span><br><span class="line">iperf3 -c &lt;server_ip&gt; -b 1G -t 30</span><br><span class="line">iperf3 -c &lt;server_ip&gt; -b 5G -t 30</span><br><span class="line">iperf3 -c &lt;server_ip&gt; -b 10G -t 30</span><br><span class="line"></span><br><span class="line"><span class="comment"># UDP 模式下验证包丢率</span></span><br><span class="line">iperf3 -u -b 10G -c &lt;server_ip&gt; -t 30</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>dnsperf使用说明</title>
    <url>/2025/11/07/dnsperf%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="🧭-dnsperf-实战与最佳实践速查指南"><a href="#🧭-dnsperf-实战与最佳实践速查指南" class="headerlink" title="🧭 dnsperf 实战与最佳实践速查指南"></a>🧭 dnsperf 实战与最佳实践速查指南</h1><h2 id="📖-1-工具简介"><a href="#📖-1-工具简介" class="headerlink" title="📖 1. 工具简介"></a>📖 1. 工具简介</h2><p><code>dnsperf</code> 是由 <strong>Nominum &#x2F; DNS-OARC</strong> 提供的 <strong>DNS 性能压测工具</strong>，用于模拟客户端大规模并发请求，测试 <strong>DNS 服务器（如 BIND、CoreDNS、PowerDNS）</strong> 的 QPS、响应延迟、丢包率等性能指标。<br>常用于：</p>
<ul>
<li>DNS 服务性能压测；</li>
<li>网络栈优化与软中断验证；</li>
<li>负载均衡策略评估；</li>
<li>DNS 缓存与 TTL 策略测试。</li>
</ul>
<hr>
<h2 id="⚙️-2-安装方式"><a href="#⚙️-2-安装方式" class="headerlink" title="⚙️ 2. 安装方式"></a>⚙️ 2. 安装方式</h2><h3 id="✅-通用（RHEL-Anolis-CentOS-8-）"><a href="#✅-通用（RHEL-Anolis-CentOS-8-）" class="headerlink" title="✅ 通用（RHEL&#x2F;Anolis&#x2F;CentOS 8+）"></a>✅ 通用（RHEL&#x2F;Anolis&#x2F;CentOS 8+）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y https://mirrors.aliyun.com/epel/epel-release-latest-8.noarch.rpm</span><br><span class="line">yum install -y dnsperf</span><br></pre></td></tr></table></figure>

<h3 id="✅-验证安装"><a href="#✅-验证安装" class="headerlink" title="✅ 验证安装"></a>✅ 验证安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnsperf -h</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧰-3-基本命令与参数说明"><a href="#🧰-3-基本命令与参数说明" class="headerlink" title="🧰 3. 基本命令与参数说明"></a>🧰 3. 基本命令与参数说明</h2><table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>-s &lt;server&gt;</code></td>
<td>指定被测 DNS 服务器 IP</td>
<td>必填</td>
</tr>
<tr>
<td><code>-p &lt;port&gt;</code></td>
<td>DNS 端口（默认53）</td>
<td>可用于测试 CoreDNS 或自定义端口</td>
</tr>
<tr>
<td><code>-d &lt;datafile&gt;</code></td>
<td>测试域名文件路径</td>
<td>每行一个域名</td>
</tr>
<tr>
<td><code>-l &lt;duration&gt;</code></td>
<td>压测时长（秒）</td>
<td>如 <code>-l 60</code> 表示持续压测 1 分钟</td>
</tr>
<tr>
<td><code>-Q &lt;rate&gt;</code></td>
<td>每秒查询速率（QPS 限制）</td>
<td>如 <code>-Q 5000</code></td>
</tr>
<tr>
<td><code>-c &lt;clients&gt;</code></td>
<td>模拟并发客户端数量</td>
<td>默认1，可设多线程</td>
</tr>
<tr>
<td><code>-t &lt;threads&gt;</code></td>
<td>线程数（默认1）</td>
<td>与 CPU 核绑定测试软中断时建议多核</td>
</tr>
<tr>
<td><code>-v</code></td>
<td>输出详细日志</td>
<td>包括 RTT 分布和请求统计</td>
</tr>
<tr>
<td><code>-D</code></td>
<td>打印每个查询结果</td>
<td>用于验证响应内容</td>
</tr>
<tr>
<td><code>-S</code></td>
<td>使用 TCP 而非 UDP</td>
<td>用于验证 TCP fallback</td>
</tr>
<tr>
<td><code>-T</code></td>
<td>设置每个线程的目标 QPS</td>
<td>可用于核级软中断分配分析</td>
</tr>
</tbody></table>
<hr>
<h2 id="📋-4-测试数据文件格式（queries-txt）"><a href="#📋-4-测试数据文件格式（queries-txt）" class="headerlink" title="📋 4. 测试数据文件格式（queries.txt）"></a>📋 4. 测试数据文件格式（<code>queries.txt</code>）</h2><p>示例：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">www.baidu.com. A</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️ 注意：</p>
<ul>
<li>每行一个查询；</li>
<li>以 <strong><code>.</code> 结尾</strong>；</li>
<li>查询类型可为 <code>A</code>, <code>AAAA</code>, <code>MX</code>, <code>NS</code>, <code>TXT</code> 等。</li>
</ul>
</blockquote>
<hr>
<h2 id="🚀-5-常用命令模板与实战注释"><a href="#🚀-5-常用命令模板与实战注释" class="headerlink" title="🚀 5. 常用命令模板与实战注释"></a>🚀 5. 常用命令模板与实战注释</h2><h3 id="🧩-5-1-基础测试（单线程）"><a href="#🧩-5-1-基础测试（单线程）" class="headerlink" title="🧩 5.1 基础测试（单线程）"></a>🧩 5.1 基础测试（单线程）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnsperf -s 10.16.13.14 -d queries.txt -l 30</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>连续压测 30 秒</li>
<li>默认 UDP + 单线程</li>
<li>适用于功能验证阶段</li>
</ul>
</blockquote>
<hr>
<h3 id="⚡️-5-2-并发压测（多线程高并发）"><a href="#⚡️-5-2-并发压测（多线程高并发）" class="headerlink" title="⚡️ 5.2 并发压测（多线程高并发）"></a>⚡️ 5.2 并发压测（多线程高并发）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnsperf -s 10.16.13.14 -d queries.txt -l 60 -Q 50000 -t 8 -c 50</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>目标 QPS：50,000</li>
<li>线程数：8（建议与 CPU 核数绑定）</li>
<li>模拟 50 个客户端并发请求</li>
<li>适合测试多核软中断均衡性能</li>
</ul>
</blockquote>
<blockquote>
<p>💡 <strong>监控建议：</strong><br>在被测 DNS 服务器执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch -n1 <span class="string">&quot;cat /proc/softirqs | grep NET_RX&quot;</span></span><br></pre></td></tr></table></figure>

<p>同时观察各 CPU 的软中断分布是否均衡。</p>
</blockquote>
<hr>
<h3 id="🌐-5-3-TCP-模式验证（DNS-over-TCP）"><a href="#🌐-5-3-TCP-模式验证（DNS-over-TCP）" class="headerlink" title="🌐 5.3 TCP 模式验证（DNS over TCP）"></a>🌐 5.3 TCP 模式验证（DNS over TCP）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnsperf -s 10.16.13.14 -p 53 -d queries.txt -S -l 30</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>使用 TCP 连接进行查询；</li>
<li>适用于验证 <strong>TCP fallback</strong> 或防火墙规则。</li>
</ul>
</blockquote>
<hr>
<h3 id="🧪-5-4-指定每线程速率（核绑定验证）"><a href="#🧪-5-4-指定每线程速率（核绑定验证）" class="headerlink" title="🧪 5.4 指定每线程速率（核绑定验证）"></a>🧪 5.4 指定每线程速率（核绑定验证）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskset -c 0-7 dnsperf -s 10.16.13.14 -d queries.txt -t 8 -T 5000 -l 30</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>限定在 CPU 0-7 核运行；</li>
<li>每线程 5,000 QPS；</li>
<li>可结合 <code>irqbalance</code> 或 <code>ethtool -X</code> 调整中断亲和性；</li>
<li>用于验证 <strong>软中断分布与性能关系</strong>。</li>
</ul>
</blockquote>
<hr>
<h3 id="📊-5-5-查看响应延迟分布"><a href="#📊-5-5-查看响应延迟分布" class="headerlink" title="📊 5.5 查看响应延迟分布"></a>📊 5.5 查看响应延迟分布</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnsperf -s 10.16.13.14 -d queries.txt -l 30 -Q 10000 -v</span><br><span class="line">dnsperf -s 10.16.13.14 -d queries.txt -l 60 -t 8 -Q 400000 -v &gt; dnsperf_verbose.log 2&gt;&amp;1</span><br><span class="line"><span class="comment">#分析</span></span><br><span class="line">grep -E <span class="string">&quot;Latency Distribution|Queries per second|Average Latency|Latency StdDev&quot;</span> dnsperf_verbose.log -n</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>输出示例：</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Statistics:</span><br><span class="line">  Queries sent:         300000</span><br><span class="line">  Queries completed:    299995 (100.00%)</span><br><span class="line">  Response codes:       NOERROR 299995</span><br><span class="line">  Average latency:      1.32 ms</span><br><span class="line">  Latency StdDev:       0.28 ms</span><br><span class="line">  Latency Distribution:</span><br><span class="line">    50%: 1.28 ms</span><br><span class="line">    90%: 1.47 ms</span><br><span class="line">    99%: 1.88 ms</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>用途：</strong> 观察性能抖动与延迟曲线，判断内核队列 &#x2F; IRQ 调整效果。</p>
</blockquote>
<hr>
<h3 id="🔍-5-6-自定义端口测试（CoreDNS-ingress-nginx-场景）"><a href="#🔍-5-6-自定义端口测试（CoreDNS-ingress-nginx-场景）" class="headerlink" title="🔍 5.6 自定义端口测试（CoreDNS &#x2F; ingress-nginx 场景）"></a>🔍 5.6 自定义端口测试（CoreDNS &#x2F; ingress-nginx 场景）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnsperf -s 192.168.179.135 -p 1053 -d queries.txt -l 30</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>当你的 DNS 服务运行在自定义端口（如 CoreDNS、Nginx stream 模式）时使用。</li>
</ul>
</blockquote>
<hr>
<h2 id="📈-6-性能指标解读"><a href="#📈-6-性能指标解读" class="headerlink" title="📈 6. 性能指标解读"></a>📈 6. 性能指标解读</h2><table>
<thead>
<tr>
<th>指标</th>
<th>含义</th>
<th>关键参考值</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Queries per second</strong></td>
<td>每秒查询数 (QPS)</td>
<td>核心性能指标</td>
</tr>
<tr>
<td><strong>Average latency</strong></td>
<td>平均响应延迟</td>
<td>&lt; 2ms 为优秀</td>
</tr>
<tr>
<td><strong>Dropped packets</strong></td>
<td>丢包率</td>
<td>理论应为 0</td>
</tr>
<tr>
<td><strong>RTT StdDev</strong></td>
<td>响应抖动</td>
<td>越小越稳定</td>
</tr>
<tr>
<td><strong>CPU SoftIRQ Balance</strong></td>
<td>各核软中断均衡度</td>
<td>CPU0 不应长期100%</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧠-7-高级应用场景"><a href="#🧠-7-高级应用场景" class="headerlink" title="🧠 7. 高级应用场景"></a>🧠 7. 高级应用场景</h2><table>
<thead>
<tr>
<th>场景</th>
<th>目标</th>
<th>推荐配置</th>
</tr>
</thead>
<tbody><tr>
<td><strong>软中断均衡验证</strong></td>
<td>调整 <code>ethtool -X</code>, <code>irqbalance</code>, <code>taskset</code></td>
<td><code>-t 8 -T 5000</code> 配合 <code>/proc/softirqs</code></td>
</tr>
<tr>
<td><strong>CoreDNS 性能测试</strong></td>
<td>验证集群内 DNS 服务稳定性</td>
<td><code>dnsperf -s &lt;clusterDNS&gt;</code></td>
</tr>
<tr>
<td><strong>边缘节点压力测试</strong></td>
<td>验证边缘 CoreDNS 容量</td>
<td>增加 <code>-c 100 -Q 80000</code></td>
</tr>
<tr>
<td><strong>Ingress &#x2F; API 域名解析链路压测</strong></td>
<td>验证上层流量入口延迟</td>
<td>将 <code>dnsperf</code> 与 <code>wrk</code>、<code>iperf3</code> 结合使用</td>
</tr>
<tr>
<td><strong>BIND &#x2F; PDNS 优化验证</strong></td>
<td>调整线程数、缓存大小</td>
<td>对比 QPS 与平均延迟变化</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧾-8-典型验证流程（软中断均衡实验）"><a href="#🧾-8-典型验证流程（软中断均衡实验）" class="headerlink" title="🧾 8. 典型验证流程（软中断均衡实验）"></a>🧾 8. 典型验证流程（软中断均衡实验）</h2><ol>
<li><p><strong>准备域名数据：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; queries.txt &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">www.baidu.com. A</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>绑定中断核（如只绑定 CPU0）：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> irq <span class="keyword">in</span> $(grep eth0 /proc/interrupts | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> | sed <span class="string">&#x27;s/://&#x27;</span>); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> 1 &gt; /proc/irq/<span class="variable">$irq</span>/smp_affinity</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行 dnsperf 压测：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dnsperf -s 10.16.13.14 -d queries.txt -t 8 -Q 10000 -l 30</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>观察软中断分布：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch -n1 <span class="string">&quot;grep NET_RX /proc/softirqs&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调整中断亲和性，重新压测对比。</strong></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>中断故事</title>
    <url>/2025/11/07/%E4%B8%AD%E6%96%AD%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="NAPI机制详解与快递站的故事-📦"><a href="#NAPI机制详解与快递站的故事-📦" class="headerlink" title="NAPI机制详解与快递站的故事 📦"></a>NAPI机制详解与快递站的故事 📦</h1><h2 id="一、NAPI在系统中的存在形式"><a href="#一、NAPI在系统中的存在形式" class="headerlink" title="一、NAPI在系统中的存在形式"></a>一、NAPI在系统中的存在形式</h2><h3 id="❓-NAPI是进程吗？"><a href="#❓-NAPI是进程吗？" class="headerlink" title="❓ NAPI是进程吗？"></a>❓ NAPI是进程吗？</h3><p><strong>不是独立进程！</strong> NAPI是Linux内核网络子系统的一个<strong>机制&#x2F;框架</strong>，而不是一个可见的进程。</p>
<h3 id="🔍-在系统中如何体现？"><a href="#🔍-在系统中如何体现？" class="headerlink" title="🔍 在系统中如何体现？"></a>🔍 在系统中如何体现？</h3><h4 id="1-软中断上下文中运行"><a href="#1-软中断上下文中运行" class="headerlink" title="1. 软中断上下文中运行"></a>1. <strong>软中断上下文中运行</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看软中断处理线程（每个CPU一个）</span></span><br><span class="line">ps aux | grep ksoftirqd</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root         12  0.0  0.0      0     0 ?        S    10:00   0:00 [ksoftirqd/0]</span><br><span class="line">root         18  0.0  0.0      0     0 ?        S    10:00   0:00 [ksoftirqd/1]</span><br><span class="line">root         24  0.0  0.0      0     0 ?        S    10:00   0:00 [ksoftirqd/2]</span><br></pre></td></tr></table></figure>

<p><strong>NAPI就运行在这些 <code>ksoftirqd</code> 线程中！</strong></p>
<h4 id="2-每个网卡有自己的NAPI结构"><a href="#2-每个网卡有自己的NAPI结构" class="headerlink" title="2. 每个网卡有自己的NAPI结构"></a>2. <strong>每个网卡有自己的NAPI结构</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看网卡的NAPI统计</span></span><br><span class="line"><span class="built_in">cat</span> /proc/net/softnet_stat</span><br></pre></td></tr></table></figure>

<h4 id="3-可以通过内核参数调整"><a href="#3-可以通过内核参数调整" class="headerlink" title="3. 可以通过内核参数调整"></a>3. <strong>可以通过内核参数调整</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看NAPI相关参数</span></span><br><span class="line">sysctl -a | grep net.core</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、NAPI工作原理详解"><a href="#二、NAPI工作原理详解" class="headerlink" title="二、NAPI工作原理详解"></a>二、NAPI工作原理详解</h2><h3 id="🎯-核心思想：智能切换"><a href="#🎯-核心思想：智能切换" class="headerlink" title="🎯 核心思想：智能切换"></a>🎯 核心思想：智能切换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">低负载（包少） ──→ 中断模式（来一个处理一个）</span><br><span class="line">                     ↓</span><br><span class="line">                  负载上升</span><br><span class="line">                     ↓</span><br><span class="line">高负载（包多） ──→ 轮询模式（定时批量处理）</span><br></pre></td></tr></table></figure>

<h3 id="📊-工作流程图"><a href="#📊-工作流程图" class="headerlink" title="📊 工作流程图"></a>📊 工作流程图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">包到达 → 硬中断 → 触发NAPI → 开启轮询 → 批量处理</span><br><span class="line">                      ↓</span><br><span class="line">                  处理完毕</span><br><span class="line">                      ↓</span><br><span class="line">                队列空了 → 关闭轮询 → 等待下次中断</span><br></pre></td></tr></table></figure>

<h3 id="💡-为什么这样设计？"><a href="#💡-为什么这样设计？" class="headerlink" title="💡 为什么这样设计？"></a>💡 为什么这样设计？</h3><h4 id="问题1：纯中断模式的问题"><a href="#问题1：纯中断模式的问题" class="headerlink" title="问题1：纯中断模式的问题"></a><strong>问题1：纯中断模式的问题</strong></h4><ul>
<li>每来1个包就中断1次</li>
<li>高负载时（每秒100万个包）&#x3D; 100万次中断</li>
<li>CPU被中断打断，来回切换开销巨大</li>
</ul>
<h4 id="问题2：纯轮询模式的问题"><a href="#问题2：纯轮询模式的问题" class="headerlink" title="问题2：纯轮询模式的问题"></a><strong>问题2：纯轮询模式的问题</strong></h4><ul>
<li>没包也要不停查看，浪费CPU</li>
<li>低负载时响应延迟高</li>
</ul>
<h4 id="NAPI的解决方案：混合模式"><a href="#NAPI的解决方案：混合模式" class="headerlink" title="NAPI的解决方案：混合模式"></a><strong>NAPI的解决方案：混合模式</strong></h4><ul>
<li><strong>低负载</strong>：用中断（响应快）</li>
<li><strong>高负载</strong>：用轮询（效率高）</li>
<li><strong>动态切换</strong>：自动适应</li>
</ul>
<h3 id="🔧-NAPI的实现细节"><a href="#🔧-NAPI的实现细节" class="headerlink" title="🔧 NAPI的实现细节"></a>🔧 NAPI的实现细节</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">napi_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">poll_list</span>;</span>  <span class="comment">// 轮询列表</span></span><br><span class="line">    <span class="type">int</span> (*poll)(<span class="keyword">struct</span> napi_struct *, <span class="type">int</span>);  <span class="comment">// 轮询函数</span></span><br><span class="line">    <span class="type">int</span> weight;  <span class="comment">// 每次轮询处理的最大包数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网卡驱动注册NAPI</span></span><br><span class="line">netif_napi_add(dev, &amp;priv-&gt;napi, my_poll_function, <span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line">irq_handler() &#123;</span><br><span class="line">    disable_irq();  <span class="comment">// 关闭网卡中断</span></span><br><span class="line">    napi_schedule(&amp;priv-&gt;napi);  <span class="comment">// 启动NAPI轮询</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NAPI轮询函数</span></span><br><span class="line">my_poll_function(<span class="keyword">struct</span> napi_struct *napi, <span class="type">int</span> budget) &#123;</span><br><span class="line">    <span class="type">int</span> work_done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (work_done &lt; budget) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!more_packets())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        process_packet();</span><br><span class="line">        work_done++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (work_done &lt; budget) &#123;</span><br><span class="line">        napi_complete(napi);  <span class="comment">// 处理完了，关闭轮询</span></span><br><span class="line">        enable_irq();  <span class="comment">// 重新开启中断</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> work_done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、快递站的完整故事-📮"><a href="#三、快递站的完整故事-📮" class="headerlink" title="三、快递站的完整故事 📮"></a>三、快递站的完整故事 📮</h2><h3 id="🏢-故事背景设定"><a href="#🏢-故事背景设定" class="headerlink" title="🏢 故事背景设定"></a>🏢 故事背景设定</h3><p><strong>人物角色：</strong></p>
<ul>
<li><strong>网线</strong> &#x3D; 高速公路</li>
<li><strong>网卡（NIC1）</strong> &#x3D; 小区快递接收点</li>
<li><strong>门卫</strong> &#x3D; 硬件中断</li>
<li><strong>DMA搬运工</strong> &#x3D; 自动传送带机器人</li>
<li><strong>Ring Buffer</strong> &#x3D; 环形旋转仓库（8个格子）</li>
<li><strong>NAPI巡检员</strong> &#x3D; 智能快递管理员</li>
<li><strong>软中断处理员</strong> &#x3D; 后台分拣中心</li>
<li><strong>协议栈</strong> &#x3D; 快递最后一公里投递员</li>
<li><strong>应用程序</strong> &#x3D; 收件人</li>
</ul>
<hr>
<h3 id="📖-故事正文"><a href="#📖-故事正文" class="headerlink" title="📖 故事正文"></a>📖 故事正文</h3><h4 id="第一幕：平静的早晨（低负载）"><a href="#第一幕：平静的早晨（低负载）" class="headerlink" title="第一幕：平静的早晨（低负载）"></a><strong>第一幕：平静的早晨（低负载）</strong></h4><p>早上8点，阳光明媚。小区快递接收点很安静，偶尔有一两个快递到达。</p>
<p><strong>门卫老王（硬件中断）</strong> 坐在门口，悠闲地喝着茶。</p>
<p><em>叮咚！</em> 一个快递包裹从高速公路（网线）送到了接收点（网卡NIC1）。</p>
<p><strong>老王（硬件中断）：</strong> “哎呀，有快递了！” 他立刻按响门铃（触发中断），通知楼上的管理中心。</p>
<p><strong>DMA机器人（自动搬运工）</strong> 听到信号后，立刻启动，不需要任何人工操作，直接把包裹从接收点搬到了<strong>环形旋转仓库</strong>（Ring Buffer）的1号格子里。</p>
<p><strong>老王快速登记：</strong> “1号包裹已入库！” 然后继续回去喝茶。</p>
<p><strong>NAPI巡检员小李（轮询机制）</strong> 听到通知后过来查看：</p>
<ul>
<li>看了看仓库，只有1个包裹</li>
<li>拿起包裹，交给<strong>后台分拣中心</strong>（软中断处理）</li>
<li>分拣员快速处理，贴上标签，送给<strong>快递员</strong>（协议栈）</li>
<li>快递员查看地址（IP层），确认楼号和房间号（TCP&#x2F;UDP层），最后敲门交给<strong>收件人</strong>（应用程序）</li>
</ul>
<p>小李处理完后说：**”仓库空了，我继续等老王通知吧。”** （关闭轮询，回到中断模式）</p>
<hr>
<h4 id="第二幕：双11爆仓（高负载）"><a href="#第二幕：双11爆仓（高负载）" class="headerlink" title="第二幕：双11爆仓（高负载）"></a><strong>第二幕：双11爆仓（高负载）</strong></h4><p>中午12点，双11促销开始了！快递像雪片一样飞来！</p>
<p><em>叮咚！叮咚！叮咚！叮咚！</em> 每秒钟有<strong>成百上千个</strong>包裹到达！</p>
<p><strong>老王（硬件中断）</strong> 急得满头大汗：</p>
<ul>
<li>“1号包裹到了！”（按门铃）</li>
<li>“2号包裹到了！”（按门铃）</li>
<li>“3号包裹到了！”（按门铃）</li>
<li>…</li>
</ul>
<p>他发现自己<strong>光按门铃就按不过来</strong>了，手都快抽筋了！而且楼上的人也被频繁的门铃吵得工作效率下降！</p>
<p><strong>这时，NAPI巡检员小李（智能管理员）发现了问题：</strong></p>
<p><strong>小李：</strong> “老王，你别按了！我看这架势，包裹会源源不断来。你就专心让DMA机器人往仓库里放吧，我<strong>自己定时过来批量取</strong>就行了！”</p>
<p><strong>老王：</strong> “好！那我就不按门铃了！” （<strong>关闭中断</strong>）</p>
<p>于是，新的工作模式开始了：</p>
<ol>
<li><p><strong>DMA机器人</strong> 疯狂工作，不停地把包裹放入<strong>环形仓库</strong>的1→2→3→4→5→6→7→8→1→2…（循环使用）</p>
</li>
<li><p><strong>小李（NAPI轮询）</strong> 每隔一小段时间（比如几微秒）就来仓库看一眼：</p>
<ul>
<li>“哦，有64个包裹！” （budget&#x3D;64）</li>
<li>一次性拿走64个，交给<strong>后台分拣中心</strong>（软中断）</li>
<li>分拣中心开始批量处理：<ul>
<li>贴标签（添加协议信息）</li>
<li>分类（IP路由）</li>
<li>装车（送入协议栈）</li>
</ul>
</li>
<li><strong>快递员们</strong>（协议栈）批量投递到各家各户（应用程序）</li>
</ul>
</li>
<li><p><strong>关键优化：</strong></p>
<ul>
<li>老王不用频繁按门铃了（减少中断开销）</li>
<li>小李批量处理，效率高（一次拿64个）</li>
<li>仓库满了也不怕，DMA会覆盖旧数据（Ring Buffer特性）</li>
</ul>
</li>
</ol>
<hr>
<h4 id="第三幕：夜深人静（恢复低负载）"><a href="#第三幕：夜深人静（恢复低负载）" class="headerlink" title="第三幕：夜深人静（恢复低负载）"></a><strong>第三幕：夜深人静（恢复低负载）</strong></h4><p>晚上11点，双11活动结束，快递量骤减。</p>
<p><strong>小李（NAPI）</strong> 又来巡检了：</p>
<ul>
<li>第1次：拿了20个包裹</li>
<li>第2次：拿了5个包裹</li>
<li>第3次：拿了1个包裹</li>
<li>第4次：<strong>仓库空了！</strong></li>
</ul>
<p><strong>小李：</strong> “看来又恢复平静了。老王，你继续按门铃模式吧，我去休息了。”（<strong>关闭轮询，重新开启中断</strong>）</p>
<p><strong>老王：</strong> “好嘞！” （<strong>恢复中断模式</strong>）</p>
<p>系统又回到了开始的状态：有包裹就按门铃，NAPI按需响应。</p>
<hr>
<h2 id="四、关键知识点总结"><a href="#四、关键知识点总结" class="headerlink" title="四、关键知识点总结"></a>四、关键知识点总结</h2><h3 id="🎯-NAPI的精髓"><a href="#🎯-NAPI的精髓" class="headerlink" title="🎯 NAPI的精髓"></a>🎯 NAPI的精髓</h3><table>
<thead>
<tr>
<th>场景</th>
<th>模式</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><strong>低负载</strong></td>
<td>中断驱动</td>
<td>响应快，不浪费CPU</td>
</tr>
<tr>
<td><strong>高负载</strong></td>
<td>轮询驱动</td>
<td>减少中断，批量处理</td>
</tr>
<tr>
<td><strong>切换时机</strong></td>
<td>自动检测</td>
<td>队列满→开轮询；队列空→关轮询</td>
</tr>
</tbody></table>
<h3 id="🔑-记忆口诀"><a href="#🔑-记忆口诀" class="headerlink" title="🔑 记忆口诀"></a>🔑 记忆口诀</h3><p><strong>“包少按门铃，包多我自取”</strong></p>
<ul>
<li>包少（低负载）&#x3D; 中断模式（按门铃通知）</li>
<li>包多（高负载）&#x3D; 轮询模式（主动批量取）</li>
</ul>
<h3 id="📊-性能对比"><a href="#📊-性能对比" class="headerlink" title="📊 性能对比"></a>📊 性能对比</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">纯中断模式：</span><br><span class="line">  1,000,000 包/秒 × 1 中断/包 = 1,000,000 次中断 😱</span><br><span class="line"></span><br><span class="line">NAPI混合模式：</span><br><span class="line">  1,000,000 包/秒 ÷ 64 包/批 = 15,625 次轮询 😊</span><br><span class="line">  </span><br><span class="line">性能提升：约 60 倍！</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、实战查看"><a href="#五、实战查看" class="headerlink" title="五、实战查看"></a>五、实战查看</h2><h3 id="查看NAPI统计"><a href="#查看NAPI统计" class="headerlink" title="查看NAPI统计"></a>查看NAPI统计</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看软中断统计</span></span><br><span class="line"><span class="built_in">cat</span> /proc/softirqs</span><br></pre></td></tr></table></figure>

<h3 id="调整NAPI参数"><a href="#调整NAPI参数" class="headerlink" title="调整NAPI参数"></a>调整NAPI参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每次轮询最多处理的包数（budget）</span></span><br><span class="line">sysctl net.core.netdev_budget=300</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次轮询最长时间（微秒）</span></span><br><span class="line">sysctl net.core.netdev_budget_usecs=2000</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🎓-总结"><a href="#🎓-总结" class="headerlink" title="🎓 总结"></a>🎓 总结</h2><ul>
<li><strong>NAPI不是进程</strong>，是运行在<code>ksoftirqd</code>内核线程中的机制</li>
<li><strong>核心是智能切换</strong>：低负载用中断，高负载用轮询</li>
<li><strong>快递站故事</strong>：老王（中断）和小李（轮询）配合，应对不同流量</li>
<li><strong>性能提升</strong>：减少中断次数，提高批量处理效率</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
